<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<book lang="en">
<bookinfo>
    <title>The Nature of Code</title>
</bookinfo>
<preface>
<title></title>
<toc></toc>
</preface>
<chapter id="_introduction">
<title>Introduction</title>
<blockquote>
<attribution>
Woody Allen
</attribution>
<simpara>“I am two with nature.”</simpara>
</blockquote>
<simpara>Here we are: the beginning.  Well, almost the beginning. If it’s been a while since you’ve done any programming in Processing (or any math, for that matter), this introduction will get your mind back into computational thinking before we head into some of the more difficult and complex material.</simpara>
<simpara>In Chapter 1, we’re going to talk about the concept of a vector and how it will serve as the building block for simulating motion throughout this book.   But before we take that step, let’s think about what it means for something to simply move around the screen.   Let’s begin with one of the best-known and simplest simulations of motion—the Random Walk.</simpara>
<section id="intro_section1">
<title>I.1 Random Walks</title>
<simpara>Imagine you are standing in the middle of a balance beam.  Every ten seconds, you flip a coin.  Heads, take a step forward.  Tails, take a step backwards.   This is a random walk—a path defined as a series of random steps.    Stepping off that balance beam and onto the floor, you could perform a random walk in two dimensions by flipping that same coin twice with the following results:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Flip 1 </entry>
<entry align="left" valign="top">Flip 2 </entry>
<entry align="left" valign="top">Result</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Step forward.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Step right.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Step left.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Step backward.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Yes, this may seem like a particularly unsophisticated algorithm.  Nevertheless, random walks can be used to model phenomena that occur in the real world, from the movements of molecules in a gas to the behavior of a gambler spending a day at the casino.   For us, we begin this book studying a random walk with three goals in mind.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
We need to review a programming concept central to this book—object-oriented programming.  The random walker will serve as a template for how we will use object-oriented design to make things that move around a Processing window.
</simpara>
</listitem>
<listitem>
<simpara>
The random walk instigates the two questions that we will ask over and over again throughout this book: “How do we define the rules that govern the behavior of our objects?” and then “How do we implement these rules in Processing?”
</simpara>
</listitem>
<listitem>
<simpara>
Throughout the book, we’ll periodically need a basic understanding of randomness, probability, and Perlin noise.  The random walk will allow us to demonstrate a few key points that will come in handy later.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="intro_section2">
<title>I.2 The Random Walker Class</title>
<simpara>Let’s review a bit of object-oriented programming (“OOP”) first by building a “Walker” object.   This will be only a cursory review.  If you have never worked with OOP before, you may want something more comprehensive; I’d suggest stopping here and reviewing the <ulink url="http://processing.org/learning/objects/">basics on the Processing website</ulink> before continuing.</simpara>
<simpara>An <emphasis role="strong"><emphasis>object</emphasis></emphasis> in Processing is an entity that has both data and functionality.  We are looking to design a Walker object that both keeps track of its data (where it exists on the screen) and has the capability to perform certain actions (such as draw itself or take a step).</simpara>
<simpara>A <emphasis role="strong"><emphasis>class</emphasis></emphasis> is the template for building actual instances of objects.  Think of a class as the cookie cutter; the objects are the cookies themselves.    Let’s begin by defining this template—what it means to be a Walker object.</simpara>
<simpara>The Walker only needs two pieces of data—a number for its x-location and one for its y-location.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Walker {
  // Objects have data.
  int x;
  int y;</programlisting>
<simpara>Every class must have a constructor, a special function that is called when the object is first created.  You can think of it as the object’s <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>.   There, we’ll initialize the Walker’s starting location (in this case, the center of the window).</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Objects have a constructor where they are initialized.
  Walker() {
    x = width/2;
    y = height/2;
  }</programlisting>
<simpara>Finally, in addition to data, classes can be defined with functionality.  In this example, a Walker has two functions.   We first write a function to display itself (as a white dot).</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Objects have functions.
  void display() {
    stroke(255);
    point(x,y);
  }</programlisting>
<simpara>The second function directs the object to take a step.   Now, this is where things get a bit more interesting.   Remember that floor on which we were taking random steps?  Well, now we can use a Processing window in that same capacity.  There are four possible steps—a step to the right can be simulated by incrementing x ( x<literal>); to the left by decrementing x (x--); forward by going down a pixel (y</literal>); and backward by going up a pixel (y--).   How do we pick from these four choices?   Earlier we stated that we could flip two coins.  In Processing, however, when we want to randomly choose from a list of options, we can pick a random number using <emphasis role="strong"><phrase role="function">random()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void step() {
    // 0, 1, 2, or 3
    int choice = int(random(4));</programlisting>
<simpara>The above line of code picks a random floating point number between 0 and 4 and converts it to an integer, resulting in 0, 1, 2, or 3.   Technically speaking, the highest number will never be 4.0, but rather 3.999999999 (with as many 9s as there are decimal places); since the process of converting to an integer lops off the decimal place, the highest int we can get is 3.  Next, we take the appropriate step (left, right, up, or down) depending on which random number was picked.</simpara>
<programlisting language="java" linenumbering="unnumbered">    // The random “choice” determines our step.
    if (choice == 0) {
      x++;
    } else if (choice == 1) {
      x--;
    } else if (choice == 2) {
      y++;
    } else {
      y--;
    }
  }
}</programlisting>
<simpara>Now that we’ve written the class, it’s time to make an actual Walker object in the main part of our sketch—<emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.   Assuming we are looking to model a single random walk, we declare one global variable of type Walker.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A Walker object
Walker w;</programlisting>
<simpara>Then we create the object in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> by calling the constructor with the <emphasis role="strong"><phrase role="function">new</phrase></emphasis> operator.</simpara>
<simpara id="intro_example1"><emphasis role="strong"><phrase role="example">Example I.1: Traditional Random Walk</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(640,360);
  // Create the Walker.
  w = new Walker();  // [bold]
  background(0);
}</programlisting>
<simpara>Finally, during each cycle through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, we ask the Walker to take a step and draw a dot.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  //[full] Call functions on the Walker.
  w.step(); // [bold]
  w.display(); // [bold]
  //[end]
}</programlisting>
<simpara>Since we only draw the background once in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> (rather than clearing it continually each time through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>), we see the trail of the random walk in our Processing window.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_ex01.png" canvas="processingjs/intro/_I_1_RandomWalkTraditional/_I_1_RandomWalkTraditional.pde processingjs/intro/_I_1_RandomWalkTraditional/Walker.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>There are a couple improvements we could make to the random walker.  For one, this walker’s step choices are limited to four—up, down, left, and right.  But any given pixel in the window has eight possible neighbors, and a ninth possibility is to stay in the same place.</simpara>
<informalfigure id="intro_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_01.png" />
  </imageobject>
  <textobject><phrase>Figure I.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To implement a walker that can step to any neighboring pixel (or stay put) we could then pick a number between zero and eight (nine possible choices).  However, a more efficient way to write the code would be to simply pick from three possible steps along the x-axis (-1, 0, or 1) and three possible steps along the y-axis.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void step() {
    //[full] Yields -1, 0, or 1
    int stepx = int(random(3))-1;
    int stepy = int(random(3))-1;
    //[end]
    x += stepx;
    y += stepy;
  }</programlisting>
<simpara>Taking this a step further, we could use floating point numbers (i.e. decimal numbers) for x and y instead and move according to an arbitrary random value between -1 and 1.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void step() {
    //[full] Yields any floating point number between -1.0 and 1.0
    float stepx = random(-1, 1);
    float stepy = random(-1, 1);
    //[end]
    x += stepx;
    y += stepy;
  }</programlisting>
<simpara>All of these variations on the “traditional” random walk have one thing in common: at any moment in time, the probability that the walker will take a step in a given direction is equal to the probability that the walker will take a step in any direction.   In other words, if there are four possible steps, there is a one in four (or 25%) chance the walker will take any given step.  With nine possible steps, it’s a one in nine (or 11.1%) chance.</simpara>
<simpara>Conveniently, this is how the <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> function works.  Processing’s random number generator (which operates behind the scenes) produces what is known as a “uniform” distribution of numbers.   We can test this distribution with a Processing sketch that counts each time a random number is picked and graphs it as the height of a rectangle.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_ex02.png" canvas="processingjs/intro/_I_2_RandomDistribution/_I_2_RandomDistribution.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="intro_example2"><emphasis role="strong"><phrase role="example">Example I.2: Random number distribution</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// An array to keep track of how often random numbers are picked
int[] randomCounts;

void setup() {
  size(640,240);
  randomCounts = new int[20];
}

void draw() {
  background(255);

  // Pick a random number and increase the count.
  int index = int(random(randomCounts.length));
  randomCounts[index]++;

  //[full] Graphing the results
  stroke(0);
  fill(175);
  int w = width/randomCounts.length;
  for (int x = 0; x &lt; randomCounts.length; x++) {
    rect(x*w,height-randomCounts[x],w-1,randomCounts[x]);
  }
  //[end]
}</programlisting>
<simpara>The above screenshot shows the result of the sketch running for a few minutes.   Notice how each bar of the graph differs in height.   Our sample size (i.e. the number of random numbers we’ve picked) is rather small and there are some random discrepancies, where certain numbers are picked more often.  Over time, with a good random number generator, this would even out.</simpara>
<note>
<title>Pseudo-Random Numbers</title>
<simpara>The random numbers we get from the <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> function are not truly random and are therefore known as “pseudo-random.”  They are the result of a mathematical function that simulates randomness.  This function would yield a pattern over time, but that time period is so long that for us, it’s just as good as pure randomness!</simpara>
</note>
<example id="intro_exercise1">
<title>Exercise I.1</title>
<simpara>Create a random walker that has a tendency to move down and to the right.  (We’ll see the solution to this in the next section.)</simpara>
</example>
</section>
<section id="intro_section3">
<title>I.3 Probability and Non-Uniform Distributions</title>
<simpara>Remember when you first started programming in Processing?  Perhaps you wanted to draw a lot of circles on the screen.  So you said to yourself: “Oh, I know.  I’ll draw all these circles at random locations, with random sizes, and random colors.”   In a computer graphics system, it’s often easiest to seed a system with randomness.   In this book, however, we’re looking to build systems modeled on what we see in nature.  Defaulting to randomness is not a particularly thoughtful solution to a design problem—in particular, the kind of problems that involve creating an organic or natural-looking simulation.</simpara>
<simpara>With a few tricks, we can change the way we use <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> to produce “non-uniform” distributions of random numbers.    This will come in handy throughout the book as we look at a number of different scenarios.    When we examine genetic algorithms, for example, we’ll need a methodology for performing “selection”—which members of our population should be selected to pass their DNA down to the next generation.   Remember the concept of survival of the fittest?    Let’s say we have a population of monkeys evolving.  Not every monkey will have a equal chance of reproducing.  To simulate Darwinian evolution, we can’t simply pick two random monkeys to be parents.  We need the more “fit” ones to be more likely to be chosen.  We need to define the “probability of the fittest.”   For example, a particularly fast and strong monkey might have a 90% chance of procreating, while a weaker one has only a 10% chance.</simpara>
<simpara>Let’s review the basic principles of probability, first looking at “Single Event Probability,” i.e. the likelihood of something to occur.</simpara>
<simpara>Given a system with a certain number of possible outcomes, the probability of any given event occurring is the number of outcomes that qualify as that event divided by the total number of possible outcomes. The simplest example is a coin toss. There are a total of two possible outcomes (heads or tails). There is only one way to flip heads. Therefore, the probability of heads is one divided by two, i.e. 1/2 or 50%.</simpara>
<simpara>Consider a deck of fifty-two cards. The probability of drawing an ace from that deck is:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">number of aces / number of cards = 4 / 52 = 0.077 = ~ 8%</phrase></emphasis></simpara>
<simpara>The probability of drawing a diamond is:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">number of diamonds / number of cards = 13 / 52 = 0.25 = 25%</phrase></emphasis></simpara>
<simpara>We can also calculate the probability of multiple events occurring in sequence as the product of the individual probabilities of each event.</simpara>
<simpara>The probability of a coin coming up heads three times in a row is:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">(1/2) * (1/2) * (1/2) =  1/8 (or 0.125)</phrase></emphasis></simpara>
<simpara>In other words, a coin will land heads three times in a row one out of eight times (with each “time” being three tosses).</simpara>
<example id="intro_exercise2">
<title>Exercise I.2</title>
<simpara>What is the probability of drawing two aces in a row from the deck of cards?</simpara>
</example>
<simpara>There are a few different techniques for using the <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> function with probability in code. For example, if we fill an array with a selection of numbers (some repeated), we can randomly pick from that array and generate events based on what we select.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] stuff = new int[5]
//[full] 1 is stored in the array twice to increase its likelihood of being picked.
stuff[0] = 1;
stuff[1] = 1;
//[end]
stuff[2] = 2;
stuff[3] = 3;
stuff[4] = 3;
// Picking a random element from an array
int index = int(random(stuff.length));</programlisting>
<simpara>If you run this code, there will be a 40% chance of printing the value 1, a 20% chance of printing 2, and a 40% chance of printing 3.</simpara>
<simpara>Another strategy is to ask for a random number (for simplicity, we’ll consider random floating point values between 0 and 1) and allow an event to occur only if the random number we pick is within a certain range.  For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">// A probability of 10%
float prob = 0.10;
// A random floating point value between 0 and 1
float r = random(1);

//[full] If our random number is less than 0.1, do something!
if (r &lt; prob) {
   [inline]// Do something!
}
//[end]</programlisting>
<simpara>This same technique can also be applied to multiple outcomes.</simpara>
<simpara><emphasis role="strong"><emphasis>Outcome A — 60% | Outcome B — 10% | Outcome C — 30%</emphasis></emphasis></simpara>
<simpara>To implement this in code, we pick one random float and check where it falls.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>between 0.00 and 0.60 (60%) –&gt; outcome A</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>between 0.60 and 0.70 (10%) –&gt; outcome B</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>between 0.70 and 1.00 (30%) –&gt; outcome C</emphasis>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered">float num = random(1);

// If random number is less than .6
if (num &lt; 0.6) {
  println("Outcome A");
// Between 0.6 or 0.7
} else if (num &lt; 0.7) {
  println("Outcome B");
// Greater than 0.7
} else {
  println("Outcome C");
}</programlisting>
<simpara>We could use the above methodology to create a random walker that tends to move to the right.  Here is an example of a Walker with the following probabilities:</simpara>
<itemizedlist classname="packed">
<listitem>
<simpara>
<emphasis>chance of moving up:         20%</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>chance of moving down:       20%</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>chance of moving left:       20%</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>chance of moving right:      40%</emphasis>
</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_ex03.png" canvas="processingjs/intro/_I_3_RandomWalkTendsToRight/_I_3_RandomWalkTendsToRight.pde processingjs/intro/_I_3_RandomWalkTendsToRight/Walker.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="intro_example3"><emphasis role="strong"><phrase role="example">Example I.3: Walker that tends to move to the right</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void step() {

    float r = random(1);
    //[full] A 40% of moving to the right!
    if (r &lt; 0.4) {
      x++;
    //[end]
    } else if (r &lt; 0.6) {
      x--;
    } else if (r &lt; 0.8) {
      y++;
    } else {
      y--;
    }
  }</programlisting>
<example id="intro_exercise3">
<title>Exercise I.3</title>
<simpara>Create a random walker with dynamic probabilities.  For example, can you give it a 50% chance of moving in the direction of the mouse?</simpara>
</example>
</section>
<section id="intro_section4">
<title>I.4 A Normal Distribution of Random Numbers</title>
<simpara>Let’s go back to that population of simulated Processing monkeys.  Your program generates a thousand “Monkey” objects, each with a “height” value between 200 and 300 (as his is a world of monkeys that have heights between 200 and 300 pixels).</simpara>
<programlisting language="java" linenumbering="unnumbered">float h = random(200,300);</programlisting>
<simpara>Does this accurately depict the heights of real-world beings?   Think of a crowded sidewalk in New York City.   Pick any person off the street and it may appear that their height is random.  Nevertheless, it’s not the kind of random that the <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> produces.   People’s heights are not uniformly distributed; there are a great deal more people of average height than there are very tall or very short ones.   To simulate nature, we may want it to be more likely that our monkeys are of average height (250 pixels), yet allow them to still on occasion be very short or very tall.</simpara>
<simpara>A distribution of values that cluster around an average (referred to as the “mean”) is known as a “normal” distribution.   It is also called the Gaussian distribution (named for mathematician Carl Friedrich Gauss) or, if you are French, the Laplacian distribution (named for Pierre-Simon Laplace).  Both mathematicians were working concurrently in the early nineteenth century on defining such a distribution.</simpara>
<simpara>When you graph the distribution, you get something that looks like the following, informally known as the bell curve.</simpara>
<informalfigure id="intro_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_02.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure I.2</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="intro_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_03.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure I.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The curve is generated by a mathematical function that defines the probability of any given value occurring as a function of the mean (often written as μ, the Greek letter <emphasis>mu</emphasis>) and standard deviation (σ, the Greek letter <emphasis>sigma</emphasis>).</simpara>
<simpara>The mean is pretty easy to understand.  In the case of our height values between 200 and 300, you probably have an intuitive sense of the mean (i.e. average) as 250. However, what if I were to say that the standard deviation is 3 or 15?   What does this mean for the numbers?  The graphs above should give us a hint. The graph on the left shows us the distribution with a very low standard deviation, where the majority of the values cluster closely around the mean.  The graph on the right shows us a higher standard deviation, where the values are more evenly spread out from the average.</simpara>
<simpara>The numbers work out as follows.  Given a population, 68% of the members of that population will have values in the range of one standard deviation from the mean, 98% within two standard deviations, and 99.7% within three standard deviations.   Given a standard deviation of five pixels, only 0.3% of the monkey heights will be less than 235 pixels (three standard deviations below the mean of 250) or greater than 265 pixels (three standard deviations above the mean of 250).</simpara>
<note>
<title>Calculating Mean and Standard Deviation</title>
<simpara>Consider a class of ten students who receive the following scores (out of 100) on a test:</simpara>
<simpara><emphasis>85, 82, 88, 86, 85, 93, 98, 40, 73, 83</emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>The mean is the average:  81.3</emphasis></emphasis></simpara>
<simpara>The standard deviation is calculated as the square root of the average of the squares of deviations around the mean. In other words, take the difference from the mean for each person and square it (variance). Calculate the average of all these values and take the square root as our standard deviation.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Score  </entry>
<entry align="left" valign="top">Difference from Mean </entry>
<entry align="left" valign="top">Variance</entry>
</row>
</thead>
<tfoot>
<row>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Average Variance:</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>254.23</simpara></entry>
</row>
</tfoot>
<tbody>
<row>
<entry align="left" valign="top"><simpara>85</simpara></entry>
<entry align="left" valign="top"><simpara>85-81.3 = 3.7</simpara></entry>
<entry align="left" valign="top"><simpara>(3.7)<superscript>2</superscript> = 13.69</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>40-81.3 = -41.3</simpara></entry>
<entry align="left" valign="top"><simpara>(-41.3)<superscript>2</superscript> = 1705.69</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>etc.</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong"><emphasis>The standard deviation is the square root of the average variance = 15.13</emphasis></emphasis></simpara>
</note>
<simpara>Luckily for us, to use a normal distribution of random numbers in a Processing sketch, we don’t have to do any of these calculations ourselves.   Instead, we can make use of a class known as Random, which we get for free as part of the default Java libraries imported into Processing (see <ulink url="http://docs.oracle.com/javase/6/docs/api/java/util/Random.html">the JavaDocs</ulink> for more information).</simpara>
<simpara>To use the Random class, we must first declare a variable of type Random and create the Random object in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">// We use the variable name “generator” as what we
// have here can be thought of as a random number generator.
Random generator;

void setup() {
  size(640,360);
  generator = new Random();
}</programlisting>
<simpara>If we want to produce a random number with a normal (or Gaussian) distribution each time we run through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, it’s as easy as calling the function <emphasis role="strong"><phrase role="function">nextGaussian()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  // Asking for a Gaussian random number
  float num = generator.nextGaussian();
}</programlisting>
<simpara>Here’s the thing.  What are we supposed to do with this value?  What if we wanted to use it, for example, to assign the x-position of a shape we draw on screen?</simpara>
<simpara>The <emphasis role="strong"><phrase role="function">nextGaussian()</phrase></emphasis> function returns a normal distribution of random numbers with the following parameters: <emphasis role="strong"><emphasis>a mean of zero</emphasis></emphasis> and <emphasis role="strong"><emphasis>a standard deviation of one</emphasis></emphasis>.    Let’s say we want a mean of 360 (the center horizontal pixel in a window of width 640) and a standard deviation of 60 pixels.   We can adjust the value to our parameters by multiplying it by the standard deviation and adding the mean.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_ex04.png" canvas="processingjs/intro/_I_4_Gaussian/_I_4_Gaussian.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="intro_example4"><emphasis role="strong"><phrase role="example">Example I.4: Gaussian distribution</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  // Note nextGaussian() returns a double.
  float num = (float) generator.nextGaussian();
  float sd = 60;
  float mean = 360;

  // Multiply by standard deviation and add the mean.
  float x = sd * num + mean;

  noStroke();
  fill(255,10);
  ellipse(x,180,16,16);
}</programlisting>
<simpara>By drawing the ellipses on top of each other with some transparency, we can actually see the distribution.  The brightest spot is near the center, where most of the values cluster, but every so often circles are drawn farther to the right or left of the center.</simpara>
<example id="intro_exercise4">
<title>Exercise I.4</title>
<simpara>Consider a simulation of paint splatter drawn as a collection of colored dots. Most of the paint clusters around a central location, but some dots do splatter out towards the edges.  Can you use a normal distribution of random numbers to generate the locations of the dots?  Can you also use a normal distribution of random numbers to generate a palette of color?</simpara>
</example>
<example id="intro_exercise5">
<title>Exercise I.5</title>
<simpara>A Gaussian random walk is defined as one in which the step size (how far you move in a given direction) is generated with a normal distribution.  Implement this variation of our random walk.</simpara>
</example>
</section>
<section id="intro_section5">
<title>I.5 A Custom Distribution of Random Numbers</title>
<simpara>There will come a time in your life when you do not want a uniform distribution of random values, or a Gaussian one.   Let’s imagine for a moment that you are a random walker in search of food.   Moving randomly around a space seems like a reasonable strategy for finding something to eat.   After all, you don’t know where the food is, so you might as well search randomly until you find it.  The problem, as you may have noticed, is that random walkers return to previously visited locations many times (this is known as “oversampling.”)   One strategy to avoid such a problem is to, every so often, take a very large step.   This allows the walker to forage randomly around a specific location while periodically jumping very far away to reduce the amount of oversampling.   This variation on the random walk (known as a Lévy flight) requires a custom set of probabilities.   Though not an exact implementation of a Lévy flight, we could state the probability distribution as follows: the longer the step, the less likely it is to be picked; the shorter the step, the more likely.</simpara>
<simpara>Earlier in this prologue, we saw that we could generate custom probability distributions by filling an array with values (some duplicated so that they would be picked more frequently) or by testing the result of <emphasis role="strong"><phrase role="function">random()</phrase></emphasis>.  Certainly, we could implement a Levy flight by saying there is a 1% chance of the walker taking a large step.</simpara>
<programlisting language="java" linenumbering="unnumbered">float r = random(1);
// A 1% chance of taking a large step
if (r &lt; 0.01) {
  xstep = random(-100,100);
  ystep - random(-100,100);
} else {
  xstep = random(-1,1);
  ystep - random(-1,1);
}</programlisting>
<simpara>However, this reduces the probabilities to a fixed number of options.  What if we wanted to make a more general rule—the higher a number, the more likely it is to be picked?  3.145 would be more likely to be picked than 3.144, even if that likelihood is just a tiny bit greater.  In other words, if x is the random number, we could map the likelihood on the y-axis with y = x.</simpara>
<informalfigure id="intro_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_04.png" />
  </imageobject>
  <textobject><phrase>Figure I.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If we can figure out how to generate a distribution of random numbers according to the above graph, then we will be able to apply the same methodology to any curve for which we have a formula.</simpara>
<simpara>One solution is to pick two random numbers instead of one.  The first random number is just that, a random number.  The second one, however, is what we’ll call a “qualifying random value.”  It will tell us whether to use the first one or throw it away and pick another one.  Numbers that have an easier time “qualifying” will be picked more often, and numbers that rarely qualify will be picked infrequently.   Here are the steps (for now, let’s consider only random values between 0 and 1.)</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Pick a random number: R1
</simpara>
</listitem>
<listitem>
<simpara>
Compute a probability P that R1 should qualify.  Let’s try: P = R1.
</simpara>
</listitem>
<listitem>
<simpara>
Pick another random number: R2
</simpara>
</listitem>
<listitem>
<simpara>
If R2 is less than P, then we have found our number—R1!
</simpara>
</listitem>
<listitem>
<simpara>
If R2 is not less than P, go back to step 1 and start over.
</simpara>
</listitem>
</orderedlist>
<simpara>Here we are saying that the likelihood that a random value will qualify is equal to the random number itself.  Let’s say we pick 0.1 for R1.  This means that R1 will have a 10% chance of qualifying.  If we pick 0.83 for R1 then it will have a 83% chance of qualifying.  The higher the number, the greater the likelihood that we will actually use it.</simpara>
<simpara>Here is a function (named for the Monte Carlo method, which was named for the Monte Carlo casino) that implements the above algorithm, returning a random value between zero and one.</simpara>
<programlisting language="java" linenumbering="unnumbered">float montecarlo() {
  // We do this “forever” until we find a qualifying random value.
  while (true) {
    // Pick a random value.
    float r1 = random(1);
    // Assign a probability.
    float probability = r1;
    // Pick a second random value.
    float r2 = random(1);

    //[full] Does it qualify?  If so, we’re done!
    if (r2 &lt; probability) {
      return r1;
    }
    //[end]
  }
}</programlisting>
<example id="intro_exercise6">
<title>Exercise I.6</title>
<simpara>Use a custom probability distribution to vary the size of a step taken by the random walker.   The step size can be achieved by affecting the range of values picked.  Can you map the probability exponentially—i.e. making the likelihood a value is picked equal to the value squared?</simpara>
<programlisting language="java" linenumbering="unnumbered">  // A uniform distribution of step sizes. Change this!
  float stepsize = random(-10,10);

  float stepx = random(-stepsize,stepsize);
  float stepy = random(-stepsize,stepsize);

  x += stepx;
  y += stepy;</programlisting>
<simpara>(Later we’ll see how to do this more efficiently using vectors.)</simpara>
</example>
</section>
<section id="intro_section6">
<title>I.6 Perlin Noise (A Smoother Approach)</title>
<simpara>One of the qualities of a good random number generator is that the numbers produced have no relationship.   If they exhibit no discernible pattern, they are considered <emphasis>random</emphasis>.</simpara>
<simpara>As we are beginning to see, a little bit of randomness can be a good thing when programming organic, lifelike behaviors.  However, randomness as the single guiding principle is not necessarily natural.   An algorithm known as “Perlin noise,” named for its inventor Ken Perlin, takes this concept into account.   Perlin developed the noise function while working on the original <emphasis>Tron</emphasis> movie in the early 1980s.  It was designed to create procedural textures for computer-generated effects; in 1997 Perlin won an Academy Award in Technical Achievement for this work. Perlin noise can be used to generate a variety of interesting effects such as clouds, landscapes, and patterned textures like marble.</simpara>
<simpara>“Perlin noise” has a more organic quality because it produces a naturally ordered (i.e. “smooth”) sequence of pseudo-random numbers.    The graph on the left below shows Perlin noise over time (the x-axis represents time; note how the curve is smooth) while the graph on the right shows pure random numbers over time.  (The code for generating these graphs is available with the accompanying book downloads.)</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_05.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure I.5: Noise</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_06.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure I.6: Random</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Processing has a built-in implementation of the Perlin noise algorithm with the function <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis>.  The <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> function takes one, two, or three arguments (referring to the “space” in which noise is computed: one, two, or three dimensions).  Let’s start by looking at one-dimensional noise.</simpara>
<note>
<title>Noise Detail</title>
<simpara>If you visit the Processing.org noise reference, you’ll find that noise is calculated over several “octaves.” You can change the number of octaves and their relative importance by calling the <ulink url="http://processing.org/reference/noiseDetail_.html">noiseDetail()</ulink> function.  This in turn changes how the noise function behaves.</simpara>
<simpara>You can learn more about how noise works from <ulink url="http://www.noisemachine.com/talk1/">Ken Perlin</ulink> himself.</simpara>
</note>
<simpara>Consider for a moment drawing a circle in our Processing window at a random x-location.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A random x-location
float x = random(0,width);
ellipse(x,180,16,16);</programlisting>
<simpara>Now, instead of a random x-location, we want a Perlin noise x-location that is “smoother.”  You might think that all you need to do is replace random() with noise(), i.e.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A noise x-location?
float x = noise(0,width); // [line-through]</programlisting>
<simpara>While conceptually this is exactly what we want to do—calculate an x-value that ranges between zero and the width according to Perlin noise—this is not the correct implementation.    While the arguments to the <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> function specify a range of values between a minimum and a maximum, <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> does not work this way.  Instead, the output range is fixed—it always returns a value between zero and one.  We’ll see in a moment that we can get around this easily with Processing’s <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function, but first we must examine what exactly <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> expects us to pass in as an argument.</simpara>
<simpara>We can think of one-dimensional Perlin noise as a linear sequence of values over time.   For example:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Time   </entry>
<entry align="left" valign="top">Noise Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0.365</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0.363</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>0.363</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>0.364</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>0.366</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Now, in order to access a particular noise value in Processing, we have to pass a specific moment in time to the <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> function.  For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">float n = noise(3);</programlisting>
<simpara>According to the above table, <emphasis role="strong"><phrase role="function">noise(3)</phrase></emphasis> will return 0.364 at time equals three. We could improve this by using a variable for “time” and asking for a noise value continuously in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">float t = 3;

void draw() {
  // We need the noise value for a specific "moment in time."
  float n = noise(t);
  println(n);
}</programlisting>
<simpara>The above code results in the same value printed over and over.   This is because we are asking for the result of the <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> function at the same point in “time”—3—over and over.  If we increment the “time” variable <emphasis role="strong"><phrase role="var">t</phrase></emphasis>, however, we’ll get a different result.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Typically we would start at time = 0, though this is arbitrary.
float t = 0;

void draw() {
  float n = noise(t);
  println(n);
  // Now, we move forward in time!
  t += 0.01;
}</programlisting>
<simpara>How quickly we increment “t” also affects the smoothness of the noise.   If we make large jumps in time, then we are skipping ahead and the values will be more random.</simpara>
<informalfigure id="intro_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_07.png" />
  </imageobject>
  <textobject><phrase>Figure I.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Try running the code several times, incrementing t by 0.01, 0.02, 0.05, 0.1, 0.0001, and you will see different results.</simpara>
<section id="_mapping_noise">
<title>Mapping Noise</title>
<simpara>Now we’re ready to answer the question of what to do with the noise value.   Once we have the value with a range between zero and one, it’s up to us to map that range to what we want.   The easiest way to do this is with Processing’s <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function.   The <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function takes five arguments.  First up is the value we want to map, in this case <emphasis role="strong"><phrase role="var">n</phrase></emphasis>.  Then we have to give it the value’s current range (minimum and maximum) followed by our desired range.</simpara>
<informalfigure id="intro_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_08.png" />
  </imageobject>
  <textobject><phrase>Figure I.8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In this case, we know that noise has a range between zero and one, but we’d like to draw our circle with a range between zero and the window’s width.</simpara>
<programlisting language="java" linenumbering="unnumbered">float t = 0;

void draw() {
  float n = noise(t);
  // Using map() to customize the range of Perlin noise
  float x = map(n,0,1,0,width);
  ellipse(x,180,16,16);

  t += 0.01;
}</programlisting>
<simpara>We can apply the exact same logic to our random walker, and assign both its x- and y-values according to Perlin noise.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_ex05.png" canvas="processingjs/intro/_I_5_NoiseWalk/_I_5_NoiseWalk.pde processingjs/intro/_I_5_NoiseWalk/Walker.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="intro_example5"><emphasis role="strong"><phrase role="example">Example I.5: Perlin Noise Walker</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Walker {
  float x,y;

  float tx,ty;

  Walker() {
    tx = 0;
    ty = 10000;
  }

  void step() {
    //[full] x- and y-location mapped from noise
    x = map(noise(tx), 0, 1, 0, width);
    y = map(noise(ty), 0, 1, 0, height);
    //[end]

    //[full] Move forward through “time.”
    tx += 0.01;
    ty += 0.01;
    //[end]
  }
}</programlisting>
<simpara>Notice how the above example requires an additional pair of variables: <emphasis role="strong"><phrase role="var">tx</phrase></emphasis> and  <emphasis role="strong"><phrase role="var">ty</phrase></emphasis>.  This is because we need to keep track of two “time” variables, one for the x-location of the walker and one for the y-location.   But there is something a bit odd about these variables. Why does <emphasis role="strong"><phrase role="var">tx</phrase></emphasis> start at zero and  <emphasis role="strong"><phrase role="var">ty</phrase></emphasis> at 10,000?  While these numbers are arbitrary choices, we have very specifically initialized our two time variables with different values.  This is because the noise function is deterministic; it gives you the same result for a specific time <emphasis role="strong"><phrase role="var">t</phrase></emphasis> each and every time.  If we asked for the the noise value at the same time <emphasis role="strong"><phrase role="var">t</phrase></emphasis> for both <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>, then <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis> would always be equal, meaning that the walker would only move along a diagonal.   Instead, we simply use two different parts of the noise space, starting at 0 for <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and 10,000 for <emphasis role="strong"><phrase role="var">y</phrase></emphasis> so that <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis> can appear to act independently of each other.</simpara>
<informalfigure id="intro_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_09.png" />
  </imageobject>
  <textobject><phrase>Figure I.9</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In truth, there is no true concept of “time” at play here.  It’s a useful metaphor to help us understand how the noise function works, but really what we have is space, rather than time.  The graph above depicts a linear sequence of noise values in a one-dimensional space, and we can ask for a value at a specific x-location whenever we want.   In examples, you will often see a variable named <emphasis role="strong"><phrase role="var">xoff</phrase></emphasis> to indicate the “x offset” along the noise graph rather than t for time (as noted in the diagram).</simpara>
<example id="intro_exercise7">
<title>Exercise I.7</title>
<simpara>In the above random walker, the result of the noise function is mapped directly to the walker’s location.  Create a random walker where you instead map the result of the <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> function to a walker’s step size.</simpara>
</example>
</section>
<section id="_two_dimensional_noise">
<title>Two-Dimensional Noise</title>
<simpara>This idea of noise values living in a one-dimensional space is important because it leads us right into a discussion of two-dimensional space.  Let’s think about this for a moment.  With one-dimensional noise, we have a sequence of values in which any given value is similar to its neighbor.  Because the value is in one dimension, it only has two neighbors: a value that comes before it (to the left on the graph) and one that comes after it (to the right).</simpara>
<informalfigure id="intro_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_10.png" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Figure I.10: 1D Noise</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="intro_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_11.png" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Figure I.11: 2D Noise</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Two-dimensional noise works exactly the same way conceptually.  The difference of course is that we aren’t looking at values along a linear path, but values that are sitting on a grid.  Think of a piece of graph paper with numbers written into each cell.  A given value will be similar to all of its neighbors: above, below, to the right, to the left, and along any diagonal.</simpara>
<simpara>If you were to visualize this graph paper with each value mapped to the brightness of a color, we would get something that looks like clouds.  White sits next to light gray, which sits next to gray, which sits next to dark grey, which sits next to black, which sits next to dark gray, etc.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_ex06.png" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_ex06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is what noise was originally invented for.  Tweak the parameters a bit, play with color, and the resulting image might look more like marble or wood or any other organic texture.</simpara>
<simpara>Let’s take a quick look at how you implement two-dimensional noise in Processing.  If you wanted to color every pixel of a window randomly, you would need a nested loop, one that accessed each pixel and picked a random brightness.</simpara>
<programlisting language="java" linenumbering="unnumbered">loadPixels();
for (int x = 0; x &lt; width; x++) {
  for (int y = 0; y &lt; height; y++) {
    // A random brightness!
    float bright = random(255);
    pixels[x+y*width] = color(bright);
  }
}
updatePixels();</programlisting>
<simpara>To color each pixel according to the <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis> function, we’ll do exactly the same thing, only instead of calling <emphasis role="strong"><phrase role="function">random()</phrase></emphasis> we’ll call <emphasis role="strong"><phrase role="function">noise()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">   // A perlin noise brightness!
   float bright = map(noise(x,y),0,1,0,255); // [bold]</programlisting>
<simpara>This is a nice start conceptually—it gives you a noise value for every (x,y) location in our two-dimensional space.  The problem is that this won’t have the cloudy quality we want.  Jumping from pixel 200 to pixel 201 is too large of a jump through noise.  Remember, when we worked with one-dimensional noise, we incremented our “time” variable by 0.01 each frame, not by 1!    A pretty good solution to this problem is to just use different variables for the noise arguments.  For example, we could increment a variable called <emphasis role="strong"><phrase role="var">xoff</phrase></emphasis> each time we move horizontally, and a yoff variable each time we move vertically through the nested loops.</simpara>
<simpara id="intro_example6"><emphasis role="strong"><phrase role="example">Example I.6: 2D Perlin Noise</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// Start xoff at 0.
float xoff = 0.0; // [bold]

for (int x = 0; x &lt; width; x++) {
  // For every xoff, start yoff at 0.
  float yoff = 0.0; // [bold]

  for (int y = 0; y &lt; height; y++) {
    // Use xoff and yoff for noise().
    float bright = map(noise(xoff,yoff),0,1,0,255);     // [bold]
    // Use x and y for pixel location.
    pixels[x+y*width] = color(bright);
    // Increment yoff
    yoff += 0.01; // [bold]
  }
  // Increment xoff
  xoff += 0.01;  // [bold]
}</programlisting>
<example id="intro_exercise8">
<title>Exercise I.8</title>
<simpara>Play with color, <emphasis role="strong"><phrase role="function">noiseDetail()</phrase></emphasis>, and the rate at which <emphasis role="strong"><phrase role="var">xoff</phrase></emphasis> and <emphasis role="strong"><phrase role="var">yoff</phrase></emphasis> are incremented to achieve different visual effects.</simpara>
</example>
<example id="intro_exercise9">
<title>Exercise I.9</title>
<simpara>Add a third argument to noise that increments once per cycle through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> to animate the two-dimensional noise.</simpara>
</example>
<example id="intro_exercise10">
<title>Exercise I.10</title>
<simpara>Use the noise values as the heights of a landscape.  See the screenshot below as a reference.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_exc10.png" />
  </imageobject>
  <textobject><phrase>imgs/intro/intro_exc10.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara>We’ve examined several traditional uses of Perlin noise in this section.  With one-dimensional noise, we used smooth values to assign the location of an object to give the appearance of wandering.  With two-dimensional noise, we created a cloudy pattern with smoothed values on a plane of pixels.  It’s important to remember, however, that Perlin noise values are just that—values.  They aren’t inherently tied to pixel locations or color.  Any example in this book that has a variable could be controlled via Perlin noise.  When we model a wind force, its strength could be controlled by Perlin noise.  Same goes for the angles between the branches in a fractal tree pattern, or the the speed and direction of objects moving along a grid in a flow field simulation.</simpara>
<informalfigure id="intro_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_12.png" canvas="processingjs/intro/TreeStochasticNoise/TreeStochasticNoise.pde" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure I.12: Tree with Perlin noise</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="intro_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro/intro_13.png" canvas="processingjs/intro/_6_04_Flowfield/_6_04_Flowfield.pde processingjs/intro/_6_04_Flowfield/FlowField.pde processingjs/intro/_6_04_Flowfield/Vehicle.pde" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure I.13: Flow field with Perlin noise</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section id="intro_section7">
<title>I.7 Onward</title>
<simpara>We began this chapter by talking about how randomness can be a crutch.  In many ways, it’s the most obvious answer to the kinds of questions we ask continuously—how should this object move? What color should it be?  This obvious answer, however, can also be a lazy one.</simpara>
<simpara>As we finish off the introduction, it’s also worth noting that we could just as easily fall into the trap of using Perlin noise as a crutch.   How should this object move? Perlin noise!  What color should it be?  Perlin noise!  How fast should it grow?  Perlin noise!</simpara>
<simpara>The point of all of this is not to say that you should or should not use randomness.  Or that you should or should not use Perlin noise.   The point is that the rules of your system are defined by you and the larger your toolbox, the more choices you’ll have as you implement those rules.   The goal of this book is to fill your toolbox.  If all you know is random, then your design thinking is limited.  Sure, Perlin noise helps, but you’ll need more.  A lot more.</simpara>
<simpara>I think we’re ready to begin.</simpara>
</section>
</chapter>
<chapter id="_chapter_1_vectors">
<title>Chapter 1.  Vectors</title>
<blockquote>
<attribution>
Captain Oveur (Airplane)
</attribution>
<simpara>“Roger, Roger. What&#8217;s our vector, Victor?”</simpara>
</blockquote>
<simpara>This book is all about looking at the world around us and coming up with clever ways to simulate that world with code.  Divided into three parts, the book will start by looking at basic physics—how an apple falls from a tree, a pendulum swings in the air, the earth revolves around the sun, etc.  Absolutely everything contained within the first five chapters of this book requires the use of the most basic building block for programming motion—the <emphasis role="strong"><emphasis>vector</emphasis></emphasis>.   And so this is where we begin our story.</simpara>
<simpara>Now, the word <emphasis role="strong"><emphasis>vector</emphasis></emphasis> can mean a lot of different things. Vector is the name of a new wave rock band formed in Sacramento, CA in the early 1980s.  It’s the name of a breakfast cereal manufactured by Kellogg’s Canada.   In the field of epidemiology, a vector is used to describe an organism that transmits infection from one host to another.  In the C++ programming language, a Vector (std::vector) is an implementation of a dynamically resizable array data structure.  While all these definitions are interesting, they’re not what we are looking for.   What we want is called a <emphasis role="strong">Euclidean vector</emphasis> (named for the Greek mathematician Euclid and also known as a geometric vector).  When you see the term “vector” in this book, you can assume it refers to a Euclidean vector defined as:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">A vector is an entity that has both magnitude and direction</phrase></emphasis></simpara>
<simpara>A vector is typically drawn as a arrow; the direction is indicated by where the arrow is pointing, and the magnitude by the length of the arrow itself.</simpara>
<informalfigure id="chapter01_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_01.png" classname="half-width" />
  </imageobject>
  <textobject><phrase>Figure 1.1: A Vector (draw as an arrow) has magnitude (length of arrow) and direction (which way it is pointing)</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the Figure 1.1, the vector is drawn as an arrow from point A to point B and serves as an instruction for how to travel from A to B.</simpara>
<section id="chapter01_section1">
<title>1.1 Vectors, You Complete Me</title>
<simpara>Before we dive into more of the details about vectors, let’s look at a basic Processing example that demonstrates why we should care about vectors in the first place.  If you’ve read any of the introductory Processing textbooks or taken a class on programming with Processing (and hopefully you’ve done one of these things to help prepare you for this book), you probably, at one point or another, learned to how to write a simple bouncing ball sketch.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex01.png" canvas="processingjs/chapter01/_1_1_bouncingball_novectors/_1_1_bouncingball_novectors.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>If you are reading this book as a PDF or in print, then you will only see screenshots of the code.  Motion, of course, is a key element of our discussion, so to the extent possible, the static screenshots will include trails to give a sense of the behavior. For more about how to draw trails, see the code examples available for download.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example1"><emphasis role="strong"><phrase role="example">Example 1.1: Bouncing ball with no vectors</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">//[full] Variables for location and speed of ball.
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;
//[end]

//[full] Remember how Processing works?  setup() is executed once when the sketch starts and draw() loops forever and ever (until you quit).
void setup() {
  size(200,200);
  smooth();
  background(255);
}
//[end]

void draw() {
  background(255);

  //[full] Move the ball according to its speed.
  x = x + xspeed;
  y = y + yspeed;
  //[end]

  //[full] Check for bouncing
  if ((x &gt; width) || (x &lt; 0)) {
    xspeed = xspeed * -1;
  }
  if ((y &gt; height) || (y &lt; 0)) {
    yspeed = yspeed * -1;
  }
  //[end]

  stroke(0);
  fill(175);
  // Display the ball at the location x,y.
  ellipse(x,y,16,16);
}</programlisting>
<simpara>In the above example, we have a very simple world—a blank canvas with a circular shape (a “ball”) traveling around.  This ball has some properties, which are represented in the code as variables.</simpara>
<note>
<variablelist>
<varlistentry>
<term>
Location
</term>
<listitem>
<simpara>
<emphasis>x and y</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Speed
</term>
<listitem>
<simpara>
<emphasis>xspeed and yspeed</emphasis>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</note>
<simpara>In a more advanced sketch, we could imagine having many more variables:</simpara>
<note>
<variablelist>
<varlistentry>
<term>
Acceleration
</term>
<listitem>
<simpara>
<emphasis>xacceleration and yacceleration</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Target location
</term>
<listitem>
<simpara>
<emphasis>xtarget and ytarget</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Wind
</term>
<listitem>
<simpara>
<emphasis>xwind and ywind</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Friction
</term>
<listitem>
<simpara>
<emphasis>xfriction and yfriction</emphasis>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</note>
<simpara>It’s becoming more and more clear that for every concept in this world (wind, location, acceleration, etc.), we need two variables.  And this is only a two-dimensional world. In a 3D world, we’ll need <emphasis role="strong"><phrase role="var">x</phrase></emphasis>, <emphasis role="strong"><phrase role="var">y</phrase></emphasis>, <emphasis role="strong"><phrase role="var">z</phrase></emphasis>, <emphasis role="strong"><phrase role="var">xspeed</phrase></emphasis>, <emphasis role="strong"><phrase role="var">yspeed</phrase></emphasis>, <emphasis role="strong"><phrase role="var">zspeed</phrase></emphasis>, and so on.</simpara>
<simpara>Wouldn’t it be nice if we could simplify our code and use fewer variables?</simpara>
<simpara>Instead of:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x;
float y;
float xspeed;
float yspeed;</programlisting>
<simpara>Wouldn’t it be nice to have. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">Vector location;
Vector speed;</programlisting>
<simpara>Taking this first step in using vectors won’t allow us to do anything new.  Just adding vectors won’t magically make your Processing sketches simulate physics; however, they will simplify your code and provide a set of functions for common mathematical operations that happen over and over and over again while programming motion.</simpara>
<simpara>As an introduction to vectors, we’re going to live in two dimensions for quite some time (at least until we get through the first several chapters.)  All of these examples can be fairly easily extended to three dimensions (and the class we will use — <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> — allows for three dimensions.)  However, for the time being, it’s easier to start with just two.</simpara>
</section>
<section id="chapter01_section2">
<title>1.2 Vectors: What are they to us Processing programmers?</title>
<simpara>One way to think of a vector is the difference between two points.   Consider how you might go about providing instructions to walk from one point to another.</simpara>
<simpara>Here are some vectors and possible translations:</simpara>
<informalfigure id="chapter01_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_02.png" />
  </imageobject>
  <textobject><phrase>Figure 1.2</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<variablelist>
<varlistentry>
<term>
(-15, 3)
</term>
<listitem>
<simpara>
<emphasis>Walk fifteen steps west, turn and walk three steps north.</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
(3, 4)
</term>
<listitem>
<simpara>
<emphasis>Walk three steps east, turn and walk five steps north.</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
(2, -1)
</term>
<listitem>
<simpara>
<emphasis>Walk two steps east, turn and walk one step south.</emphasis>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</note>
<simpara>You’ve probably done this before when programming motion.  For every frame of animation (i.e.  a single cycle through Processing’s <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop), you instruct each object on the screen to move a certain number of pixels horizontally and a certain number of pixels vertically.</simpara>
<informalfigure id="chapter01_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_03.png" />
  </imageobject>
  <textobject><phrase>Figure 1.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For every frame:</simpara>
<simpara><emphasis role="strong"><emphasis>new location = velocity applied to current location</emphasis></emphasis></simpara>
<simpara>If velocity is a vector (the difference between two points), what is location?   Is it a vector too?  Technically, one might argue that location is not a vector, since it’s not describing how to move from one point to another—it’s simply describing a singular point in space.  And so conceptually, we think of a location as different.</simpara>
<informalfigure id="chapter01_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_04.png" />
  </imageobject>
  <textobject><phrase>Figure 1.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Nevertheless, another way to describe a location is the path taken from the origin to reach that location. Hence, a location can be the vector representing the difference between location and origin.</simpara>
<simpara>Let’s examine the underlying data for both location and velocity.  In the bouncing ball example we had the following:</simpara>
<note>
<variablelist>
<varlistentry>
<term>
location
</term>
<listitem>
<simpara>
<emphasis>x,y</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
velocity
</term>
<listitem>
<simpara>
<emphasis>xspeed,yspeed</emphasis>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</note>
<simpara>Notice how we are <emphasis>storing the same data for both</emphasis> — two floating point numbers, an x and a y. If we were to write a vector class ourselves, we’d start with something rather basic:</simpara>
<programlisting language="java" linenumbering="unnumbered">class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

}</programlisting>
<simpara>At its core, a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> is just a convenient way to store two values (or three, as we’ll see in 3D examples.).</simpara>
<simpara>And so this &#8230;</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;</programlisting>
<simpara>&#8230; becomes &#8230;</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector location = new PVector(100,100);
PVector velocity = new PVector(1,3.3);</programlisting>
<simpara>Now that we have two vector objects (“location” and “velocity”), we’re ready to implement the algorithm for motion—location = location + velocity.   In Example 1.1, without vectors, we had:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add each speed to each location.
x = x + xspeed;
y = y + yspeed;</programlisting>
<simpara>In an ideal world, we would be able to rewrite the above as:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add the velocity vector to the location vector.
location = location + velocity;</programlisting>
<simpara>However, in Processing, the addition operator ‘+’ is reserved for primitive values (integers, floats, etc.) only.  Processing doesn’t know how to add two <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> objects together any more than it knows how to add two <emphasis role="strong"><phrase role="klass">PFont</phrase></emphasis> objects or <emphasis role="strong"><phrase role="klass">PImage</phrase></emphasis> objects.   Fortunately for us, the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class includes functions for common mathematical operations.</simpara>
</section>
<section id="chapter01_section3">
<title>1.3 Vector Addition</title>
<simpara>Before we continue looking at the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class and its <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> method (purely for the sake of learning since it’s already implemented for us in Processing itself), let’s examine vector addition using the notation found in math and physics textbooks</simpara>
<simpara>Vectors are typically written either in boldface type or with an arrow on top.  For the purposes of this book, to distinguish a <emphasis role="strong"><emphasis>vector</emphasis></emphasis> from a <emphasis role="strong">scalar</emphasis> (scalar refers to a single value, such as an integer or a floating point number), we’ll use the arrow notation:</simpara>
<itemizedlist>
<listitem>
<simpara>
Vector: &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;
</simpara>
</listitem>
<listitem>
<simpara>
Scalar: &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mi&gt;x &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;
</simpara>
</listitem>
</itemizedlist>
<simpara>Let’s say I have the following two vectors:</simpara>
<informalfigure id="chapter01_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_05.png" />
  </imageobject>
  <textobject><phrase>Figure 1.5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each vector has two components, an x and a y.  To add two vectors together we simply add both x’s and both y’s.</simpara>
<informalfigure id="chapter01_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_06.png" />
  </imageobject>
  <textobject><phrase>Figure 1.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In other words:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt;= &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt;+ &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>translates to:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>and therefore:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mn&gt; 5 &lt;/mn&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?></simpara>
<simpara>and therefore:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mn&gt; 8 &lt;/mn&gt;&lt;mo&gt; , &lt;/mo&gt;&lt;mn&gt; 6 &lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>Now that we understand how to add two vectors together, we can look at how addition is implemented in the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class itself.  Let’s write a function called <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> that takes as its argument another <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> object.</simpara>
<programlisting language="java" linenumbering="unnumbered">class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

  //[full] New! A function to add another PVector to this PVector.  Simply add the x components and the y components together.
  void add(PVector v) { // [bold]
    y = y + v.y; // [bold]
    x = x + v.x; // [bold]
  } // [bold]
  //[end]
}</programlisting>
<simpara>Now that we see how <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> is written inside of <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>, we can return to the <emphasis role="strong"><emphasis>location + velocity</emphasis></emphasis> algorithm with our bouncing ball example and implement vector addition:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add the current velocity to the location.
location = location + velocity; // [line-through]
location.add(velocity);</programlisting>
<simpara>And here we are, ready to rewrite the bouncing ball example using <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>.</simpara>
<simpara id="chapter01_example2"><emphasis role="strong"><phrase role="example">Example 1.2: Bouncing ball with PVector!</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// Instead of a bunch of floats, we now just have two PVector variables.
PVector location; // [bold]
PVector velocity; // [bold]

void setup() {
  size(200,200);
  smooth();
  location = new PVector(100,100); // [bold]
  velocity = new PVector(2.5,5); // [bold]
}

void draw() {
  background(255);

  location.add(velocity); // [bold]

  //[full] We still sometimes need to refer to the individual components of a PVector and can do so using the dot syntax: location.x, velocity.y, etc.
  if ((location.x &gt; width) || (location.x &lt; 0)) { // [bold]
    velocity.x = velocity.x * -1; // [bold]
  } // [bold]
  if ((location.y &gt; height) || (location.y &lt; 0)) { // [bold]
    velocity.y = velocity.y * -1; // [bold]
  } // [bold]
  //[end]

  stroke(0);
  fill(175);
  ellipse(location.x,location.y,16,16); // [bold]
}</programlisting>
<simpara>Now, you might feel somewhat disappointed.  After all, this may initially appear to have made the code more complicated than the original version.  While this is a perfectly reasonable and valid critique, it’s important to understand that we haven’t fully realized the power of programming with vectors just yet.   Looking at a simple bouncing ball and only implementing vector addition is just the first step.  As we move forward into a more complex world of multiple objects and multiple <emphasis role="strong"><emphasis>forces</emphasis></emphasis> (Chapter 2), the benefits of <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> will become more apparent.</simpara>
<simpara>We should, however, make note of an important aspect of the above transition to programming with vectors.  Even though we are using <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> objects to describe two values—the x and y of location and the x and y of velocity—we still often need to refer to the x and y components of each <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> individually.  When we go to draw an object in Processing, there’s no means for us to say:</simpara>
<programlisting language="java" linenumbering="unnumbered">ellipse(location,16,16); // [line-through]</programlisting>
<simpara>The <emphasis role="strong"><phrase role="function">ellipse()</phrase></emphasis> function does not allow for a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> as an argument.  An ellipse can only be drawn with two scalar values, an x coordinate and a y coordinate.  And so we must dig into the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> object and pull out the x and y components using object-oriented dot syntax.</simpara>
<programlisting language="java" linenumbering="unnumbered">ellipse(location.x,location.y,16,16);</programlisting>
<simpara>The same issue arises when testing if the circle has reached the edge of the window, and we need to access the individual components of both vectors: location and velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">if ((location.x &gt; width) || (location.x &lt; 0)) {
  velocity.x = velocity.x * -1;
}</programlisting>
<example id="chapter01_exercise1">
<title>Exercise 1.1</title>
<simpara>Find something you’ve previously made in Processing using separate <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis> variables and use PVectors instead.</simpara>
</example>
<example id="chapter01_exercise2">
<title>Exercise 1.2</title>
<simpara>Take any of the walker examples from the introduction and convert it to use PVectors.</simpara>
</example>
<example id="chapter01_exercise3">
<title>Exercise 1.3</title>
<simpara>Extend the bouncing ball with vectors example into 3D.  Can you get a sphere to bounce around a box?</simpara>
</example>
</section>
<section id="chapter01_section4">
<title>1.4 More Vector Math</title>
<simpara>Addition was really just the first step.   There are many mathematical operations that are commonly used with vectors.   Below is a comprehensive list of the operations available as functions in the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class.  We’ll go through a few of the key ones now.  As our examples get more and more sophisticated in later chapters, we’ll continue to reveal the details of more functions.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">add()</phrase></emphasis> — add vectors
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">sub()</phrase></emphasis> — subtract vectors
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">mult()</phrase></emphasis> — scale the vector with multiplication
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">div()</phrase></emphasis> — scale the vector with division
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">mag()</phrase></emphasis> — calculate the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">setMag()</phrase></emphasis> - set the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">normalize()</phrase></emphasis> — normalize the vector to unit length of 1
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">limit()</phrase></emphasis> — limit the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">heading2D()</phrase></emphasis> — the heading of a vector expressed as an angle
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">rotate()</phrase></emphasis> — rotate a 2D vector by an angle
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">lerp()</phrase></emphasis> - linear interpolate to another vector
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">dist()</phrase></emphasis> — the Euclidean distance between two vectors (considered as points)
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">angleBetween()</phrase></emphasis> — find the angle between two vectors
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">dot()</phrase></emphasis> — the dot product of two vectors
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">cross()</phrase></emphasis> — the cross product of two vectors (only relevant in three dimensions)
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">random2D()</phrase></emphasis> - make a random 2D vector
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">random3D()</phrase></emphasis> - make a random 3D vector
</simpara>
</listitem>
</itemizedlist>
<simpara>Having already covered addition, let’s start with subtraction.  This one’s not so bad; just take the plus sign and replace it with a minus!</simpara>
<section id="_vector_subtraction">
<title>Vector subtraction:</title>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt;= &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt;- &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>translates to:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<informalfigure id="chapter01_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_07.png" />
  </imageobject>
  <textobject><phrase>Figure 1.7: Vector Subtraction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>and the function inside <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> therefore looks like:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void sub(PVector v) {
    x = x - v.x;
    y = y - v.y;
  }</programlisting>
<simpara>The following example demonstrates vector subtraction by taking the difference between two points—the mouse location and the center of the window.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex03.png" canvas="processingjs/chapter01/_1_3_vector_subtraction/_1_3_vector_subtraction.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example3"><emphasis role="strong"><phrase role="example">Example 1.3: Vector subtraction</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
  smooth();
}

void draw() {
  background(255);

  //[full] Two PVectors, one for the mouse location and one for the center of the window.
  PVector mouse  = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  //[end]

  // PVector subtraction!
  mouse.sub(center);

  // Draw a line to represent the vector.
  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
<note>
<title>Basic Number Properties with Vectors</title>
<simpara>Both addition and subtraction with vectors follow the same algebraic rules as with real numbers.</simpara>
<simpara><emphasis role="strong"><emphasis>The commutative rule:</emphasis></emphasis>  &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;
<?asciidoc-br?>
<emphasis role="strong"><emphasis>The associative rule:</emphasis></emphasis>  &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>Fancy terminology and symbols aside, this is really quite a simple concept.  We’re just saying that common sense properties of addition apply to vectors as well.</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;
<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mn&gt; 1 &lt;/mn&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mn&gt; 1 &lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
</note>
<simpara>Moving on to multiplication, we have to think a little bit differently.  When we talk about multiplying a vector, what we typically mean is <emphasis role="strong"><emphasis>scaling</emphasis></emphasis> a vector.  In the case that we want to scale a vector to twice its size or one-third of its size (leaving its direction the same), we would say: “Multiply the vector by 2” or “Multiply the vector by 1/3.”   Note we are multiplying a vector by a scalar, a single number, not another vector.</simpara>
<simpara>To scale a vector, we multiply each component (x and y) by a scalar.</simpara>
</section>
<section id="_vector_multiplication">
<title>Vector multiplication:</title>
<informalfigure id="chapter01_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_08.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.8: Scaling a vector.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>translates to:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>Let’s look at an example with vector notation.</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;mo&gt; , &lt;/mo&gt;&lt;mn&gt; 7 &lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mn&gt; 7 &lt;/mn&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mn&gt; 3 &lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; w &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mn&gt; 9 &lt;/mn&gt;&lt;mo&gt; , &lt;/mo&gt;&lt;mn&gt; 11 &lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>The function inside the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class therefore is written as:</simpara>
<programlisting language="java" linenumbering="unnumbered">// With multiplication, the components of the vector are multiplied by a number.
void mult(float n) {
   x = x * n;
   y = y * n;
 }</programlisting>
<simpara>And implementing multiplication in code is as simple as:</simpara>
<programlisting language="java" linenumbering="unnumbered">// This PVector is now three times the size and is equal to (-9,21).
PVector u = new PVector(-3,7);
u.mult(3);</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex04.png" canvas="processingjs/chapter01/_1_4_vector_multiplication/_1_4_vector_multiplication.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example4"><emphasis role="strong"><phrase role="example">Example 1.4: Multiplying a vector</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
  smooth();
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).
  mouse.mult(0.5);

  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
<informalfigure id="chapter01_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_09.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.9</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Division works just like multiplication—we simply replace the multiplication sign (asterisk) with the division one (forward slash).</simpara>
<programlisting language="java" linenumbering="unnumbered">void div(float n) {
  x = x / n;
  y = y / n;
}

PVector u = new PVector(8,-4);
u.div(2);</programlisting>
<note>
<title>More Number Properties with Vectors</title>
<simpara>As with addition, basic algebraic rules of multiplication and division apply to vectors.</simpara>
<simpara>The associative rule: &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; m &lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mi&gt; m &lt;/mi&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
The distributive rule with 2 scalars, 1 vector: &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; m &lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mi&gt; m &lt;/mi&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;<?asciidoc-br?>
The distributive rule with 2 vectors, 1 scalar: &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;￼</simpara>
</note>
</section>
</section>
<section id="chapter01_section5">
<title>1.5 Vector Magnitude</title>
<simpara>Multiplication and division, as we just saw, are means by which the length of the vector can be changed without affecting direction.  Perhaps you’re wondering: “OK, so how do I know what the length of a vector is?  I know the components (<emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>), but how long (in pixels) is the actual arrow?!”</simpara>
<informalfigure id="chapter01_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_10.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.10: The length or “magnitude” of a vector &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&amp;#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt; is often written as: &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mo&gt; &amp;#x2225; &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &amp;#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; &amp;#x2225; &lt;/mo&gt;&lt;/mstyle&gt;&lt;/math&gt;</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Understanding how to calculate the length (also known as <emphasis role="strong"><emphasis>magnitude</emphasis></emphasis>) of a vector is incredibly useful and important.</simpara>
<simpara>Notice in the above diagram how the vector, drawn as an arrow and two components (<emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>), creates a right triangle.  The sides are the components and the hypotenuse is the arrow itself.   We’re very lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras developed a lovely formula to describe the relationship between the sides and hypotenuse of a right triangle.</simpara>
<informalfigure id="chapter01_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_11.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.11: The Pythagorean Theorem</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Pythagorean theorem: <emphasis role="strong"><phrase role="var">a</phrase></emphasis> squared plus <emphasis role="strong"><phrase role="var">b</phrase></emphasis> squared equals <emphasis role="strong"><phrase role="var">c</phrase></emphasis> squared.</simpara>
<simpara>Armed with this formula, we can now compute the magnitude of &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;&#x2192;&lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt; as follows:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mfenced open="∥" close="∥"&gt;&lt;mrow&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;msqrt&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; + &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; * &lt;/mo&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; y &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/msqrt&gt;&lt;/mstyle&gt;</simpara>
<simpara>or in <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">float mag() {
  return sqrt(x*x + y*y);
}</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex05.png" canvas="processingjs/chapter01/_1_5_vector_magnitude/_1_5_vector_magnitude.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example5"><emphasis role="strong"><phrase role="example">Example 1.5: Vector magnitude</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
  smooth();
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // The magnitude (i.e. length) of a vector can be accessed via the mag() function.  Here it is used as the width of a rectangle drawn at the top of the window.
  float m = mouse.mag();
  fill(0);
  rect(0,0,m,10);

  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
</section>
<section id="chapter01_section6">
<title>1.6 Normalizing Vectors</title>
<simpara>Calculating the magnitude of a vector is only the beginning.  The magnitude function opens the door to many possibilities, the first of which is <emphasis role="strong"><emphasis>normalization</emphasis></emphasis>.  Normalizing refers to the process of making something “standard” or, well, “normal.”  In the case of vectors, let’s assume for the moment that a standard vector has a length of one.  To normalize a vector, therefore, is to take a vector of any length and, keeping it pointing in the same direction, change its length to one, turning it into what is called a <emphasis role="strong"><emphasis>unit vector</emphasis></emphasis>.</simpara>
<informalfigure id="chapter01_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_12.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The ability to quickly access the unit vector is useful since it describes a vector’s direction without regard to length, and we’ll see this come in handy once we start to work with forces in Chapter 2.</simpara>
<simpara>For any given vector &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;, its unit vector (written as û) is calculated as follows:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mfenced open="∥" close="∥"&gt;&lt;mrow&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; u &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>In other words, to normalize a vector, simply divide each component by its magnitude.  This is pretty intuitive.  Say a vector is of length 5.  Well, 5 divided by 5 is 1.  So looking at our right triangle, we then need to scale the hypotenuse down by dividing by 5.   In that process the sides shrink, divided by 5 as well.</simpara>
<informalfigure id="chapter01_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_13.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the PVector class, we therefore write our normalization function as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">void normalize() {
  float m = mag();
  div(m);
}</programlisting>
<simpara>Of course, there’s one small issue.  What if the magnitude of the vector is zero?  We can’t divide by zero!   Some quick error checking will fix that right up:</simpara>
<programlisting language="java" linenumbering="unnumbered">void normalize() {
 float m = mag();
 if (m != 0) {
   div(m);
 }
}</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex06.png" canvas="processingjs/chapter01/_1_6_vector_normalize/_1_6_vector_normalize.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example6"><emphasis role="strong"><phrase role="example">Example 1.6: Normalizing a vector</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // In this example, after the vector is normalized it is multiplied by 50 so that it is viewable onscreen. Note that no matter where the mouse is, the vector will have the same length (50) due to the normalization process.
  mouse.normalize();
  mouse.mult(50);
  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
</section>
<section id="chapter01_section7">
<title>1.7 Vector Motion: Velocity</title>
<simpara>Why should we care?  Yes, all this vector math stuff sounds like something we should know about, but why exactly?  How will it actually help us write code?   The truth of the matter is that we need to have some patience.  The awesomeness of using the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class will take some time to fully come to light.  This is actually quite common when first learning a new data structure.   For example, when you first learn about an array, it might seem like much more work to use an array than to just have several variables stand for multiple things.   But that plan quickly breaks down when you need a hundred, or a thousand, or ten thousand things.  The same can be true for <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>.  What might seem like more work now will pay off later, and pay off quite nicely.  And you don’t have to wait too long, as your reward will come in the next chapter.</simpara>
<simpara>For now, however, we want to focus on simplicity.  What does it mean to program motion using vectors?   We’ve seen the beginning of this in <link linkend="chapter01_example2">Example 1.2</link><literal>:</literal> the bouncing ball.   An object on screen has a location (where it is at any given moment) as well as a velocity (instructions for how it should move from one moment to the next).   Velocity is added to location:</simpara>
<programlisting language="java" linenumbering="unnumbered">location.add(velocity);</programlisting>
<simpara>And then we draw the object at that location:</simpara>
<programlisting language="java" linenumbering="unnumbered">ellipse(location.x,location.y,16,16);</programlisting>
<simpara>This is Motion 101.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Add velocity to location</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Draw object at location</emphasis></emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>In the bouncing ball example, all of this code happened in Processing’s main tab, within <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.   What we want to do now is move towards encapsulating all of the logic for motion inside of a <emphasis role="strong"><emphasis>class</emphasis></emphasis>. This way, we can create a foundation for programming moving objects in Processing.    In <link linkend="intro_section2">Introduction</link> Section  section I.2 of the introduction, “The Random Walker Class,” we briefly reviewed the basics of object-oriented-programming (“OOP”).   Beyond that short introduction, this book assumes experience with objects and classes in Processing.   If you need a refresher, I encourage you to check out the online OOP Processing tutorial: <ulink url="http://processing.org/learning/tutorials/objects/">Processing objects tutorial</ulink>.</simpara>
<simpara>In this case, we’re going to create a generic <emphasis>Mover</emphasis> class, a class to describe a thing moving around the screen.  And so we must consider the following two questions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>What data does a Mover have?</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>What functionality does a Mover have?</emphasis></emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>Our “Motion 101” algorithm tells us the answers to these questions.  A Mover object has two pieces of data: location and velocity, two PVector objects.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;</programlisting>
<simpara>Its functionality is just about as simple.  The Mover needs to move and it needs to be seen.  We’ll implement these as functions named <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis>.  <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is where we’ll put all of our motion logic code and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> is where we will draw the object.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {
    // The Mover moves.
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    // The Mover is displayed.
    ellipse(location.x,location.y,16,16);
  }

}</programlisting>
<simpara>We’ve forgotten one crucial item, however: the object’s <emphasis role="strong"><emphasis>constructor</emphasis></emphasis>.  The constructor is a special function inside of a class that creates the instance of the object itself. It is where you give instructions on how to set up the object.  It always has the same name as the class and is called by invoking the <emphasis role="strong"><emphasis>new</emphasis></emphasis> operator: <emphasis role="strong"><phrase role="function">Mover m = new Mover();</phrase></emphasis>.</simpara>
<simpara>In our case, let’s arbitrarily decide to initialize our mover object by giving it a random location and a random velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }</programlisting>
<simpara>If object-oriented programming is at all new to you, one aspect here may seem a bit confusing.  After all, we spent the beginning of this chapter discussing the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class.  The <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class is the template for making the object “location” and the object “velocity”.  So what are they doing inside of yet another object, the Mover object?   In fact, this is just about the most normal thing ever.  An object is simply something that holds data (and functionality).  That data can be numbers (integers, floats, etc.) or other objects!  We’ll see this over and over again in this book.   For example, in <link linkend="chapter04_section1">Chapter 4</link> we’ll write a class to describe a system of particles.  That “ParticleSystem” object will have as its data a list of Particle objects. . .and each Particle object will have as its data several PVector objects!</simpara>
<simpara>Let’s finish off the Mover class by incorporating a function to determine what the object should do when it reaches the edge of the window.  For now let’s do something simple, and just have it wrap around the edges.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void checkEdges() {

    // When it reaches one edge, set location to the other.
    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }

  }</programlisting>
<simpara>Now that the Mover class is finished, we can look at what we need to do in our main program.  We first declare a Mover object:</simpara>
<programlisting language="java" linenumbering="unnumbered">Mover mover;</programlisting>
<simpara>Then initialize the mover in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">mover = new Mover();</programlisting>
<simpara>and call the appropriate functions in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">mover.update();
mover.checkEdges();
mover.display();</programlisting>
<simpara>Here is the entire example for reference:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex07.png" canvas="processingjs/chapter01/_1_7_motion101/_1_7_motion101.pde processingjs/chapter01/_1_7_motion101/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex07.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example7"><emphasis role="strong"><phrase role="example">Example 1.7: Motion 101 (velocity)</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// Declare Mover object.
Mover mover;

void setup() {
  size(200,200);
  smooth();
  // Create Mover object.
  mover = new Mover();
}

void draw() {
  background(255);

  //[full] Call functions on Mover object.
  mover.update();
  mover.checkEdges();
  mover.display();
  //[end]
}

class Mover {

  //[full] Our object has two PVectors: location and velocity.
  PVector location;
  PVector velocity;
  //[end]

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }

  void update() {
    // Motion 101: Location changes by velocity.
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {
    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}</programlisting>
</section>
<section id="chapter01_section8">
<title>1.8 Vector Motion: Acceleration</title>
<simpara>OK. At this point, we should feel comfortable with two things: (1) what a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> is and (2) how we use <emphasis role="strong"><phrase role="klass">PVectors</phrase></emphasis> inside of an object to keep track of its location and movement.  This is an excellent first step and deserves a mild round of applause.   Before standing ovations and screaming fans, however, we need to make one more, somewhat larger, step forward.   After all, watching the Motion 101 example is fairly boring—the circle never speeds up, never slows down, and never turns.  For more interesting motion, for motion that appears in the real world around us, we need to add one more <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> to our class—<emphasis role="strong"><phrase role="var">acceleration</phrase></emphasis>.</simpara>
<simpara>The strict definition of acceleration we’re using here is: the rate of <emphasis>change of velocity</emphasis>.  Let’s think about that definition for a moment.  Is this a new concept?  Not really.  Velocity is defined as <emphasis>the rate of change of location</emphasis>.  In essence, we are developing a “trickle down” effect.  Acceleration affects velocity, which in turn affects location (for some brief foreshadowing, this point will become even more crucial in the next chapter when we see how forces affect acceleration, which affects velocity, which affects location.)  In code, this reads:</simpara>
<programlisting language="java" linenumbering="unnumbered">velocity.add(acceleration);
location.add(velocity);</programlisting>
<simpara>As an exercise, from this point forward, let’s make a rule for ourselves.  Let’s write every example in the rest of this book without ever touching the value of velocity and location (except to initialize them).  In other words, our goal now for programming motion is as follows—come up with an algorithm for how we calculate acceleration and let the trickle-down effect work its magic.   (In truth, you’ll find reasons to break this rule, but it’s important to illustrate the principles behind our motion algorithm.)  And so we need to come up with some ways to calculate acceleration:</simpara>
<section id="_acceleration_algorithms">
<title>Acceleration Algorithms!</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>
A constant acceleration
</simpara>
</listitem>
<listitem>
<simpara>
A totally random acceleration
</simpara>
</listitem>
<listitem>
<simpara>
Acceleration towards the mouse
</simpara>
</listitem>
</orderedlist>
<simpara>Algorithm #1, a constant acceleration, is not particularly interesting, but it is the simplest and will help us begin incorporating acceleration into our code.   The first thing we need to do is add another <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> to the Mover class:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;
  // A new PVector for acceleration
  PVector acceleration;</programlisting>
<simpara>And incorporate acceleration into the <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> function:</simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {
    // Our motion algorithm is now two lines of code!
    velocity.add(acceleration);
    location.add(velocity);
  }</programlisting>
<simpara>We’re almost done.  The only missing piece is initialization in the constructor.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Mover() {</programlisting>
<simpara>Let’s start the mover object in the middle of the window. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">    location = new PVector(width/2,height/2);</programlisting>
<simpara>with an initial velocity of zero.</simpara>
<programlisting language="java" linenumbering="unnumbered">    velocity = new PVector(0,0);</programlisting>
<simpara>This means that when the sketch starts, the object is at rest.  We don’t have to worry about velocity anymore as we are controlling the object’s motion entirely with acceleration.  Speaking of which, according to Algorithm #1, our first sketch involves constant acceleration.  So let’s pick a value.</simpara>
<programlisting language="java" linenumbering="unnumbered">    acceleration = new PVector(-0.001,0.01);
  }</programlisting>
<simpara>Maybe you’re thinking, “Gosh, those values seem awfully small!”   That’s right, they are quite tiny.  It’s important to realize that our acceleration values (measured in pixels) accumulate over time in the velocity, about thirty times per second depending on our sketch’s frame rate.   And so to keep the magnitude of the velocity vector within a reasonable range, our acceleration values should remain quite small.   We can also help this cause by incorporating the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> function <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The limit() function constrains the magnitude of a vector.
velocity.limit(10);</programlisting>
<simpara>This translates to the following:</simpara>
<simpara><emphasis>What is the magnitude of velocity?  If it’s less than 10, no worries; just leave it as is.  If it’s more than 10, however, reduce it to 10!</emphasis></simpara>
<example id="chapter01_exercise4">
<title>Exercise 1.4</title>
<simpara>Write the <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis> function for the PVector class.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void limit(float max) {
    if (_______ &gt; _______) {
      _________();
      ____(max);
    }
  }</programlisting>
</example>
<simpara>Let’s take a look at the changes to the Mover class, complete with <emphasis role="strong"><phrase role="function">acceleration</phrase></emphasis> and <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex08.png" canvas="processingjs/chapter01/_1_8_motion101_acceleration/_1_8_motion101_acceleration.pde processingjs/chapter01/_1_8_motion101_acceleration/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex08.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example8"><emphasis role="strong"><phrase role="example">Example 1.8: Motion 101 (velocity and constant acceleration)</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;
  // Acceleration is the key!
  PVector acceleration;
  // The variable, topspeed, will limit the magnitude of velocity.
  float topspeed;

  Mover() {
    location = new PVector(width/2,height/2);
    velocity = new PVector(0,0);
    acceleration = new PVector(-0.001,0.01);
    topspeed = 10;
  }

  void update() {
    //[full] Velocity changes by acceleration and is limited by topspeed.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    //[end]
    location.add(velocity);
  }

  // display() is the same
  void display() {}
  // checkEdges() is the same
  void checkEdges() {}
}</programlisting>
<example id="chapter01_exercise5">
<title>Exercise 1.5</title>
<simpara>Create a simulation of a car (or runner) that accelerates when you press the up key and brakes when you press the down key.</simpara>
</example>
<simpara>Now to Algorithm #2,“a totally random acceleration.”  In this case, instead of initializing acceleration in the object’s constructor, we want to pick a new acceleration each cycle, i.e. each time <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is called.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex09.png" canvas="processingjs/chapter01/_1_9_motion101_acceleration/_1_9_motion101_acceleration.pde processingjs/chapter01/_1_9_motion101_acceleration/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex09.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example9"><emphasis role="strong"><phrase role="example">Example 1.9: Motion 101 (velocity and random acceleration)</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {

    acceleration = new PVector(random(-1,1),random(-1,1));
    acceleration.normalize();

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
  }</programlisting>
<simpara>While normalizing acceleration is not entirely necessary, it does prove useful, as it standardizes the magnitude of the vector, allowing us to try different things. Such as:</simpara>
<simpara>(a) scaling the acceleration to a constant value</simpara>
<programlisting language="java" linenumbering="unnumbered">acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();
// Constant
acceleration.mult(0.5); // [bold]</programlisting>
<simpara>(b) scaling the acceleration to a random value</simpara>
<programlisting language="java" linenumbering="unnumbered">acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();
// Random
acceleration.mult(random(2)); // [bold]</programlisting>
<simpara>While this may seem like an obvious point, it’s crucial to understand that acceleration does not merely refer to the <emphasis>speeding up</emphasis> or <emphasis>slowing down</emphasis> of a moving object, but rather <emphasis>any change</emphasis> in velocity in either magnitude or direction.   Acceleration is used to steer an object, and we’ll see this again and again in future chapters as we begin to program objects that make decisions about how to move about the screen.</simpara>
<example id="chapter01_exercise6">
<title>Exercise 1.6</title>
<simpara>Referring back to <link linkend="intro_section6">Introduction</link>, implement acceleration according to Perlin noise.</simpara>
</example>
</section>
</section>
<section id="chapter01_section9">
<title>1.9 Static vs. Non-Static Functions</title>
<simpara>Before we get to acceleration Algorithm #3 (accelerate towards the mouse), we need to cover one more rather important aspect of working with vectors and the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class: the difference between using <emphasis role="strong">static</emphasis> methods and <emphasis role="strong">non-static</emphasis> methods.</simpara>
<simpara>Forgetting about vectors for a moment, take a look at the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = 0;
float y = 5;

x = x + y;</programlisting>
<simpara>Pretty simple, right?  <emphasis role="strong"><phrase role="var">x</phrase></emphasis> has the value of 0, we add <emphasis role="strong"><phrase role="var">y</phrase></emphasis> to it, and now <emphasis role="strong"><phrase role="var">x</phrase></emphasis> is equal to 5.  We could write the corresponding code pretty easily based on what we’ve learned about <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
v.add(u);</programlisting>
<simpara>The vector <emphasis role="strong"><phrase role="var">v</phrase></emphasis> has the value of (0,0), we add <emphasis role="strong"><phrase role="var">u</phrase></emphasis> to it, and now <emphasis role="strong"><phrase role="var">v</phrase></emphasis> is equal to (4,5).  Easy, right?</simpara>
<simpara>OK, let’s take a look at another example of some simple floating point math:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = 0;
float y = 5;

float z = x + y;</programlisting>
<simpara><emphasis role="strong"><phrase role="var">x</phrase></emphasis> has the value of 0, we add <emphasis role="strong"><phrase role="var">y</phrase></emphasis> to it, and store the result in a new variable <emphasis role="strong"><phrase role="var">z</phrase></emphasis>.   The value of <emphasis role="strong"><phrase role="var">x</phrase></emphasis> does not change in this example (neither does <emphasis role="strong"><phrase role="var">y</phrase></emphasis>)!  This may seem like a trivial point, and one that is quite intuitive when it comes to mathematical operations with floats.   However, it’s not so obvious with mathematical operations in <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>).  Let’s try to write the code based on what we know so far.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
// Don’t be fooled; this is incorrect!!!
PVector w = v.add(u); // [line-through]</programlisting>
<simpara>The above might seem like a good guess, but it’s just not the way the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class works.   If we look at the definition of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> . . .</simpara>
<programlisting language="java" linenumbering="unnumbered">void add(PVector v) {
    x = x + v.x;
    y = y + v.y;
 }</programlisting>
<simpara>we see that this code does not accomplish our goal.  First, it does not return a new <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> (the return type is “void”) and second, it changes the value of the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> upon which it is called.  In order to add two PVector objects together and return the result as a new PVector, we must use the <emphasis role="strong">static</emphasis> <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> function.</simpara>
<simpara>Functions that we call from the class name itself (rather than from a speciﬁc object instance) are known as <emphasis role="strong">static</emphasis> functions.   Here are two examples of function calls that assume two PVector objects, <emphasis role="strong"><phrase role="var">v</phrase></emphasis> and <emphasis role="strong"><phrase role="var">u</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Static: called from the class name.
PVector.add(v,u);
// Not static: called from an object instance.
v.add(u);</programlisting>
<simpara>Since you can’t write static functions yourself in Processing, you might not have encountered them before.  <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> 's static functions allow us to perform generic mathematical operations on <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> objects without having to adjust the value of one of the input <emphasis role="strong"><phrase role="klass">PVectors</phrase></emphasis>.  Let’s look at how we might write the static version of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">  //[offset-up] The static version of add allows us to add two PVectors together and assign the result to a new PVector while leaving the original PVectors (v and u) intact.
  static PVector add(PVector v1, PVector v2) {
    PVector v3 = new PVector(v1.x + v2.x, v1.y + v2.y);
    return v3;
  }</programlisting>
<simpara>There are several differences here:</simpara>
<itemizedlist>
<listitem>
<simpara>
The function is labeled as <emphasis role="strong"><emphasis>static</emphasis></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
The function does not have a <emphasis role="strong"><emphasis>void</emphasis></emphasis> return type, but rather returns a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
The function creates a new <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> (v3) and returns the sum of the components of <emphasis role="strong"><phrase role="var">v1</phrase></emphasis> and <emphasis role="strong"><phrase role="var">v2</phrase></emphasis> in that new <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>.
</simpara>
</listitem>
</itemizedlist>
<simpara>When you call a static function, instead of referencing an actual object instance, you simply reference the name of the class itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
PVector w = v.add(u); // [line-through]
PVector w = PVector.add(v,u); // [bold]</programlisting>
<simpara>The PVector class has static versions of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">sub()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">mult()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">div()</phrase></emphasis>.</simpara>
<example id="chapter01_exercise7">
<title>Exercise 1.7</title>
<simpara>Translate the following pseudocode to code using static or non-static functions where appropriate.</simpara>
<itemizedlist>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">v</phrase></emphasis> equals (1,5)
</simpara>
</listitem>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">u</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">v</phrase></emphasis> multiplied by 2.
</simpara>
</listitem>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">w</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">v</phrase></emphasis> minus <emphasis role="strong"><phrase role="var">u</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
Divide the PVector w by 3.
</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(1,5);
PVector u = ________._____(__,__);
PVector w = ________._____(__,__);
___________;</programlisting>
</example>
</section>
<section id="chapter01_section10">
<title>1.10 Interactivity with acceleration</title>
<informalfigure id="chapter01_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_14.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.14</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To finish out this chapter, let’s try something a bit more complex and a great deal more useful.  We’ll dynamically calculate an object’s acceleration according to a rule, acceleration Algorithm #3 —“the object accelerates towards the mouse.”</simpara>
<simpara>Anytime we want to calculate a vector based on a rule or a formula, we need to compute two things: <emphasis role="strong"><emphasis>magnitude</emphasis></emphasis> and <emphasis role="strong"><emphasis>direction</emphasis></emphasis>.  Let’s start with direction.  We know the acceleration vector should point from the object’s location towards the mouse location.  Let’s say the object is located at the point (<emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y</phrase></emphasis>) and the mouse at (<emphasis role="strong"><phrase role="var">mouseX</phrase></emphasis>,<emphasis role="strong"><phrase role="var">mouseY</phrase></emphasis>).</simpara>
<informalfigure id="chapter01_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_15.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 1.15</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>As illustrated in Figure 1.15, we see that we can get a vector (<emphasis role="strong"><phrase role="var">dx</phrase></emphasis>,<emphasis role="strong"><phrase role="var">dy</phrase></emphasis>) by subtracting the object’s location from the mouse’s location.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="formula">dx = mouseX - x</phrase></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="formula">dy = mouseY - y</phrase></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>Let’s rewrite the above using <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> syntax.   Assuming we are in the Mover class and thus have access to the object’s location <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>, we then have:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector mouse = new PVector(mouseX,mouseY);
// Look! We’re using the static reference to sub() because we want a new PVector pointing from one point to another.
PVector dir = PVector.sub(mouse,location);</programlisting>
<simpara>We now have a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> that points from the mover’s location all the way to the mouse.  If the object were to actually accelerate using that vector, it would appear instantaneously at the mouse location.  This does not make for good animation, of course, and what we want to do now is decide how quickly that object should accelerate toward the mouse.</simpara>
<simpara>In order to set the magnitude (whatever it may be) of our acceleration PVector, we must first <emphasis><emphasis></emphasis></emphasis><emphasis><emphasis></emphasis></emphasis><emphasis><emphasis></emphasis></emphasis><emphasis><emphasis></emphasis></emphasis><emphasis><emphasis></emphasis>___</emphasis> that direction vector.  That’s right, you said it.  <emphasis role="strong"><emphasis>Normalize</emphasis></emphasis>.   If we can shrink the vector down to its unit vector (of length one) then we have a vector that tells us the direction and can easily be scaled to any value.   One multiplied by anything equals anything.</simpara>
<programlisting language="java" linenumbering="unnumbered">float anything = ?????
dir.normalize();
dir.mult(anything);</programlisting>
<simpara>To summarize, we take the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Calculate a vector that points from the object to the target location (mouse).
</simpara>
</listitem>
<listitem>
<simpara>
Normalize that vector (reducing its length to 1)
</simpara>
</listitem>
<listitem>
<simpara>
Scale that vector to an appropriate value (by multiplying it by some value)
</simpara>
</listitem>
<listitem>
<simpara>
Assign that vector to acceleration
</simpara>
</listitem>
</orderedlist>
<simpara>And here are those steps in the <emphasis role="strong"><emphasis>update()</emphasis></emphasis> function itself:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex10.png" canvas="processingjs/chapter01/_1_10_motion101_acceleration/_1_10_motion101_acceleration.pde processingjs/chapter01/_1_10_motion101_acceleration/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex10.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example10"><emphasis role="strong"><phrase role="example">Example 1.10: Accelerating towards mouse</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {

    PVector mouse = new PVector(mouseX,mouseY);
    // Step 1: Direction
    PVector dir = PVector.sub(mouse,location);

    // Step 2: Normalize
    dir.normalize();

    // Step 3: Scale
    dir.mult(0.5);

    // Step 4: Accelerate
    acceleration = dir;

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);

  }</programlisting>
<simpara>You may be wondering why the circle doesn’t stop when it reaches the target.  It’s important to note that the object moving has no knowledge about trying to stop at a destination; it only knows where the destination is and tries to go there as quickly as possible. Going as quickly as possible means it will inevitably overshoot the location and have to turn around, again going as quickly as possible towards the destination, overshooting it again, and so on, and so forth.   Stay tuned; in later chapters we’ll learn how to program an object to “arrive” at a location (slow down on approach).</simpara>
<example id="chapter01_exercise8">
<title>Exercise 1.8</title>
<simpara>This example is remarkably close to the concept of gravitational attraction (in which the object is attracted to the mouse location).  Gravitational attraction will be covered in more detail in the next chapter. However, one thing missing here is that the strength of gravity (magnitude of acceleration) is inversely proportional to distance.  This means that the closer the object is to the mouse, the faster it accelerates.   Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.</simpara>
</example>
<simpara>Let’s see what this example would look like with an array of Mover objects (rather than just one).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_ex11.png" canvas="processingjs/chapter01/_1_11_motion101_acceleration_array/_1_11_motion101_acceleration_array.pde processingjs/chapter01/_1_11_motion101_acceleration_array/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch01_ex11.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter01_example11"><emphasis role="strong"><phrase role="example">Example 1.11: Array of Movers accelerating towards mouse</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// An array of objects
Mover[] movers = new Mover[20];

void setup() {
  size(200,200);
  smooth();
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    // Initialize each object in the array.
    movers[i] = new Mover();
  }
}

void draw() {
  background(255);

  for (int i = 0; i &lt; movers.length; i++) {
    //[full] Calling functions on all the objects in the array.
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
    //[end]
  }
}

class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float topspeed;

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    topspeed = 4;
  }

  void update() {

    // &lt;b&gt;&lt;u&gt;Our algorithm for calculating acceleration&lt;/b&gt;&lt;/u&gt;:

    //[full] Find vector pointing towards mouse
    PVector mouse = new PVector(mouseX,mouseY);
    PVector dir = PVector.sub(mouse,location);
    //[end]
    // Normalize
    dir.normalize();
    // Scale
    dir.mult(0.5);
    // Set to acceleration
    acceleration = dir;

    //[full] Motion 101! Velocity changes by acceleration.  Location changes by velocity.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
    //[end]
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {

    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    }  else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}</programlisting>
<informalfigure id="chapter01_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch01_16.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 1.16: The Ecosystem Project</phrase></textobject>
</mediaobject>
</informalfigure>
<tip>
<title>Ecosystem Project:</title>
<simpara>As mentioned in the preface, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter one step at a time.  We’ll follow the development of an example project throughout this book—an “ecosystem” simulation.  Imagine a population of computational creatures swimming around a digital pond, interacting with each other according to various rules.</simpara>
<simpara>Step 1 Exercise:</simpara>
<simpara>Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc.  Can you control the object’s motion by only manipulating the acceleration?  Try to give the creature a personality through its behavior (rather than through its visual design.)</simpara>
</tip>
</section>
</chapter>
<chapter id="_chapter_2_forces">
<title>Chapter 2.  Forces</title>
<blockquote>
<attribution>
Darth Vader
</attribution>
<simpara>“Don&#8217;t underestimate the Force.”</simpara>
</blockquote>
<simpara>In the final example of Chapter 1, we saw how we could calculate a dynamic acceleration based on a vector pointing from a circle on the screen to the mouse location.   The resulting motion resembled a magnetic attraction between circle and mouse, as if some <emphasis>force</emphasis> were pulling the circle in towards the mouse.  In this chapter we will formalize our understanding of the concept of a <emphasis role="strong"><emphasis>force</emphasis></emphasis> and its relationship to <emphasis role="strong"><emphasis>acceleration</emphasis></emphasis>.    Our goal, by the end of this chapter, is to understand how to make multiple objects move around the screen and respond to a variety of environmental forces.</simpara>
<section id="chapter02_section1">
<title>2.1 Forces and Newton’s Laws of Motion</title>
<simpara>Before we begin examining the practical realities of simulating forces in code, let’s take a conceptual look at what it means to be a <emphasis role="strong"><emphasis>force</emphasis></emphasis> in the real world.   Just as with the word “vector”, “force” is often commonly used to mean a variety of things.  It can be used to indicate a powerful intensity, as in “She pushed the boulder with great force” or “He spoke forcefully.”   The definition of force that we care about is much more formal and comes from Isaac Newton’s laws of motion:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Force is a vector that causes an object with mass to accelerate.</phrase></emphasis></simpara>
<simpara>The good news here is that we recognize the first part of the definition—“a force is a vector.” Thank goodness we just spent a whole chapter learning what a vector is and how to program with PVectors!</simpara>
<simpara>Let’s look at Newton’s three laws in relation to the concept of a force.</simpara>
<section id="_newton_s_first_law">
<title>Newton’s First Law</title>
<simpara>Newton’s first law is commonly stated as:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">An object at rest stays at rest and an object in motion stays in motion.</phrase></emphasis></simpara>
<simpara>However, this is missing an important element related to forces and so we could expand it by stating:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">An object at rest stays at rest and an object in motion stays in motion at a constant speed and direction unless acted upon by an unbalanced force.</phrase></emphasis></simpara>
<simpara>By the time Newton came along, the prevailing theory of motion—formulated by Aristotle—was nearly two thousand years old. It stated that if an object is moving, some sort of “force” is required to keep it moving.   Unless that moving thing is being pushed or pulled, it will simply slow down or stop.  Right?</simpara>
<simpara>This, of course, is not true.   In the absence of any forces, no force is required to keep an object moving.  An object (such as a ball) tossed in the earth’s atmosphere slows down because of air resistance (a force).    An object’s velocity will only remain constant in the absence of any forces or if the forces that act on it <emphasis>cancel each other out</emphasis>, i.e. the net force adds up to zero.  This is often referred to as <emphasis role="strong"><emphasis>equilibrium</emphasis></emphasis>.  The falling ball will reach a terminal velocity (that stays constant) once the force of air resistance equals the force of gravity.</simpara>
<informalfigure id="chapter02_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_01.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 2.1: The pendulum doesn't move because all the forces cancel each other out (add up to a net force of zero.)</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In our Processing world, we could restate Newton’s first law as follows:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">An object’s PVector velocity will remain constant if it is in a state of equilibrium.</phrase></emphasis></simpara>
<simpara>Skipping Newton’s second law (arguably the most important law for our purposes) for a moment, let’s move on to the third law.</simpara>
</section>
<section id="_newton_s_third_law">
<title>Newton’s Third Law</title>
<simpara>This law is often stated as:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">For every action there is an equal and opposite reaction.</phrase></emphasis></simpara>
<simpara>This law frequently causes some confusion in the way that it is stated.   For one, it sounds like one force causes another.   Yes, if you push someone, that someone may <emphasis>actively</emphasis> decide to push you back.  But this is not the action and reaction we are talking about with Newton’s third law.</simpara>
<simpara>Let’s say you push against a wall.  The wall doesn’t actively decide to push back on you.   There is no “origin” force.   Your push simply includes both forces, referred to as an “action/reaction pair.”</simpara>
<simpara>A better way of stating the law might be:</simpara>
<simpara>[highlight]*Forces always occur in pairs.  The two forces are of equal strength, but in opposite directions.</simpara>
<simpara>Now, this still causes confusion because it sounds like these forces would always cancel each other out.   This is not the case.  Remember, the forces act on different objects.  And just because the two forces are equal, it doesn’t mean that the <emphasis>movements</emphasis> are equal (or that the objects will stop moving).</simpara>
<simpara>Try pushing on a stationary truck.  Although the truck is far more powerful than you, unlike a moving one, a stationary truck will never overpower you and send you flying backwards.  The force you exert on it is equal and opposite to the force exerted on your hand.   The <emphasis>outcome</emphasis> depends on a variety of other factors.  If the truck is a small truck on an icy downhill, you’ll probably be able to get it to move.  On the other hand, if it’s a very large truck on a dirt road and you push hard enough (maybe even take a running start) you could injure your hand.</simpara>
<simpara>And if you are wearing roller skates when you push on that truck?</simpara>
<informalfigure id="chapter02_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_02.png" classname="half-width" />
  </imageobject>
  <textobject><phrase>Figure 2.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">[REDO DIAGRAM AS TRUCK]</phrase></emphasis></simpara>
<simpara>You’ll accelerate away from the truck sliding along the road while the truck stays put.   Why do you slide but not the truck?  For one, the truck has a much larger mass (which we’ll get into with Newton’s second law) and there are other forces at work too, namely the friction of the truck’s tires and your roller skates against the road.</simpara>
</section>
<section id="_newton_s_third_law_as_seen_through_the_eyes_of_processing">
<title>Newton’s Third Law as seen through the eyes of Processing</title>
<simpara>If we calculate a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> <emphasis role="strong"><phrase role="var">f</phrase></emphasis> that is a force of object A on object B, we must also apply the force <emphasis role="strong"><phrase role="var">f</phrase></emphasis> (or <emphasis role="strong"><phrase role="function">PVector.mult(f,-1);</phrase></emphasis>) that B exerts on object A.</simpara>
<simpara>We’ll see that in the world of Processing programming we don’t always have to stay true to the above.  Sometimes, such as in the case of gravitational attraction between bodies (see <link linkend="chapter02_example6">Example 2.6</link>), we’ll want to model equal and opposite forces.  Other times, such as when we’re simply saying, “Hey, there’s some wind in the environment,” we’re not going to bother to model the force that a body exerts back on the air.  In fact, we’re not modeling the air at all!  Remember, we are simply taking inspiration from the physics of the natural world and not simulating everything with perfect precision.</simpara>
</section>
</section>
<section id="chapter02_section2">
<title>2.2 Forces and Processing—Newton’s Second Law as a Function</title>
<simpara>And here we are at the most important law for the Processing programmer.</simpara>
<section id="_newton_s_second_law">
<title>Newton’s Second Law</title>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mi&gt; M &lt;/mi&gt;&lt;mo&gt; &#x00D7; &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; A &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>Force equals mass times acceleration.</simpara>
<simpara>Why is this the most important law for us?  Well, let’s write this a different way.</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; A &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; / &lt;/mo&gt;&lt;mi&gt; M &lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>Acceleration is directly proportional to force and inversely proportional to mass.  This means that if you get pushed, the harder you are pushed, the faster you’ll move (accelerate).  The bigger you are, the slower you’ll move.</simpara>
<note>
<title>Weight vs. Mass</title>
<itemizedlist>
<listitem>
<simpara>
The <emphasis role="strong">mass</emphasis> of an object is a measure of the amount of matter in the object (measured in kilograms).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Weight</emphasis>, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, we can calculate it as mass times the acceleration of gravity (<emphasis role="strong"><phrase role="var">w</phrase></emphasis> = <emphasis role="strong"><phrase role="var">m</phrase></emphasis> * <emphasis role="strong"><phrase role="var">g</phrase></emphasis>). Weight is measured in newtons.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Density</emphasis> is is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).
</simpara>
</listitem>
</itemizedlist>
<simpara>Note that an object that has a mass of one kilogram on earth would have a mass of one kilogram on the moon. However, it would weigh only one-sixth as much.</simpara>
</note>
<simpara>Now, in the world of Processing, what is mass anyway?  Aren’t we dealing with pixels?  To start in a simpler place, let’s say that in our pretend pixel world, all of our objects have a mass equal to 1.  <emphasis role="strong"><phrase role="var">F</phrase></emphasis>/ 1 = <emphasis role="strong"><phrase role="var">F</phrase></emphasis>.  And so:</simpara>
<simpara>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; A &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mstyle&gt;&lt;/math&gt;</simpara>
<simpara>The acceleration of an object is equal to force.  This is great news.  After all, we saw in Chapter 1 that acceleration was the key to the controlling the movement of our objects on screen.  Location is adjusted by velocity, and velocity by acceleration.  Acceleration was where it all began.  Now we learn that <emphasis role="strong">force</emphasis> is truly where it all begins.</simpara>
<simpara>Let’s say we have a class called Mover, with location, velocity, and acceleration.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
}</programlisting>
<simpara>Now our goal is to be able to add forces to this object, perhaps saying:</simpara>
<programlisting language="java" linenumbering="unnumbered">mover.applyForce(wind);</programlisting>
<simpara>or:</simpara>
<programlisting language="java" linenumbering="unnumbered">mover.applyForce(gravity);</programlisting>
<simpara>where wind and gravity are PVectors.  According to Newton’s second law, we could implement this function as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void applyForce(PVector force) {
    // Newton’s second law at its simplest.
    acceleration = force;
  }</programlisting>
</section>
</section>
<section id="chapter02_section3">
<title>2.3 Force Accumulation</title>
<simpara>This looks pretty good.  After all, it’s a literal translation of Newton’s second law (without mass): <emphasis role="strong"><emphasis>Acceleration = Force</emphasis></emphasis>.   Nevertheless, there’s a pretty big problem here.  Let’s return to what we are trying to accomplish: creating a moving object on the screen that responds to wind and gravity.</simpara>
<programlisting language="java" linenumbering="unnumbered">mover.applyForce(wind);
mover.applyForce(gravity);
mover.update();
mover.display();</programlisting>
<simpara>Ok, let’s <emphasis>be</emphasis> the computer for a moment.  First, we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> with wind.  And so the Mover object’s acceleration is now set to the wind PVector.   Second, we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> with gravity.  And so the Mover object’s acceleration is now set to the gravity PVector.    Third, we call <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>.  What happens in update?  Acceleration is added to velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">velocity.add(acceleration);</programlisting>
<simpara>We’re not going to see any <emphasis>error</emphasis> in Processing, but zoinks!  We’ve got a major problem.  What is the value of acceleration when it is added to velocity?  It is equal to the gravity force.  Wind has been left out!  If we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> more than once, it overrides each previous call.   How are we going to handle more than one force?</simpara>
<simpara>The answer is through a process known as <emphasis role="strong"><emphasis>force accumulation</emphasis></emphasis>.  It’s actually very simple; all we need to do is add all of the forces together.  At any given moment, there might be one, two, six, twelve, or three hundred and three forces.  As long as our object knows how to accumulate them, it doesn’t matter how many forces act on it.</simpara>
<programlisting language="java" linenumbering="unnumbered"> void applyForce(PVector force) {
  // Newton’s second law but with force accumulation.
  // We now add each force to acceleration, one at a time.
    acceleration.add(force);
 }</programlisting>
<simpara>Now, we’re not finished just yet.  There is one more piece to force accumulation.  Since we’re adding all the forces together at any given moment, we have to make sure that we clear acceleration (i.e. set it to zero) before each time <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is called.   Let’s think about wind for a moment.   Sometimes the wind is very strong, sometimes it’s weak, and sometimes there’s no wind at all.   At any given moment, there might be a huge gust of wind, say, when the user holds down the mouse.</simpara>
<programlisting language="java" linenumbering="unnumbered">if (mousePressed) {
  PVector wind = new PVector(0.5,0);
  mover.applyForce(wind);
}</programlisting>
<simpara>When the user releases the mouse, the wind will stop and according to Newton’s first law, the object will continue to move at a constant velocity.   However, if we had forgotten to reset acceleration to zero, the gust of wind would still be in effect.  Even worse, it would add onto itself from the previous frame, since we are accumulating forces!    Acceleration, in our simulation, has no memory; it is simply calculated based on the environmental forces present at a moment in time.   This is different than, say, location, which must remember where the object was the previous frame in order to move properly to the next.</simpara>
<simpara>The easiest way to implement clearing the acceleration for each frame is to multiply the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> by zero at the end of <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {
    velocity.add(acceleration);
    location.add(velocity);
    acceleration.mult(0);
 }</programlisting>
<example id="chapter02_exercise1">
<title>Exercise 2.1</title>
<simpara>Using forces, simulate a helium-filled balloon floating upward (and bouncing off the top of a window).  Can you add a wind force which changes over time, perhaps according to Perlin noise?</simpara>
</example>
</section>
<section id="chapter02_section4">
<title>2.4 Dealing with Mass</title>
<simpara>OK. We’ve got one tiny little addition to make before we are done with integrating forces into our Mover class and are ready to look at examples.  After all, Newton’s second law is really &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mi&gt; M &lt;/mi&gt;&lt;mo&gt; &#x00D7; &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; A &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;, not &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; A &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mstyle&gt;&lt;/math&gt;.   Incorporating mass is as easy as adding an instance variable to our class, but we need to spend a little more time here because a slight complication will emerge.</simpara>
<simpara>First we just need to add mass.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Adding mass as a float.
  float mass;</programlisting>
<note>
<title>Units of Measurement</title>
<simpara>Now that we are introducing mass it’s important to make a quick note about units of measurement.  In the real world, things are measured with specific units.  We say that two objects are three meters apart, the baseball is moving at a rate of ninety miles per hour, or this bowling ball has a mass of six kilograms.   As we’ll see later in this book, sometimes we will want to take real-world units into consideration.  However, in this chapter, we’re going to ignore them for the most part.  Our units of measurement are in pixels (“these two circles are one hundred pixels apart”) and frames of animation (“this circle is moving at a rate of two pixels per frame.”)   In the case of mass, there isn’t any unit of measurement for us to use.  We’re just going to make something up.  In this example, we’re arbitrarily picking the number ten.   There is no unit of measurement (you might enjoy inventing a unit of your own, like “1 moog” or “1 yurkle.”)  It should also be noted that, for demonstration purposes, we’ll tie mass to pixels (drawing, say, a circle with a radius of ten).  This will allow us to visualize the mass of an object.   In the real world, however, size does not definitely indicate mass. A small metal ball could have a much higher mass than a large balloon due to its higher density.</simpara>
</note>
<simpara>Mass is a scalar (float), not a vector, as it’s just one number describing the amount of matter in an object.  We could be fancy about things and compute the area of a shape as its mass, but it’s simpler to begin by saying, “Hey, the mass of this object is&#8230;um, I dunno&#8230;how about 10?”</simpara>
<programlisting language="java" linenumbering="unnumbered"> Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
    mass = 10.0;
  }</programlisting>
<simpara>This isn’t so great since things only become interesting once we have objects with varying mass, but it’ll get us started.  Where does mass come in?  We use it while applying Newton’s second law to our object.</simpara>
<programlisting language="java" linenumbering="unnumbered"> void applyForce(PVector force) {
   //[full] Newton’s second law (with force accumulation and mass).
   force.div(mass);
   acceleration.add(force);
   //[end]
 }</programlisting>
<simpara>Yet again, even though our code looks quite reasonable, we have a fairly major problem here.  Consider the following scenario with two <emphasis>Mover</emphasis> objects, both being blown away by a wind force.</simpara>
<programlisting language="java" linenumbering="unnumbered">Mover m1 = new Mover();
Mover m2 = new Mover();

PVector wind = new PVector(1,0);

m1.applyForce(wind);
m2.applyForce(wind);</programlisting>
<simpara>Again, let’s <emphasis>be</emphasis> the computer.  Object <emphasis role="strong"><phrase role="var">m1</phrase></emphasis> receives the wind force—(1,0)—divides it by mass (10) and adds it to acceleration.</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><phrase role="var">m1</phrase></emphasis> equals wind force
</term>
<listitem>
<simpara>
(1,0)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Divided by mass of 10
</term>
<listitem>
<simpara>
(0.1,0)
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>OK, moving onto object <emphasis role="strong"><phrase role="var">m2</phrase></emphasis>.  It also receives the wind force—(1,0).  Wait.  Hold on a second.  What is the value of wind force?   Taking a closer look, the wind force is actually now—(0.1,0)!!   Do you remember this little tidbit about working with objects?  When you pass an object (in this case a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>) into a function, you are passing a reference to that object.  It’s not a copy!  So if a function makes a change to that object (which, in this case, it does by dividing by mass) then that object is permanently changed!  But we don’t want <emphasis role="strong"><phrase role="var">m2</phrase></emphasis> to receive a force divided by the mass of object <emphasis role="strong"><phrase role="var">m1</phrase></emphasis>. We want it to receive that force in its original state—(1,0).  And so we must protect ourselves and make a copy of the PVector f before dividing it by mass.    Fortunately, the <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> class has a convenient method for making a copy—<emphasis role="strong"><phrase role="function">get()</phrase></emphasis>.  <emphasis role="strong"><phrase role="function">get()</phrase></emphasis> returns a new <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> object with the same data.  And so we can revise <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">void applyForce(PVector force) {
  // Making a copy of the PVector before using it!
  PVector f = force.get();
  f.div(mass);
  acceleration.add(f);
}</programlisting>
<simpara>There’s another way we could write the above function, using the static method <emphasis role="strong"><phrase role="function">div()</phrase></emphasis>. For help with this exercise, review static methods in <link linkend="chapter01_section9">Chapter 1</link>.</simpara>
<example id="chapter02_exercise2">
<title>Exercise 2.2</title>
<simpara>Rewrite the applyForce method using the static method div() instead of get().</simpara>
<programlisting language="java" linenumbering="unnumbered">void applyForce(PVector force) {
  PVector f = _______.___(_____,____);
  acceleration.add(f);
}</programlisting>
</example>
</section>
<section id="chapter02_section5">
<title>2.5 Creating Forces</title>
<simpara>Let’s take a moment to remind ourselves where we are.  We know what a force is (a vector), and we know how to apply a force to an object (divide it by mass, add it to the object’s acceleration vector).   What are we missing?  Well, we have yet to figure out how we get a force in the first place.  Where do forces come from?</simpara>
<simpara>In this chapter, we’ll look at two methods for creating forces in our Processing world.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong">Make up a force!</emphasis>  After all, you are the programmer, the creator of your world. There’s no reason why you can’t just make up a force and apply it.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Model a force!</emphasis>  Yes, forces exist in the real world.  And physics textbooks often contain formulas for these forces.  We can take these formulas, translate them into source code, and model real-world forces in Processing.
</simpara>
</listitem>
</orderedlist>
<simpara>The easiest way to make up a force is just to just pick a number.  Let’s start with the idea of simulating wind.  How about a wind force that points to the right and is fairly weak?  Assuming a Mover object “m”, our code would look like:</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector wind = new PVector(0.01,0);
  m.applyForce(wind);</programlisting>
<simpara>The result isn’t terribly interesting, but it is a good place to start.  We create a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> object, initialize it, and pass it into an object (which in turn will apply it to its own acceleration).
￼
If we wanted to have two forces, perhaps wind and gravity (a bit stronger, pointing down), we might say:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex01.png" canvas="processingjs/chapter02/_2_1_forces/_2_1_forces.pde processingjs/chapter02/_2_1_forces/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example1"><emphasis role="strong"><phrase role="example">Example 2.1</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector wind = new PVector(0.01,0);
  PVector gravity = new PVector(0,0.1);
  m.applyForce(wind);
  m.applyForce(gravity);</programlisting>
<simpara>Now we have two forces, pointing in different directions with different magnitudes, both applied to object “<emphasis role="strong"><phrase role="var">m</phrase></emphasis>.”  We’re beginning to get somewhere.  We’ve now built a world for our objects in Processing, an environment to which they can actually respond.</simpara>
<simpara>Let’s look at how we could make this example a bit more exciting with many objects of varying mass.   To do this, we’ll need to do a quick review of object-oriented programming.  Again, we’re not covering all the basics of programming here (for that you can check out any of the intro Processing books listed in the introduction).  However, since the idea of creating a world filled with objects is pretty fundamental to all the examples in this book, it’s worth taking a moment to walk through the steps of going from one object to many.</simpara>
<simpara>This is where we are with the Mover class as a whole.  Notice how it is identical to the Mover class created in Chapter 1, with two additions—<emphasis role="strong"><phrase role="var">mass</phrase></emphasis> and a new <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  // The object now has mass!
  float mass;

  Mover() {
    // And for now, we’ll just set the mass equal to 1 for simplicity.
    mass = 1;
    location = new PVector(30,30);
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }

  // Newton’s second law.
  void applyForce(PVector force) {
    //[full] Receive a force, divide by mass, and add to acceleration.
    PVector f = PVector.div(force,mass);
    acceleration.add(f);
    //[end]
  }

  void update() {
    //[full] Motion 101 from Chapter 1
    velocity.add(acceleration);
    location.add(velocity);
    //[end]
    // Now add clearing the acceleration each time!
    acceleration.mult(0);
  }

  void display() {
    stroke(0);
    fill(175);
    // Let’s scale the size of the object according to its mass.
    ellipse(location.x,location.y,mass*16,mass*16);
  }

  // Somewhat arbitrarily, we are deciding that an object bounces when it hits the edges of a window.
  void checkEdges() {
    if (location.x &gt; width) {
      location.x = width;
      velocity.x *= -1;
    } else if (location.x &lt; 0) {
      velocity.x *= -1;
      location.x = 0;
    }

    if (location.y &gt; height) {
      // Even though we said we shouldn't touch location and velocity directly, there are some exceptions to this
      // For example we are doing so as a quick and easy way to reverse the direction of our object when it reaches the edge
      velocity.y *= -1;
      location.y = height;
    }
  }
}</programlisting>
<simpara>Now that our class is set, we can choose to create, say, one hundred <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> objects with an array.</simpara>
<programlisting language="java" linenumbering="unnumbered">Mover[] movers = new Mover[100];</programlisting>
<simpara>And then we can initialize all of those Mover objects in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> with a loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover();
  }
}</programlisting>
<simpara>But now we have a small issue.  If we refer back to the <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> object’s constructor&#8230;</simpara>
<programlisting language="java" linenumbering="unnumbered">  Mover() {
    //[full] Every object has a mass of 1 and a location of (30,30)
    mass = 1;
    location = new PVector(30,30);
    //[end]
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }</programlisting>
<simpara>&#8230;we discover that every Mover object is made exactly the same way.  What we want are Mover objects of varying mass that start at varying locations.  Here is where we need to increase the sophistication of our constructor by adding arguments.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Mover(float m, float x , float y) {
    //[full] Now setting these variables with arguments
    mass = m;
    location = new PVector(x,y);
    //[end]
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }</programlisting>
<simpara>Notice how the mass and location are no longer set to hardcoded numbers, but rather initialized via arguments passed through the constructor.   This means we can create a variety of Mover objects: big ones, small ones, ones that start on the left side of the screen, ones that start on the right, etc.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A big Mover on the left side of the window
Mover m1 = new Mover(10,0,height/2);
// A small Mover on the right side of the window
Mover m1 = new Mover(0.1,width,height/2);</programlisting>
<simpara>With an array, however, we want to initialize all of the objects with a loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  for (int i = 0; i &lt; movers.length; i++) {
    // Initializing many “Mover” objects all with random mass (and all starting at 0,0).
    movers[i] = new Mover(random(0.1,5),0,0);
  }
}</programlisting>
<simpara>For each “Mover” created, the mass is set to a random value between 0.1 and 5, the starting x-location is set to 0, and the starting y-location is set to 0.  Certainly, there are all sorts of ways we might choose to initialize the objects; this is just a demonstration of one possibility.</simpara>
<simpara>Once the array of objects is declared, created, and initialized, the rest of the code is simple.  We run through every object, hand them each the forces in the environment, and enjoy the show.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex02.png" canvas="processingjs/chapter02/_2_2_forces_many/_2_2_forces_many.pde processingjs/chapter02/_2_2_forces_many/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example2"><emphasis role="strong"><phrase role="example">Example 2.2</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);

  PVector wind = new PVector(0.01,0);
  // Make up two forces.
  PVector gravity = new PVector(0,0.1);

  //[full] Loop through all objects and apply both forces to each object.
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);
  //[end]
    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}</programlisting>
<simpara>Note how in the above image, the smaller circles reach the right of the window faster than the larger ones.  This is because of our formula: <emphasis role="strong"><emphasis>acceleration = force divided by mass</emphasis></emphasis>.   The larger the mass, the smaller the acceleration.</simpara>
<example id="chapter02_exercise3">
<title>Exercise 2.3</title>
<simpara>Create an example where instead of objects bouncing off the edge of the wall, an invisible force pushes back on the objects to keep them in the window.  Can you weight the force according to how far the object is from an edge—i.e., the closer it is, the stronger the force?</simpara>
</example>
</section>
<section id="chapter02_section6">
<title>2.6 Gravity on Earth and Modeling a Force</title>
<simpara>You may have noticed something woefully inaccurate about this last example.  The smaller the circle, the faster it falls.   There is a logic to this; after all, we just stated (according to Newton’s second law) that the smaller the mass, the higher the acceleration.  But this is not what happens in the real world.  If you were to climb to the top of the Leaning Tower of Pisa and drop two balls of different masses, which one will hit the ground first?  According to legend, Galileo performed this exact test in 1589, discovering that they fell with the same acceleration, hitting the ground at the same exact time.  Why is this?   As we will see later in this chapter, the force of gravity is calculated relative to an object’s mass.  The bigger the object, the stronger the force.  So if the force is scaled according to mass, it is cancelled out when acceleration is divided by mass.   We can implement this in our sketch rather easily, by multiplying our “made up” gravity force by mass.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex03.png" canvas="processingjs/chapter02/_2_3_forces_many_realgravity/_2_3_forces_many_realgravity.pde processingjs/chapter02/_2_3_forces_many_realgravity/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example3"><emphasis role="strong"><phrase role="example">Example 2.3</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = 0; i &lt; movers.length; i++) {

    PVector wind = new PVector(0.001,0);
    float m = movers[i].mass;
    // Scaling gravity by mass to be more accurate
    PVector gravity = new PVector(0,0.1*m);
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }</programlisting>
<simpara>While the object’s now fall at the same rate, because the strength of the wind force is independent of mass, the smaller objects still accelerate to the right more quickly.</simpara>
<simpara>Making up forces will actually get us quite far.  The world of Processing is a pretend world of pixels and you are its master.  So whatever you deem appropriate to be a force, well by golly, that’s the force it should be.  Nevertheless, there may come a time where you find yourself wondering: “But how does it really all work?”</simpara>
<simpara>Open up any high school physics textbook and you will find some diagrams and formulas describing many different forces—gravity, electromagnetism, friction, tension, elasticity, and more.  In this chapter we’re going to look at two forces—friction and gravity.  The point we’re making here is not that friction and gravity are fundamental forces that you always need to have in your Processing sketches.  Rather, we want to evaluate these two forces as case studies for the following process:</simpara>
<itemizedlist>
<listitem>
<simpara>
Understanding the concept behind a force
</simpara>
</listitem>
<listitem>
<simpara>
Deconstructing the force’s formula into two parts:
</simpara>
<itemizedlist>
<listitem>
<simpara>
How do we compute the force’s direction?
</simpara>
</listitem>
<listitem>
<simpara>
How do we compute the force’s magnitude?
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Translating that formula into Processing code that calculates a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> to be sent through our Mover’s <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.
</simpara>
</listitem>
</itemizedlist>
<simpara>If we can follow the above steps with two forces, then hopefully if you ever find yourself Googling “atomic nuclei weak nuclear force” at 3 a.m., you will have the skills to take what you find and adapt it for Processing.</simpara>
<note>
<title>Dealing with formulae</title>
<simpara>Ok, in a moment we’re going to write out the formula for friction.  This isn’t the first time we’ve seen a formula is this book; we just finished up our discussion of Newton’s second law, F =MA (or force = mass * acceleration).    We didn’t spend a lot of time worrying about this formula, because it’s a nice and simple one.  Nevertheless, it’s a scary world out there.  Just take a look at the equation for a “normal” distribution which we covered (without looking at the formula) in the <link linkend="intro_section4">Introduction</link>.</simpara>
<simpara>&lt;div style="font-size: 2.0em;"&gt;&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mi&gt; f &lt;/mi&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;mo&gt; ; &lt;/mo&gt;&lt;mi&gt; &#x00B5; &lt;/mi&gt;&lt;mo&gt; , &lt;/mo&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mi&gt; &#x03C3; &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt; 1 &lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; &#x03C3; &lt;/mi&gt;&lt;msqrt&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;mi&gt; &#x03C0; &lt;/mi&gt;&lt;/msqrt&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mi&gt; e &lt;/mi&gt;&lt;msup&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mfenced&gt;&lt;mrow&gt;&lt;mi&gt; x &lt;/mi&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mi&gt; &#x00B5; &lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mi&gt; &#x03C3; &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/msup&gt;&lt;/mstyle&gt;&lt;/math&gt;&lt;/div&gt;</simpara>
<simpara>What we’re seeing here is that formulas like to use a lot of symbols (quite often letters from the Greek alphabet).   Let’s take a look at the formula for friction, which we’re about to cover.</simpara>
<simpara>&lt;div style="font-size: 2.0em;"&gt;&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;mi&gt; r &lt;/mi&gt;&lt;mi&gt; i &lt;/mi&gt;&lt;mi&gt; c &lt;/mi&gt;&lt;mi&gt; t &lt;/mi&gt;&lt;mi&gt; i &lt;/mi&gt;&lt;mi&gt; o &lt;/mi&gt;&lt;mi&gt; n &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2192; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mi&gt; &#x00B5; &lt;/mi&gt;&lt;mi&gt; N &lt;/mi&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;&lt;/div&gt;</simpara>
<simpara>If it’s been a while since you’ve looked at a formula from a math or physics textbook, there are three key points that are important to cover before we move on.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Evaluate the right side, assign to the left side.</emphasis></emphasis>  This is just like in code!  What we’re doing here is evaluating the right side of the equation and assigning it to the left.  In the case above, we want to calculate the force of friction—the left side tells us what we want to calculate and the right side tells us how to do it.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Are we talking about a vector or a scalar?</emphasis></emphasis>  It’s important for us to realize that in some cases, we’ll be looking at a vector; in others, a scalar.   For example, in this case the force of friction is a vector.  It has a magnitude and direction.  We can see that by the arrow above the word “friction.”  The right side of the equation also has a vector, as indicated by the symbol &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;, which is this case stands for the velocity unit vector.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>When symbols are placed next too each other, we mean for them to be multiplied.</emphasis></emphasis>  The formula above actually has four elements:  -1, -μ, N, and &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;.  We want to multiply them together and read the formula as:
</simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section id="chapter02_section7">
<title>2.7 Friction</title>
<simpara>Let’s begin with friction and follow our steps:</simpara>
<section id="_what_is_friction">
<title>What is friction?</title>
<simpara>Friction is a “dissipative” force.  A dissipative force is one in which the total energy of a system decreases when an object is in motion.   Let’s say you are driving a car. When you press your foot down on the brake pedal, the car’s brakes use friction to slow down the motion of the tires.  Kinetic energy (motion) is converted into thermal energy (heat).   Whenever two surfaces come into contact, they experience friction.   A complete model of friction would include separate cases for static friction (a body at rest against a surface) and kinetic friction (a body in motion against a surface), but for our purposes, we are going to only look at the kinetic case.</simpara>
</section>
<section id="_what_is_the_formula_for_friction">
<title>What is the formula for friction?</title>
<informalfigure id="chapter02_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_03.png" />
  </imageobject>
  <textobject><phrase>Figure 2.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>It’s now up to us to separate this formula into two components that determine the direction of friction as well as the magnitude.  Based on the diagram above, we can see that <emphasis>friction points in the opposite direction of velocity.</emphasis>   In fact, that’s the part of the formula that says -1 * &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt; or negative one times the velocity unit vector.  In Processing, this would mean taking the velocity vector, normalizing it, and multiplying by -1.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector friction = velocity.get();
friction.normalize();
// Let’s figure out the direction of the friction force
// (a unit vector in the opposite direction of velocity).
friction.mult(-1);</programlisting>
<simpara>Notice two additional steps here.  First, it’s important to make a copy of the velocity vector first as we don’t want to reverse the object’s direction by accident.  Second, we normalize the vector.  This is because the magnitude of friction is not associated with how fast it is moving, and we want to start with a friction vector of magnitude 1 so that it can easily be scaled.</simpara>
<simpara>According to the formula, the magnitude is <emphasis role="strong"><phrase role="var">μ</phrase></emphasis> * <emphasis role="strong"><phrase role="var">N</phrase></emphasis>.   <emphasis role="strong"><phrase role="var">μ</phrase></emphasis> is the Greek letter Mu (pronounced “mew”), which is used here to describe the “coefficient of friction.”   The coefficient of friction establishes the strength of a friction force for a particular surface.  The higher it is, the stronger the friction; the lower, the weaker.   A block of ice, for example, will have a much lower coefficient of friction than, say, sandpaper.   Since we’re in a pretend Processing world, we can arbitrarily set the coefficient based on how much friction we want to simulate.</simpara>
<programlisting language="java" linenumbering="unnumbered">float c = 0.01;</programlisting>
<simpara>Now for the second part: <emphasis role="strong"><phrase role="var">N</phrase></emphasis>.  <emphasis role="strong"><phrase role="var">N</phrase></emphasis> refers to the “normal” force, the force perpendicular to the object’s motion along a surface.  Think of a vehicle driving along a road.   The vehicle pushes down against the road with gravity, and Newton’s third law tells us that the road in turn pushes back against the vehicle.  That’s the normal force.  The greater the gravitational force, the greater the normal force.   As we’ll see in the next section, gravity is associated with mass and so a lightweight sports car would experience less friction than a massive tractor trailer truck.   With the diagram above, however, where the object is moving along a surface at an angle, computing the normal force is a bit more complicated because it doesn’t point in the same direction as gravity.  We’ll need to know something about angles and trigonometry.</simpara>
<simpara>All of these specifics are important; however, in Processing, a “good enough” simulation can be achieved without them.  We can, for example, make friction work with the assumption that the normal force will always have a magnitude of 1.  When we get into trigonometry in the next chapter, we’ll remember to return to this question and make our friction example a bit more sophisticated.  Therefore:</simpara>
<programlisting language="java" linenumbering="unnumbered">float normal = 1;</programlisting>
<simpara>Now that we have both the magnitude and direction for friction, we can put it all together:</simpara>
<programlisting language="java" linenumbering="unnumbered">float c = 0.01;
float normal = 1;
// Let’s figure out the magnitude of friction
// (really just an arbitrary constant).
float frictionMag = c*normal;

PVector friction = velocity.get();
friction.mult(-1);
friction.normalize();

// Take the unit vector and multiply it by magnitude
// and we have our force vector!
friction.mult(frictionMag);</programlisting>
<simpara>&#8230;and add it to our “forces” example, where many objects experience wind, gravity, and now friction:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex04a.png" canvas="processingjs/chapter02/_2_4_forces_nofriction/_2_4_forces_nofriction.pde processingjs/chapter02/_2_4_forces_nofriction/Mover.pde" classname="two-col" />
  </imageobject>
  <textobject><phrase>No friction</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex04b.png" canvas="processingjs/chapter02/_2_4_forces_friction/_2_4_forces_friction.pde processingjs/chapter02/_2_4_forces_friction/Mover.pde" classname="two-col" />
  </imageobject>
  <textobject><phrase>With friction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example4"><emphasis role="strong"><phrase role="example">Example 2.4: Including friction</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);

  PVector wind = new PVector(0.001,0);
  // We could scale by mass to be more accurate
  PVector gravity = new PVector(0,0.1);

  for (int i = 0; i &lt; movers.length; i++) {

    float c = 0.01; // [bold]
    PVector friction = movers[i].velocity.get(); // [bold]
    friction.mult(-1); // [bold]
    friction.normalize(); // [bold]
    friction.mult(c); // [bold]

    // Apply friction force vector to object
    movers[i].applyForce(friction); // [bold]
    movers[i].applyForce(wind);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }

}</programlisting>
<simpara>Running this example, you’ll notice that the circles don’t even make it to the right side of the window.  Since friction continuously pushes against the object in the opposite direction of its movement, the object continuously slows down.  This can be a useful technique or a problem depending on the goals of your visualization.</simpara>
<example id="chapter02_exercise4">
<title>Exercise 2.4</title>
<simpara>Create pockets of friction in a Processing sketch so that objects only experience the friction when crossing over that area.    What if you vary the strength (friction coefficient) of each area?   What if you make some of them the opposite of friction—i.e., when you enter a given pocket you actually speed up instead of slowing down?</simpara>
</example>
</section>
</section>
<section id="chapter02_section8">
<title>2.8 Air and Fluid Resistance</title>
<informalfigure id="chapter02_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_04.png" />
  </imageobject>
  <textobject><phrase>Figure 2.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Friction also occurs when a body passes through a liquid or gas.  This force has many different names, all really meaning the same thing: viscous force, drag force, fluid resistance.  While the result is ultimately the same as our previous friction examples (the object slows down), the way in which we calculate a drag force will be slightly different.  Let’s look at the formula:</simpara>
<simpara>&lt;div style="font-size: 2.0em;"&gt;&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; F &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; d &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt; = &lt;/mo&gt;&lt;mo&gt; - &lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt; 1 &lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mi&gt; &#x03C1; &lt;/mi&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt; 2 &lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mi&gt; A &lt;/mi&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt; C &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt; d &lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt;&lt;/div&gt;</simpara>
<simpara>Now let’s break this down and see what we really need for an effective simulation in Processing, making ourselves a much simpler formula in the process.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">F<subscript>d</subscript></phrase></emphasis> refers to “Drag Force”, the vector we ultimately want to compute and pass into our <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.
</simpara>
</listitem>
<listitem>
<simpara>
- 1/2 is a constant: -0.5!   This is fairly irrelevant in terms of our Processing world, as we will be making up values for other constants anyway.   However, the fact that it is negative is important, as it tells us that the force is in the opposite direction of velocity (just as with friction).
</simpara>
</listitem>
<listitem>
<simpara>
ρ is the Greek letter rho, and refers to the density of the liquid, something we don’t need to worry about.  We can simplify the problem and consider this to have a constant value of 1.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">v</phrase></emphasis> refers to the speed of the object moving.  OK, we’ve got this one!  The object’s speed is the magnitude of the velocity vector:  velocity.magnitude().  And <emphasis role="strong"><phrase role="var">v</phrase></emphasis><superscript>2</superscript> just means <emphasis role="strong"><phrase role="var">v</phrase></emphasis> squared or <emphasis role="strong"><phrase role="var">v</phrase></emphasis> * <emphasis role="strong"><phrase role="var">v</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
A refers to the frontal area of the object that is pushing through the liquid (or gas).  An aerodynamic Lamborghini, for example, will experience less air resistance than a boxy Volvo.   Nevertheless, for a basic simulation, we can consider our object to be spherical and ignore this element.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">C<subscript>d</subscript></phrase></emphasis> is the coefficient of drag, exactly the same as the coefficient of friction (<emphasis role="strong"><phrase role="var">μ</phrase></emphasis>).  This is a constant we’ll determine based on whether we want the drag force to be strong or weak.
</simpara>
</listitem>
<listitem>
<simpara>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; v &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt; Look familiar?  It should.  This refers to the velocity unit vector, i.e. velocity.normalize().  Just like with ￼friction, drag is a force that points in the opposite direction of velocity.
</simpara>
</listitem>
</itemizedlist>
<simpara>Now that we’ve analyzed each of these components and determined what we need for a simple simulation, we can reduce our formula to:</simpara>
<informalfigure id="chapter02_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_05.png" />
  </imageobject>
  <textobject><phrase>Figure 2.5: Our Simplified Drag Force formula</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>or:</simpara>
<programlisting language="java" linenumbering="unnumbered">float c = 0.1;
float speed = v.mag();
// Part 1 of our formula (magnitude): Cd * v2
float dragMagnitude = c * speed * speed;
PVector drag = velocity.get();
// Part 2 of our formula (direction):
// -1 * velocity
drag.mult(-1);
drag.normalize();
// Magnitude and direction together!
drag.mult(dragMagnitude);</programlisting>
<simpara>Let’s implement this force in our Mover example with one addition.   When we wrote our friction example, the force of friction was always present.  Whenever an object was moving, friction would slow it down.  Here, let’s introduce an element to the environment—a “liquid” that the Mover objects pass through.  The liquid object will be a rectangle and will know about its location, width, height, and “coefficient of drag”—i.e., is it easy for objects to move through it (like air) or difficult (like molasses)?  In addition, it should include a function to draw itself on the screen (and two more functions, which we’ll see in a moment.)</simpara>
<programlisting language="java" linenumbering="unnumbered">class Liquid {
  // The liquid object includes a variable defining
  // its coefficient of drag.
  float x,y,w,h;
  float c;

  Liquid(float x_, float y_, float w_, float h_, float c_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;
    c = c_;
  }

  void display() {
    noStroke();
    fill(175);
    rect(x,y,w,h);
  }

}</programlisting>
<simpara>The main program will now include a Liquid object reference as well as a line of code that initializes that object.</simpara>
<programlisting language="java" linenumbering="unnumbered">Liquid liquid;

void setup() {
  //[offset-up] Initialize a Liquid object.  Note how the coefficient value is low (0.1). Otherwise, the object would come to a halt fairly quickly (which may someday be the effect you want).
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
}</programlisting>
<simpara>Now comes an interesting question: how do we get the Mover object to talk to the Liquid object?  In other words, we want to execute the following:</simpara>
<simpara><emphasis>When a Mover passes through a Liquid it experiences a Drag force.</emphasis></simpara>
<simpara>or in object-oriented speak (assuming we are looping through an array of Mover objects with index i):</simpara>
<programlisting language="java" linenumbering="unnumbered">if (movers[i].isInside(liquid)) {
  // If a Mover is inside a Liquid, apply the drag force.
  movers[i].drag(liquid);
}</programlisting>
<simpara>The above code tells us that we need to add two functions to the Mover class: (1) a function that determines if a Mover object is inside the liquid, and (2) a function that computes and applies a drag force on the Mover object.</simpara>
<simpara>The first is easy; we can simply use a conditional statement to determine if the location vector rests inside the rectangle defined by the liquid.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean isInside(Liquid l) {
  //[offset-down] This conditional statement determines if the PVector location is inside the rectangle defined by the Liquid class.
  if (location.x&gt;l.x &amp;&amp; location.x&lt;l.x+l.w &amp;&amp; location.y&gt;l.y &amp;&amp; location.y&lt;l.y+l.h) {
    return true;
  } else {
    return false;
  }
}</programlisting>
<simpara>The <emphasis role="strong"><phrase role="function">drag()</phrase></emphasis> function is a bit more complicated; however, we’ve written the code for it already.  This is simply an implementation of our formula.  The drag force is equal to <emphasis>the coefficient of drag multiplied by the speed of the Mover squared in the opposite direction of velocity!</emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered"> void drag(Liquid l) {

    float speed = velocity.mag();
    // The force’s magnitude: Cd * v~2~
    float dragMagnitude = l.c * speed * speed;

    PVector drag = velocity.get();
    drag.mult(-1);
    // The force's direction: -1 * velocity
    drag.normalize();

    // Finalize force: magnitude and direction together
    drag.mult(dragMagnitude);

    // Apply the force
    applyForce(drag);
  }</programlisting>
<simpara>And with these two functions added to the Mover class, we’re ready to put it all together in the main tab:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex05.png" canvas="processingjs/chapter02/_2_5_fluidresistance/_2_5_fluidresistance.pde processingjs/chapter02/_2_5_fluidresistance/Liquid.pde processingjs/chapter02/_2_5_fluidresistance/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example5"><emphasis role="strong"><phrase role="example">Example 2.5: Fluid Resistance</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">Mover[] movers = new Mover[100];

Liquid liquid;

void setup() {
  size(360, 640);
  smooth();
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,5),0,0);
  }
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
}

void draw() {
  background(255);

  liquid.display();

  for (int i = 0; i &lt; movers.length; i++) {

    if (movers[i].isInside(liquid)) {
      movers[i].drag(liquid);
    }

    float m = 0.1*movers[i].mass;
    // Note we are scaling gravity according to mass.
    PVector gravity = new PVector(0, m);
    movers[i].applyForce(gravity);

    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}</programlisting>
<simpara>Running the example, you should notice that we are simulating balls falling into water.  The objects only slow down when crossing in the gray area at the bottom of the window (representing the liquid).  You’ll also notice that the smaller objects slow down a great deal more than the larger objects.    Remember Newton’s second law?  <emphasis role="strong"><phrase role="var">A</phrase></emphasis> = <emphasis role="strong"><phrase role="var">F</phrase></emphasis> / <emphasis role="strong"><phrase role="var">M</phrase></emphasis>. Acceleration equals Force <emphasis role="strong"><emphasis>divided</emphasis></emphasis> by mass.  A massive object will accelerate less.  A smaller object will accelerate more.    In this case, the acceleration we’re talking about is the “slowing down” due to drag.  The smaller objects will slow down at a greater rate than the larger ones.</simpara>
<example id="chapter02_exercise5">
<title>Exercise 2.5</title>
<simpara>Take a look at our formula for drag again.  <emphasis role="strong"><emphasis>DRAG FORCE = COEFFICIENT * SPEED * SPEED</emphasis></emphasis>.  The faster an object moves, the greater the drag force against it.  In fact, an object not moving in water experiences no drag at all.   Expand the example to drop the balls from different heights.  How does this affect the drag as they hit the water?</simpara>
</example>
<example id="chapter02_exercise6">
<title>Exercise 2.6</title>
<simpara>The formula for drag also included surface area.  Can you create a simulation of boxes falling into water with a drag force dependent on the length of the side hitting the water?</simpara>
</example>
<example id="chapter02_exercise7">
<title>Exercise 2.7</title>
<simpara>Fluid resistance does not work only opposite to the velocity vector, but also perpendicular to it.  This is known as “lift-induced drag” and will cause an airplane with an angled wing to rise in altitude.   Try creating a simulation of lift.</simpara>
</example>
</section>
<section id="chapter02_section9">
<title>2.9 Gravitational Attraction</title>
<informalfigure id="chapter02_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_06.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 2.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Probably the most famous force of all is gravity.   We humans on earth think of gravity as an apple hitting Isaac Newton on the head.    Gravity means that stuff falls down.  But this is only our experience of gravity.   In truth, just as the earth pulls the apple towards it due to a gravitational force, the apple pulls the earth as well.   The thing is, the earth is just so freaking big that it overwhelms all the other gravity interactions.  Every object with mass exerts a gravitational force on every other object.   And there is a formula for calculating the strengths of these forces, as depicted in Figure 2.6.</simpara>
<simpara>Let’s examine this formula a bit more closely:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">F</phrase></emphasis> refers to the gravitational force, the vector we ultimately want to compute and pass into our applyForce() function.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">G</phrase></emphasis> is the “Universal Gravitational Constant” and in our world equals 6.67428 x 10-11 meters cubed per kilogram per second squared.   This is a pretty important number if your name is Isaac Newton or Albert Einstein.  It’s not an important number if you are a Processing programmer.  Again, it’s a constant that we can use to make the forces in our world weaker or stronger.  Just making it equal to one and ignoring it isn’t such a terrible choice either.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">m<subscript>1</subscript></phrase></emphasis> and <emphasis role="strong"><phrase role="var">m<subscript>2</subscript></phrase></emphasis> are the masses of objects 1 and 2.   As we saw with Newton’s second law (F = M*A), mass is also something we could choose to ignore.  After all, shapes drawn on the screen don’t actually have a physical mass.  However, if we keep these values, we can create more interesting simulations where “bigger” objects exert a stronger gravitational force than smaller ones.
</simpara>
</listitem>
<listitem>
<simpara>
&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; r &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt; refers to the unit vector pointing from object 1 to object 2.  As we’ll see in a moment, we can compute this direction vector by subtracting the location of one object from the other.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">r</phrase></emphasis><superscript>2</superscript> refers to the distance between the two objects squared.  Let’s take a moment to think about this a bit more.  With everything on the top of the formula—<emphasis role="strong"><phrase role="var">G</phrase></emphasis>, <emphasis role="strong"><phrase role="var">m<subscript>1</subscript></phrase></emphasis>, <emphasis role="strong"><phrase role="var">m<subscript>2</subscript></phrase></emphasis>—the bigger its value, the stronger the force.  Big mass, big force.  Big <emphasis role="strong"><phrase role="var">G</phrase></emphasis>, big force.  Now, when we divide by something we have the opposite.  The strength of the force is inversely proportional to the distance squared.  The <emphasis>further</emphasis> away an object is, the <emphasis>weaker</emphasis> the force; the <emphasis>closer</emphasis>, the <emphasis>stronger</emphasis>.
</simpara>
</listitem>
</itemizedlist>
<simpara>Hopefully by now the formula makes some sense to us.  We’ve looked at a diagram and dissected the individual components of the formula.  Now it’s time to figure out how we translate the math into Processing code.  Let’s make the following assumptions.</simpara>
<simpara>We have two objects and:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Each object has a location: <emphasis role="strong"><phrase role="var">PVector location1</phrase></emphasis> and <emphasis role="strong"><phrase role="var">PVector location2</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
Each object has a mass: <emphasis role="strong"><phrase role="var">float mass1</phrase></emphasis> and <emphasis role="strong"><phrase role="var">float mass2</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
There is a variable <emphasis role="strong"><phrase role="var">float G</phrase></emphasis> for the universal gravitational constant.
</simpara>
</listitem>
</orderedlist>
<simpara>Given these assumptions, we want to compute <emphasis role="strong"><phrase role="var">PVector force</phrase></emphasis>, the force of gravity.  We’ll do it in two parts.  First, we’ll compute the direction of the force &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mover&gt;&lt;mrow&gt;&lt;mi&gt; r &lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt; &#x2227; &lt;/mo&gt;&lt;/mrow&gt;&lt;/mover&gt;&lt;/mstyle&gt;&lt;/math&gt; in the formula above).  Second, we’ll calculate the strength of the force according to the masses and distance.</simpara>
<informalfigure id="chapter02_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_07.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 2.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Remember in Chapter 1, when we figured out how to have an object accelerate towards the mouse? (See <link linkend="chapter01_section10">Chapter 1 Section 10</link>, as depicted in Figure 2.7.)</simpara>
<simpara>A vector is the difference between two points. To make a vector that points from the circle to the mouse, we simply subtract one point from another:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector dir = PVector.sub(mouse,location);</programlisting>
<simpara>In our case, the direction of the attraction force that object 1 exerts on object 2 is equal to:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector dir = PVector.sub(location1,location2);
dir.normalize();</programlisting>
<simpara>Don’t forget that since we want a unit vector, a vector that tells us about direction only, we’ll need to <emphasis role="strong"><emphasis>normalize</emphasis></emphasis> the vector after subtracting the locations.</simpara>
<simpara>OK, we’ve got the direction of the force.  Now we just need to compute the magnitude and scale the vector accordingly.</simpara>
<programlisting language="java" linenumbering="unnumbered">float m = (G * mass1 * mass2) / (distance * distance);
dir.mult(m);</programlisting>
<informalfigure id="chapter02_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_08.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 2.8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The only problem is that we don’t know the distance.  <emphasis role="strong"><phrase role="var">G</phrase></emphasis>, <emphasis role="strong"><phrase role="var">mass1</phrase></emphasis>, and <emphasis role="strong"><phrase role="var">mass2</phrase></emphasis> were all givens, but we’ll need to actually compute distance before the above code will work.   Didn’t we just make a vector that points all the way from one location to another?   Wouldn’t the length of that vector be the distance between two objects?</simpara>
<simpara>Well, if we add just one line of code and grab the magnitude of that vector before normalizing it, then we’ll have the distance.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The vector that points from one object to another
PVector force = PVector.sub(location1,location2);

// The length (magnitude) of that vector
// is the distance between the two objects.
float distance = force.magnitude();

// Use the formula for gravity to compute the strength of the force.
float m = (G * mass1 * mass2) / (distance * distance);

// Normalize and scale the force vector
// to the appropriate magnitude.
force.normalize();
force.mult(m);</programlisting>
<simpara>Note that I also renamed the PVector “dir” as “force.”   After all, when we’re finished with the calculations, the PVector we started with ends up being the actual force vector we wanted all along.</simpara>
<simpara>Now that we’ve worked out the math and the code for calculating an attractive force (emulating gravity), we need to turn our attention to applying this technique in the context of an actual Processing sketch.   In Example 2.x, you may recall how we created a simple Mover object—a class with PVector’s location, velocity, and acceleration as well as an <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis>.  Let’s take this exact class and put it in a sketch with:</simpara>
<informalfigure id="chapter02_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_09.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 2.9</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>
A single Mover object.
</simpara>
</listitem>
<listitem>
<simpara>
A single Attractor object (a new class that will have a fixed location).
</simpara>
</listitem>
</itemizedlist>
<simpara>The Mover object will experience a gravitational pull towards the Attractor object, as illustrated in Figure 2.9.</simpara>
<simpara>We can start by making the new Attractor class very simple—a location and a mass, along with a function to display itself (tying mass to size).</simpara>
<programlisting language="java" linenumbering="unnumbered">class Attractor {
  // Our Attractor is a simple object that doesn’t move.
  // We just need a mass and a location.
  float mass;
  PVector location;

  Attractor() {
    location = new PVector(width/2,height/2);
    mass = 20;
  }

  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}</programlisting>
<simpara>And in our main program, we can add an instance of the Attractor class.</simpara>
<programlisting language="java" linenumbering="unnumbered">Mover m;
Attractor a;

void setup() {
  size(200,200);
  m = new Mover();
  // Initialize Attractor object.
  a = new Attractor();
}

void draw() {
  background(255);

  // Display Attractor object.
  a.display();

  m.update();
  m.display();
}</programlisting>
<simpara>This is a good structure: a main program with a Mover and Attractor object, and a class to handle the variables and behaviors of Movers and Attractors.   The last piece of the puzzle is how to get one object to attract the other.  How do we get these two objects to talk to each other?</simpara>
<simpara>There are a number of ways we could do this.  Here are just a few possibilities:</simpara>
<passthrough><table class="code">
<tr>
<th>Task</th>
<th>Function</th>
</tr>
<tr>
<td>1. A function that receives both an Attractor and a Mover:</td>
<td><pre>attraction(a,m);</pre></td>
</tr>
<tr>
<td>2. A function in the Attractor class that receives a Mover:</td>
<td><pre>a.attract(m);</pre></td>
</tr>
<tr>
<td>3. A function in the Mover class that receives an Attractor:</td>
<td><pre>m.attractedTo(a);</pre></td>
</tr>
<tr>
<td>4. A function in the Attractor class that receives a Mover and returns a PVector, which is the attraction force.  That attraction force is then passed into the Mover's applyForce() function:</td>
<td>
<pre>
PVector f = a.attract(m);
m.applyForce(f);
</pre></td>
</tr>
</table></passthrough>
<simpara>and so on. . .</simpara>
<simpara>It’s good to look at a range of options for making objects talk to each other, and you could probably make arguments for each of the above possibilities.  I’d like to at least discard the first one, since an object-oriented approach is really a much better choice over an arbitrary function not tied to either the Mover or Attractor class.   Whether you pick (2) or (3) is the difference between saying “The attractor attracts the mover” or “The mover is attracted to the attractor.”  Number 4 is really my favorite, at least in terms of where we are in this book.  After all, we spent a lot of time working out the <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function and I think our examples will be clearer if we continue with the same methodology.</simpara>
<simpara>In other words, where we once had:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Made-up force
PVector f = new PVector(0.1,0);
m.applyForce(f);</programlisting>
<simpara>We now have:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Attraction force between two objects
PVector f = a.attract(m); //[bold]
m.applyForce(f);</programlisting>
<simpara>And so our draw() function can now be written as:</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);

  //[full] Calculate attraction force and apply it.
  PVector f = a.attract(m); //[bold]
  m.applyForce(f); //[bold]
  //[end]

  m.update();

  a.display();
  m.display();

}</programlisting>
<simpara>We’re almost there.  Since we decided to put the attract() function inside of the Attractor class, we’ll need to actually write that function.   The function needs to receive a Mover object and return a PVector, i.e.:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector attract(Mover m) {

}</programlisting>
<simpara>And what goes inside that function?  All of that nice math we worked out for gravitational attraction!</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector attract(Mover m) {

  // What’s the force’s direction?
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  force.normalize();
  //[offset-down] What’s the force’s magnitude?
  float strength = (G * mass * m.mass) / (distance * distance);
  force.mult(strength);

  // Return the force so that it can be applied!
  return force;
}</programlisting>
<simpara>And we’re done.  Sort of.  Almost.  There’s one small kink we need to work out.  Let’s look at the above code again.  See that symbol for divide, the slash?  Whenever we have one of these, we need to ask ourselves the question:  What would happen if  the distance happened to be a really, really small number or (even worse!) zero??!  Well, we know we can’t divide a number by zero, and if we were to divide a number by something like 0.0001, that is the equivalent of multiplying that number by 10,000!   Yes, this is the real-world formula for the strength of gravity, but we don’t live in the real world.  We live in the <emphasis>Processing</emphasis> world.   And in the Processing world, the Mover could end up being very, very close to the Attractor and the force could become so strong the Mover would just fly way off the screen.   And so with this formula, it’s good for us to be practical and constrain the range of what distance can actually be.   Maybe, no matter where the Mover actually is, we should never consider it less than 5 pixels or more than 25 pixels away from the Attractor.</simpara>
<programlisting language="java" linenumbering="unnumbered">  distance = constrain(distance,5,25);</programlisting>
<simpara>For the same reason we need to constrain the minimum distance, it’s useful for us to do the same with the maximum.  After all, if the Mover were to be, say, 500 pixels from the Attractor (not unreasonable), we’d be dividing the force by 250,000.  That force might end up being so weak that it’s almost as if we’re not applying it at all.</simpara>
<simpara>Now, it’s really up to you to decide what behaviors you want.  But in the case of, “I want reasonable-looking attraction that is never absurdly weak or strong,” then constraining the distance is a good technique.</simpara>
<simpara>Our Mover class hasn’t changed at all, so let’s just look at the main program and Attractor class as a whole, adding a variable “g” for the universal gravitational constant.  (On the web site, you’ll find that this example also has code that allows you to move the Attractor object with the mouse):</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex06.png" canvas="processingjs/chapter02/_2_6_attraction/_2_6_attraction.pde processingjs/chapter02/_2_6_attraction/Attractor.pde processingjs/chapter02/_2_6_attraction/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example6"><emphasis role="strong"><phrase role="example">Example 2.6: Attraction</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// A Mover and an Attractor
Mover m;
Attractor a;

void setup() {
  size(200,200);
  m = new Mover();
  a = new Attractor();
}

void draw() {
  background(255);

  // Apply the attraction force from the Attractor on the Mover.
  PVector force = a.attract(m);
  m.applyForce(force);
  m.update();

  a.display();
  m.display();
}

class Attractor {
  float mass;
  PVector location;
  float G;

  Attractor() {
    location = new PVector(width/2,height/2);
    mass = 20;
    G = 0.4;
  }

  PVector attract(Mover m) {
    PVector force = PVector.sub(location,m.location);
    float distance = force.mag();
    // Remember, we need to constrain the distance
    // so that our circle doesn’t spin out of control.
    distance = constrain(distance,5.0,25.0);


    force.normalize();
    float strength = (G * mass * m.mass) / (distance * distance);
    force.mult(strength);
    return force;
  }

  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}</programlisting>
<simpara>And we could, of course, expand this example using an array to include many Mover objects, just as we did with friction and drag:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex07.png" canvas="processingjs/chapter02/_2_7_attraction_many/_2_7_attraction_many.pde processingjs/chapter02/_2_7_attraction_many/Attractor.pde processingjs/chapter02/_2_7_attraction_many/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex07.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example7"><emphasis role="strong"><phrase role="example">Example 2.7: Attraction with many Movers</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// Now we have 10 Movers!
Mover[] movers = new Mover[10];

Attractor a;

void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    //[offset-down] Each Mover is initialized randomly
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
  a = new Attractor();
}

void draw() {
  background(255);

  a.display();

  for (int i = 0; i &lt; movers.length; i++) {
    // We calculate an attraction force for each Mover object.
    PVector force = a.attract(movers[i]);
    movers[i].applyForce(force);

    movers[i].update();
    movers[i].display();
  }

}</programlisting>
<example id="chapter02_exercise8">
<title>Exercise 2.8</title>
<simpara>In the example above, we have a system (i.e. array) of Mover objects and one Attractor object.  Build an example that has both systems of Movers and Attractors.  What if you make the Attractors invisible?  Can you create a pattern / design from the trails of objects moving around attractors?  (See the Metropop Denim project by Clayton Cubitt and Tom Carden: <ulink url="http://processing.org/exhibition/works/metropop/">http://processing.org/exhibition/works/metropop/</ulink>) for an example.)</simpara>
</example>
<example id="chapter02_exercise9">
<title>Exercise 2.9</title>
<simpara>It’s worth noting that gravitational attraction is a model we can follow to develop our own forces.  This chapter isn’t suggesting that you should exclusively create sketches that use gravitational attraction.  Rather, you should be thinking creatively about how to design your own rules to drive the behavior of objects.  For example, what happens if you design a force that is weaker the closer it gets and stronger the farther it gets?  Or what if you design your attractor to attract far away objects, but repel close ones?</simpara>
</example>
</section>
<section id="chapter02_section10">
<title>2.10 Everything Attracts (or Repels) Everything</title>
<simpara>Hopefully, you found it helpful that we started with a simple scenario:  <emphasis>one object attracts another object</emphasis>, moving on to <emphasis>one object attracts many objects</emphasis>.  However, it’s likely that you are going to find yourself in a slightly more complex situation: <emphasis>many objects attract each other</emphasis>.  In other words, every object in a given system attracts every other object in that system (except for itself).</simpara>
<simpara>We’ve really done almost all of the work for this already.  Let’s consider a Processing sketch with an array of Mover objects:</simpara>
<programlisting language="java" linenumbering="unnumbered">Mover[] movers = new Mover[10];

void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
}

void draw() {
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i].update();
    movers[i].display();
  }
}</programlisting>
<simpara>The <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> function is where we need to work some magic.  Currently, we’re saying: “for every Mover i, update and display yourself.”  Now what we need to say is: “for every Mover i, be attracted to every other Mover j, and update and display yourself.”</simpara>
<simpara>To do this, we need to nest a second loop.</simpara>
<programlisting language="java" linenumbering="unnumbered"> for (int i = 0; i &lt; movers.length; i++) {
  // For every Mover, check every Mover!
    for (int j = 0; j &lt; movers.length; j++) {
      PVector force = movers[j].attract(movers[i]);
      movers[i].applyForce(force);
    }
    movers[i].update();
    movers[i].display();
  }</programlisting>
<simpara>In the previous example, we had an <emphasis role="strong"><phrase role="klass">Attractor</phrase></emphasis> object with a function named <emphasis role="strong"><phrase role="function">attract()</phrase></emphasis>.  Now, since we have <emphasis role="strong"><phrase role="klass">Movers</phrase></emphasis> attracting <emphasis role="strong"><phrase role="klass">Movers</phrase></emphasis>, all we need to do is copy the <emphasis role="strong"><phrase role="function">attract()</phrase></emphasis> function into the <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> class.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  [inline]// All the other stuff we had before plus. . .

  // The Mover now knows how to attract another Mover.
  PVector attract(Mover m) {

    PVector force = PVector.sub(location,m.location);
    float distance = force.mag();
    distance = constrain(distance,5.0,25.0);
    force.normalize();

    float strength = (G * mass * m.mass) / (distance * distance);
    force.mult(strength);
    return force;
  }
}</programlisting>
<simpara>Of course, there’s one small problem. When we are looking at every <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> <emphasis role="strong"><phrase role="var">i</phrase></emphasis> and every  <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> <emphasis role="strong"><phrase role="var">j</phrase></emphasis> , are we OK with the times that <emphasis role="strong"><phrase role="var">i</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">j</phrase></emphasis>?  For example, should <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> #3 attract <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> #3?   The answer, of course, is no.   If there are five objects, we only want <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> #3 to attract 0, 1, 2, and 4, skipping itself.   And so, we finish this example by adding a simple conditional statement to skip applying the force when i equals j.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter02/ch02_ex08.png" canvas="processingjs/chapter02/_2_8_mutual_attraction/_2_8_mutual_attraction.pde processingjs/chapter02/_2_8_mutual_attraction/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter02/ch02_ex08.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter02_example8"><emphasis role="strong"><phrase role="example">Example 2.8: Mutual Attraction</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">Mover[] movers = new Mover[20];

float g = 0.4;

void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
}

void draw() {
  background(255);

  for (int i = 0; i &lt; movers.length; i++) {
    for (int j = 0; j &lt; movers.length; j++) {
      // Don’t attract yourself!
      if (i != j) {
        PVector force = movers[j].attract(movers[i]);
        movers[i].applyForce(force);
      }
    }
    movers[i].update();
    movers[i].display();
  }
}</programlisting>
<example id="chapter02_exercise10">
<title>Exercise 2.10</title>
<simpara>Change the attraction force in Example 2.x to a repulsion force.  Can you create an example where all of the Mover objects are attracted to the mouse, but repel each other?  Think about how you need to balance the relative strength of the forces and how to most effectively use distance in your force calculations.</simpara>
</example>
<tip>
<title>The Ecosystem Project:</title>
<simpara>Step 2 Exercise:</simpara>
<simpara>Incorporate the concept of forces into your ecosystem.   Try introducing other elements into the environment (food, a predator) that the creature interacts with.   Does the creature experience attraction or repulsion to things in its world?  Can you think more abstractly and design forces based on the creature’s desires or goals?</simpara>
</tip>
</section>
</chapter>
<chapter id="_chapter_3_oscillation">
<title>Chapter 3.  Oscillation</title>
<blockquote>
<attribution>
Anonymous
</attribution>
<simpara>“Trigonometry is a sine of the times.”</simpara>
</blockquote>
<simpara>In Chapters 1 and 2, we carefully worked out an object-oriented structure to make something move on the screen, using the concept of a vector to represent location, velocity, and acceleration driven by forces in the environment.   We could move straight from here into topics such as particle systems, steering forces, group behaviors, etc.  If we did that, however, we’d skip an important area of mathematics that we’re going to need: <emphasis role="strong"><emphasis>trigonometry</emphasis></emphasis>, the mathematics of triangles, specifically right triangles.</simpara>
<simpara>Trigonometry is going to give us a lot of tools.   We’ll get to think about angles and angular velocity and acceleration.  It’s going to teach us about the sine and cosine functions, which when used properly can yield an nice ease-in, ease-out wave pattern.   It’s going to allow us to calculate more complex forces in an environment that involves angles, such as a pendulum swinging or a box sliding down an incline.</simpara>
<simpara>So this chapter is a bit of a mishmash. We’ll start with the basics of angles in Processing and cover many trigonometric topics, tying it all into forces at the end.  And by taking this break now, we’ll also pave the way for more advanced examples that require trig later in this book.</simpara>
<section id="chapter03_section1">
<title>3.1  Angles</title>
<simpara>OK. Before we can do any of this stuff, we need to make sure we understand what it means to be an angle in Processing.   If you have experience with Processing, you’ve undoubtedly encountered this question while using the <emphasis role="strong"><phrase role="function">rotate()</phrase></emphasis> function to rotate and spin objects.</simpara>
<simpara>The first order of business is <emphasis role="strong"><emphasis>radians</emphasis></emphasis> and <emphasis role="strong"><emphasis>degrees</emphasis></emphasis>.  You’re probably familiar with the concept of an angle in degrees.  A full rotation goes from zero to 360 degrees.   90 degrees (a right angle) is 1/4th  of 360, shown below as two perpendicular lines.</simpara>
<informalfigure id="chapter03_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_01.png" />
  </imageobject>
  <textobject><phrase>Figure 3.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>It’s fairly intuitive for us to think of angles of in terms of degrees.  For example, the square in Figure 3.2 is rotated 45 degrees around its center.</simpara>
<informalfigure id="chapter03_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_02.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Processing, however, requires angles to be specified in <emphasis role="strong"><emphasis>radians</emphasis></emphasis>.   A radian is a unit of measurement for angles defined by the ratio of the length of the arc of a circle to the radius of that circle.   One radian is the angle at which that ratio equals one (see figure x.x).  180 degrees = PI radians, 360 degrees = 2*PI radians, 90 degrees = PI/2 radians, etc.</simpara>
<informalfigure id="chapter03_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_03.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The formula to convert from degrees to radians is:</simpara>
<simpara>radians = 2 * PI * (degrees / 360)</simpara>
<simpara>Fortunately for us, if we prefer to think in degrees but code with radians, Processing makes this easy.  The <emphasis role="strong"><phrase role="function">radians()</phrase></emphasis> function will automatically convert values from degrees to radians.  In addition, the constants PI and TWO_PI provide convenient access to these commonly used numbers (equivalent to 180 and 360 degrees, respectively).   The following code, for example, will rotate shapes by 60 degrees.</simpara>
<programlisting language="java" linenumbering="unnumbered">float angle = radians(60);
rotate(angle);</programlisting>
<simpara>(If you are not familiar with how rotation is implemented in Processing, I would suggest this tutorial: <ulink url="http://www.processing.org/learning/transform2d/)">Processing - Transform 2D</ulink>).</simpara>
<note>
<title>What is PI?</title>
<simpara>The mathematical constant pi (or π) is a real number defined as the ratio of a circle&#8217;s circumference (the distance around the perimeter) to its diameter (a straight line that passes through the circle center).  It is equal to approximately 3.14159 and can be accessed in Processing with the built-in variable PI.</simpara>
</note>
<example id="chapter03_exercise1">
<title>Exercise 3.1</title>
<simpara>Rotate a baton-like object (see below) around its center using <emphasis role="strong"><phrase role="function">translate()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">rotate()</phrase></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_exc01.png" canvas="processingjs/chapter03/Ex_3_01_exercise_baton/Ex_3_01_exercise_baton.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_exc01.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter03_section2">
<title>3.2 Angular Motion</title>
<simpara>Remember all this stuff?</simpara>
<simpara><emphasis role="strong"><phrase role="formula">location = location + velocity;</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">velocity = velocity + acceleration;</phrase></emphasis></simpara>
<simpara>The stuff we dedicated almost all of Chapters 1 and 2 to?  Well, we can apply exactly the same logic to a rotating object.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">angle = angle + angular velocity</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">angular velocity = angular velocity + angular acceleration</phrase></emphasis></simpara>
<simpara>In fact, the above is actually simpler than what we started with because an angle is a <emphasis role="strong"><emphasis>scalar</emphasis></emphasis> quantity—a single number, not a vector!</simpara>
<simpara>Using the answer from <link linkend="chapter03_exercise1">Exercise 3.1</link>, let’s say we were going to rotate a baton in Processing by some angle.  We would have code like:</simpara>
<programlisting language="java" linenumbering="unnumbered">  translate(width/2,height/2);
  rotate(angle);
  line(-50,0,50,0);
  ellipse(50,0,8,8);
  ellipse(-50,0,8,8);</programlisting>
<simpara>Adding in our principles of motion, we’d have something like:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex01.png" canvas="processingjs/chapter03/_3_01_angular_motion/_3_01_angular_motion.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example1"><emphasis role="strong"><phrase role="example">Example 3.1: Angular motion using rotate()</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// location
float angle = 0;
// velocity
float aVelocity = 0;
// acceleration
float aAcceleration = 0.001;

void setup() {
  size(200,200);
}

void draw() {
  background(255);

  fill(175);
  stroke(0);
  rectMode(CENTER);
  translate(width/2,height/2);
  rotate(angle);
  line(-50,0,50,0);
  ellipse(50,0,8,8);
  ellipse(-50,0,8,8);

  // Angular equivalent of velocity.add(acceleration);
  aVelocity += aAcceleration;
  // Angular equivalent of location.add(velocity);
  angle += aVelocity;
}</programlisting>
<simpara>The baton starts onscreen with no rotation and then spins faster and faster and faster as the angle of rotation accelerates.</simpara>
<simpara>This idea can be incorporated into our Mover object.  For example, we can add the variables related to angular motion to our Mover.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float mass;

  float angle = 0;
  float aVelocity = 0;
  float aAcceleration = 0;</programlisting>
<simpara>And then in <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>, we update both location and angle according to the same algorithm!</simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {

    //[full] Regular old-fashioned motion of Cartesian location
    velocity.add(acceleration);
    location.add(velocity);
    //[end]

    //[full] New-fangled angular motion
    aVelocity += aAcceleration;
    angle += aVelocity;
    //[end]

    acceleration.mult(0);
  }</programlisting>
<simpara>Of course, for any of this to matter, we also would need to rotate the object when displaying it.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    stroke(0);
    fill(175,200);
    rectMode(CENTER);
    // pushMatrix() and popMatrix() are necessary
    // so that the rotation of this shape doesn’t
    // affect the rest of the world.
    pushMatrix();

    // Set the origin at the shape’s location.
    translate(location.x,location.y);
    // Rotate by the angle.
    rotate(angle);
    rect(0,0,mass*16,mass*16);
    popMatrix();
  }</programlisting>
<simpara>Now, if we were to actually go ahead and run the above code, we wouldn’t see anything new.  This is because angular the acceleration (<emphasis role="strong"><phrase role="function">float aAcceleration = 0;</phrase></emphasis>) is initialized to zero.  For the object to rotate, we need to give it an acceleration!  Certainly, we could hard-code in a different number.</simpara>
<programlisting language="java" linenumbering="unnumbered">float aAcceleration = 0.01;</programlisting>
<simpara>However, a more interesting result can be produced by dynamically assigning an angular acceleration according to forces in the environment.   Now, we could head far down this road, trying to model realistically the physics of angular acceleration using the concepts of torque (<ulink url="http://en.wikipedia.org/wiki/Torque">Torque</ulink>) and moment of inertia (<ulink url="http://en.wikipedia.org/wiki/Moment_of_inertia">Moment of Intertia</ulink>).    Nevertheless, this level of simulation is beyond the scope of this book.  (We will see more about modeling angular acceleration with a pendulum later in this chapter, as well as look at how Box2D realistically models rotational motion in Chapter 5.)</simpara>
<simpara>For now, a quick and dirty solution will do.  We can produce reasonable results by simply calculating angular acceleration as a function of the object’s acceleration vector.  Here’s one such example:</simpara>
<programlisting language="java" linenumbering="unnumbered">    aAcceleration = acceleration.x;</programlisting>
<simpara>Yes, this is completely arbitrary.  But it does do something.  If the object is accelerating to the right, its angular rotation accelerates in a clockwise direction; acceleration to the left results in a counterclockwise rotation.  Of course, it’s important to think about scale in this case. The <emphasis role="strong"><phrase role="var">x</phrase></emphasis> component of the acceleration vector might be a quantity that’s too large, causing the object to spin in way that looks ridiculous or unrealistic.  So dividing the <emphasis role="strong"><phrase role="var">x</phrase></emphasis> component by some value, or perhaps constraining the angular velocity to a reasonable range, could really help.  Here’s the entire <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> function with these tweaks added:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex02.png" canvas="processingjs/chapter03/_3_02_forces_angular_motion/_3_02_forces_angular_motion.pde processingjs/chapter03/_3_02_forces_angular_motion/Attractor.pde processingjs/chapter03/_3_02_forces_angular_motion/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example2"><emphasis role="strong"><phrase role="example">Example 3.2: Forces with (Arbitrary) Angular Motion</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {

    velocity.add(acceleration);
    location.add(velocity);

    // Calculate angular acceleration according to
    // acceleration’s horizontal direction and
    // magnitude.
    aAcceleration = acceleration.x / 10.0;
    aVelocity += aAcceleration;
    // Use constrain() to ensure that angular
    // velocity doesn’t spin out of control.
    aVelocity = constrain(aVelocity,-0.1,0.1);
    angle += aVelocity;

    acceleration.mult(0);
  }</programlisting>
<example id="chapter03_exercise2">
<title>Exercise 3.2</title>
<simpara>Step 1.  Create a simulation where objects are shot out of a cannon.  Each object should experience a sudden force when shot (just once) as well as gravity (always present).  Step 2.  Add rotation to the object to model its spin as it is shot from the cannon.  How realistic can you make it look?</simpara>
</example>
</section>
<section id="chapter03_section3">
<title>3.3 Trigonometry</title>
<simpara>I think it may be time.  We’ve looked at angles, we’ve spun an object.  It’s time for: <emphasis>sohcahtoa</emphasis>.  Yes, <emphasis>sohcahtoa</emphasis>.  Strangely enough, this seemingly nonsensical word is the foundation for a lot of computer graphics work.    Anytime you need to calculate an angle, determine the distance between points, deal with circles, arcs, lines, etc., you will find that a basic understanding of trigonometry is essential.  And <emphasis>sohcahtoa</emphasis> is a  mnemonic device (albeit a somewhat absurd one) for remembering the definitions of the trigonometric functions sine, cosine, and tangent.</simpara>
<informalfigure id="chapter03_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_04.png" />
  </imageobject>
  <textobject><phrase>Figure 3.4</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>soh</emphasis></emphasis>: sine  = opposite / hypotenuse
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>cah</emphasis></emphasis>: cosine  = adjacent / hypotenuse
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>toa</emphasis></emphasis>: tangent  = opposite / adjacent
</simpara>
</listitem>
</itemizedlist>
<informalfigure id="chapter03_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_05.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Take a look at the above diagram again.  There’s no need to memorize it, but make sure you feel comfortable with it.  Draw it again yourself.    Now let’s draw it a slightly different way (Figure 3.5).</simpara>
<simpara>See how we create a right triangle out of a vector?  The vector arrow itself is the hypotenuse and the components of the vector (x and y) are the sides of the triangle.  The angle is an additional means for specifying the vector’s direction (or “heading”).</simpara>
<simpara>Because the trigonometric functions allow us to establish a relationship between the components of a vector and its direction+magnitude, they will prove very useful throughout this book.  We’ll begin by looking at an example that requires the tangent function.</simpara>
</section>
<section id="chapter03_section4">
<title>3.4 Pointing in the Direction of Movement</title>
<simpara>Let’s go all the way back to Example 1.10, which features a <emphasis role="strong"><phrase role="class">Mover</phrase></emphasis> object accelerating towards the mouse.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01/ch1_ex10.png" canvas="processingjs/chapter01/_1_10_motion101_acceleration/_1_10_motion101_acceleration.pde processingjs/chapter01/_1_10_motion101_acceleration/Mover.pde" />
  </imageobject>
  <textobject><phrase>imgs/chapter01/ch1_ex10.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You might notice that almost all of the shapes we’ve been drawing so far are circles.   This is convenient for a number of reasons, one of which is that we don’t have to consider the question of rotation.  Rotate a circle and, well, it looks exactly the same.  However, there comes a time in all motion programmers’ lives when you want to draw something on the screen that points in the direction of movement. Perhaps you are drawing an ant, or a car, or a spaceship. And when we say point in the direction of movement, what we are really saying is “rotate according to the velocity vector.”  Velocity is a vector, with an <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and a <emphasis role="strong"><phrase role="var">y</phrase></emphasis> component, but to rotate in Processing we need an angle, in radians.   Let’s draw our trigonometry diagram one more time, with an object’s velocity vector (Figure 3.6).</simpara>
<informalfigure id="chapter03_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_06.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>OK. We know that the definition of tangent is:</simpara>
<simpara><emphasis>tangent(angle) = velocity<subscript>y</subscript>  / velocity<subscript>x</subscript></emphasis></simpara>
<simpara>The problem with the above is that we know velocity, but we don’t know the angle.  We have to solve for the angle.   This is where a special function known as <emphasis>inverse tangent</emphasis> comes in, sometimes referred to as <emphasis>arctangent</emphasis>.  (There is also an <emphasis>inverse sine</emphasis> and an <emphasis>inverse cosine</emphasis>.)</simpara>
<simpara>If the tangent of some value <emphasis role="strong"><phrase role="var">a</phrase></emphasis> equals some value <emphasis role="strong"><phrase role="var">b</phrase></emphasis>, then the inverse tangent of <emphasis role="strong"><phrase role="var">b</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">a</phrase></emphasis>, for example:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis>if</emphasis>
</term>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="formula">tangent(a) = b</phrase></emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis>then</emphasis>
</term>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="formula">a = arctangent(b)</phrase></emphasis>
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>See how that is the inverse?   The above now allows us to solve for the angle:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis>if</emphasis>
</term>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="formula">tangent(angle) = velocity<subscript>y</subscript>  / velocity<subscript>x</subscript></phrase></emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis>then</emphasis>
</term>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="formula">angle = arctangent(velocity<subscript>y</subscript>  / velocity<subscript>x</subscript>)</phrase></emphasis>
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Now that we have the formula, let’s see where it should go in our Mover’s <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> function.   Notice how in Processing, the function for arctangent is called <emphasis role="strong"><phrase role="function">atan()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    // Solve for angle by using atan().
    float angle = atan(velocity.y/velocity.x);

    stroke(0);
    fill(175);
    pushMatrix();
    rectMode(CENTER);
    translate(location.x,location.y);
    // Rotate according to that angle.
    rotate(angle);
    rect(0,0,30,10);
    popMatrix();
  }</programlisting>
<simpara>Now the above code is pretty darn close, and almost works.   There’s a pretty big problem, though.  Let’s consider the following two velocity vectors depicted.</simpara>
<informalfigure id="chapter03_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_07.png" />
  </imageobject>
  <textobject><phrase>Figure 3.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Though superficially similar, the two vectors point in quite different directions—opposite  directions, in fact!  However, if we were to apply our formula to solve for the angle to each vector&#8230;</simpara>
<simpara><emphasis>V1 =&#8658; angle = atan(-4/3) = atan(-1.25) = -0.9272952 radians = -53 degrees</emphasis><?asciidoc-br?>
<emphasis>V2 =&#8658; angle = atan(4/-3) = atan(-1.25) = -0.9272952 radians = -53 degrees</emphasis></simpara>
<simpara>We get the same angle for each vector.   This can’t be right for both; the vectors point in opposite directions!   The thing is, this is a pretty common problem in computer graphics. Rather than simply using <emphasis role="strong"><phrase role="function">atan()</phrase></emphasis> along with a bunch of conditional statements to account for positive/negative scenarios, Processing (and pretty much all programming environments) has a nice function called <emphasis role="strong"><phrase role="function">atan2()</phrase></emphasis> that does it for you.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex03.png" canvas="processingjs/chapter03/_3_03_pointing_velocity/_3_03_pointing_velocity.pde  processingjs/chapter03/_3_03_pointing_velocity/Mover.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example3"><emphasis role="strong"><phrase role="example">Example 3.3: Pointing in the direction of motion</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    // Using atan2() to account for all possible directions
    float angle = atan2(velocity.y,velocity.x);

    stroke(0);
    fill(175);
    pushMatrix();
    rectMode(CENTER);
    translate(location.x,location.y);
    rotate(angle);
    rect(0,0,30,10);
    popMatrix();
  }</programlisting>
<simpara>To simplify this even further, the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class itself provides a function <emphasis role="strong"><phrase role="class">heading2D()</phrase></emphasis>, which takes care of calling <emphasis role="strong"><phrase role="function">atan2()</phrase></emphasis> for you so you can get the direction angle, in radians, for any Processing PVector.</simpara>
<programlisting language="java" linenumbering="unnumbered">    // The easiest way to do this!
    float angle = velocity.heading2D();</programlisting>
<example id="chapter03_exercise3">
<title>Exercise 3.3</title>
<simpara>Create a simulation of a vehicle that you can drive around the screen using the arrow keys: left arrow accelerates the car to the left, right to the right.  The car should point in the direction in which it is currently moving.</simpara>
</example>
</section>
<section id="chapter03_section5">
<title>3.5 Polar vs. Cartesian Coordinates</title>
<simpara>Any time we display a shape in Processing, we have to specify a pixel location, a set of x and y coordinates.  These coordinates are known as Cartesian coordinates, named for the French mathematician René Descartes who developed the ideas behind Cartesian space.</simpara>
<simpara>Another useful coordinate system known as <emphasis>polar coordinates</emphasis> describes a point in space as an angle of rotation around the origin and a radius from the origin.   Thinking about this in terms of a vector:</simpara>
<simpara>Cartesian coordinate:   the x,y components of a vector<?asciidoc-br?>
Polar coordinate:       the magnitude (length) and direction (angle) of a vector</simpara>
<simpara>Processing’s drawing functions, however, don’t understand polar coordinates.  Whenever we want to display something in Processing we have to specify locations as (<emphasis>x</emphasis>,<emphasis>y</emphasis>) Cartesian coordinates.   However, sometimes it is a great deal more convenient for us to think in polar coordinates when designing.   Happily for us, with trigonometry we can convert back and forth between polar and Cartesian, which allows us to design with whatever coordinate system we have in mind but always draw with Cartesian coordinates.</simpara>
<informalfigure id="chapter03_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_08.png" />
  </imageobject>
  <textobject><phrase>Figure 3.8: The Greek letter θ (theta) is often used to denote an angle.  Since it’s the convention for a polar coordinate to be referred to as (r, θ), we’ll use theta as a variable name when referring to an angle.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="formula">sine(theta) = y / r</phrase></emphasis>     -&#8594; <emphasis role="strong">y = r * sine(theta)</emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">cosine(theta) = x / r</phrase></emphasis>   -&#8594; <emphasis role="strong">x = r * cosine(theta)</emphasis></simpara>
<simpara>For example, if <emphasis role="strong"><phrase role="var">r</phrase></emphasis> is 75 and <emphasis role="strong"><phrase role="var">theta</phrase></emphasis> is 45 degrees (or PI/4 radians), we can calculate x and y as below.  The functions for sine and cosine in Processing are <emphasis role="strong"><phrase role="function">sin()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">cos()</phrase></emphasis> respectively.  They each take one argument, an angle measured in radians.</simpara>
<programlisting language="java" linenumbering="unnumbered">float r = 75;
float theta = PI / 4;
// Converting from polar (r,theta) to Cartesian (x,y)
float x = r * cos(theta);
float y = r * sin(theta);</programlisting>
<simpara>This type of conversion can be useful in certain applications.  For example, to move a shape along a circular path using Cartesian coordinates is not so easy.  With polar coordinates, on the other hand, it’s simple: increment the angle!
￼
Here’s how it is done with global variables <emphasis role="strong"><phrase role="var">r</phrase></emphasis> and <emphasis role="strong"><phrase role="var">theta</phrase></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex04.png" canvas="processingjs/chapter03/_3_04_PolarToCartesian/_3_04_PolarToCartesian.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example4"><emphasis role="strong"><phrase role="example">Example 3.4: Polar to Cartesian</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">float r = 75;
float theta = 0;

void setup() {
  size(200,200);
  background(255);
  smooth();
}

void draw() {

  // Polar coordinates (r,theta) are converted to Cartesian (x,y)
  // for use in the ellipse() function.
  float x = r * cos(theta);
  float y = r * sin(theta);

  noStroke();
  fill(0);
  ellipse(x+width/2, y+height/2, 16, 16);

  theta += 0.01;
}</programlisting>
<example id="chapter03_exercise4">
<title>Exercise 3.4</title>
<simpara>Using the Example 3.4 as a basis, draw a spiral path.  Start in the center and move outwards.  Note that this can be done by only changing one line of code and adding one line of code!</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_exc04.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_exc04.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example id="chapter03_exercise5">
<title>Exercise 3.5</title>
<simpara>Simulate the spaceship in the game Asteroids.   In case you aren’t familiar with Asteroids, here is a brief description: A spaceship (represented as a triangle) floats in two dimensional space.   The left arrow keys turns the spaceship counterclockwise, the right clockwise.  The space bar applies a “thrust” force in the direction the spaceship is pointing.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_exc05.png" canvas="processingjs/chapter03/Ex_3_05_asteroids/Ex_3_05_asteroids.pde processingjs/chapter03/Ex_3_05_asteroids/Spaceship.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_exc05.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter03_section6">
<title>3.6 Oscillation Amplitude and Period</title>
<simpara>Are you amazed yet?  We’ve seen pretty great uses of tangent (for finding the angle of a vector) and sine and cosine (for converting from polar to Cartesian coordinates).   We could stop right here and be satisfied.  But we’re not going to.  This is only the beginning.  What sine and cosine can do for you goes beyond mathematical formulas and right triangles.</simpara>
<simpara>Let’s take a look at a graph of the sine function, where y = sin(x).</simpara>
<informalfigure id="chapter03_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_09.png" />
  </imageobject>
  <textobject><phrase>Figure 3.9</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You’ll notice that the output of the sine function is a smooth curve alternating between –1 and 1.  This type of a behavior is known as <emphasis role="strong"><emphasis>oscillation</emphasis></emphasis>, a periodic movement between two points.  Plucking a guitar string, swinging a pendulum, bouncing on a pogo stick—these are all examples of oscillating motion.</simpara>
<simpara>And so we happily discover that we can simulate oscillation in a Processing sketch by assigning the output of the sine function to an object’s location.  (Note this will follow the same methodology we applied to Perlin noise in the &lt;&lt;<anchor id="intro_section6" xreflabel="[intro_section6]"/>, Introduction&gt;&gt;.</simpara>
<simpara>Let’s begin with a really basic scenario.  We want a circle to oscillate from the left side to the right side of a Processing window.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex05.png" canvas="processingjs/chapter03/_3_05_simple_harmonic_motion/_3_05_simple_harmonic_motion.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is what is known as simple harmonic motion (or to be fancier: “the periodic sinusoidal oscillation of an object”).   This is going to be a simple program to write, but before we get into the code, let’s familiarize ourselves with some of the terminology of oscillation (and waves).</simpara>
<simpara>Simple harmonic motion can be expressed as any location (in our case, the <emphasis role="strong"><phrase role="var">x</phrase></emphasis> location) as a function of time, with the following two elements:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Amplitude</emphasis></emphasis>: The distance from the center of motion to either extreme<?asciidoc-br?>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Period</emphasis></emphasis>: The amount of time it takes for one complete cycle of motion
</simpara>
</listitem>
</itemizedlist>
<simpara>Looking at the graph of <emphasis role="strong"><emphasis>sine</emphasis></emphasis> (Figure 3.9), we can see that the amplitude is <emphasis role="strong"><emphasis>1</emphasis></emphasis> and the period is <emphasis role="strong"><emphasis>TWO PI</emphasis></emphasis>; the output of sine never rises above 1 or below -1; and every TWO PI radians (or 360 degrees) the wave pattern repeats.</simpara>
<simpara>Now, in the world we live in, the Processing world, what is amplitude and what is period?  Amplitude can be measured rather easily in pixels.   In the case of a window 200 pixels wide, we would oscillate from the center 100 pixels to the right and 100 pixels to the left. Therefore:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Our amplitude is measured in pixels.
float amplitude = 100;</programlisting>
<simpara>Period is the amount of time it takes for one cycle.  What is time in our Processing world?  I mean, certainly we could say we want the circle to oscillate every three seconds.  And we could track the milliseconds—using [function]*millis()*—in Processing and come up with an elaborate algorithm for oscillating an object according to real-world time.   But for us, real-world time doesn’t really matter. The real measure of time in Processing is in frames.  The oscillating motion should repeat every 30 frames, or 50 frames, or 1000 frames, etc.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Our period is measured in frames (our unit of time for animation).
float period = 120;</programlisting>
<simpara>Once we have the amplitude and period, it’s time to write a formula to calculate x as a function of time, which we now know is the current frame count.</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = amplitude * cos(TWO_PI * frameCount / period);</programlisting>
<simpara>Let’s dissect the formula a bit more and try to understand each component.   The first is probably the easiest.   Whatever comes out of the cosine function we multiply by amplitude.   We know that cosine will oscillate between -1 and 1. If we take that value and multiply it by amplitude then we’ll get the desired result: a value oscillating between -amplitude and amplitude.   (Note this is also a place where we could use Processing’s <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function to map the output of cosine to a custom range).</simpara>
<simpara>Now, let’s look at what is inside the cosine function:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">TWO_PI <literal>*</literal> frameCount / period</phrase></emphasis></simpara>
<simpara>What’s going on here?   Let’s start with what we know.  We know that cosine will repeat every 2PI radians—i.e., it will start at 0, repeat at 2PI, 4PI, 6PI, etc.   If the period is 120, then we want the oscillating motion to repeat when the frameCount is at 120 frames, 240 frames, 360 frames, etc.  <emphasis role="strong"><phrase role="var">frameCount</phrase></emphasis> is really the only variable; it starts at 0 and counts upward.   Let’s take a look at what the formula yields at those values:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">frameCount     </entry>
<entry align="left" valign="top">frameCount / period    </entry>
<entry align="left" valign="top">TWO_PI * frameCount / period</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>60</simpara></entry>
<entry align="left" valign="top"><simpara>0.5</simpara></entry>
<entry align="left" valign="top"><simpara>PI</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>TWO_PI</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>240</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>2 * TWO_PI (or 4* PI)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>etc.</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong"><phrase role="var">frameCount</phrase></emphasis> divided by <emphasis role="strong"><phrase role="var">period</phrase></emphasis> tells us how many cycles we’ve completed—are we halfway through the first cycle?  Have we completed two  cycles?  By multiplying that number by TWO_PI, we get the result we want, since TWO_PI is the number of radians required for one cosine (or sine) to complete one cycle.</simpara>
<simpara>Wrapping this all up, here’s the Processing example that oscillates the <emphasis role="strong"><phrase role="var">x</phrase></emphasis> location of a circle with an amplitude of 100 pixels and a period of 120 frames.</simpara>
<simpara id="chapter03_example5"><emphasis role="strong"><phrase role="example">Example 3.5 Simple Harmonic Motion</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
}

void draw() {
  background(255);

  float period = 120;
  float amplitude = 100;
  //[offset-down] Calculating horizontal location according to formula for simple harmonic motion
  float x = amplitude * cos(TWO_PI * frameCount / period);
  stroke(0);
  fill(175);
  translate(width/2,height/2);
  line(0,0,x,0);
  ellipse(x,0,20,20);
}</programlisting>
<simpara>It’s also worth mentioning the term <emphasis role="strong"><emphasis>frequency</emphasis></emphasis>: <emphasis>the number of cycles per time unit.</emphasis>  Frequency is equal to 1 divided by <emphasis role="strong"><phrase role="var">period</phrase></emphasis>.  If the period is 120 frames, then only 1/120th of a cycle is completed in one frame, and so frequency = 1/120.   In the above example, we simply chose to define the rate of oscillation in terms of period and therefore did not need a variable for frequency.</simpara>
<example id="chapter03_exercise6">
<title>Exercise 3.6</title>
<simpara>Create a simulation of a weight (sometimes referred to as a “bob”) hanging from the top of the window by a spring using the sine function.  Use the map() function to calculate the vertical location of the bob.  Later in this chapter, we’ll see how to recreate this same simulation by modeling the forces of a spring according to Hooke’s law.</simpara>
</example>
</section>
<section id="chapter03_section7">
<title>3.7 Oscillation with Angular Velocity</title>
<simpara>Understanding the concepts of oscillation, amplitude, frequency/period is important and often required in the course of simulating “real-world” behaviors.  However, there is a slightly easier way to rewrite the above example with the same result.  Let’s take one more look at our oscillation formula:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = amplitude * cos(TWO_PI * frameCount / period);</programlisting>
<simpara>And let’s rewrite it a slightly different way:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = amplitude * cos ( some value that increments slowly );</programlisting>
<simpara>If we care about precisely defining the period of oscillation in terms of frames of animation, we might need the formula the way we first wrote it, but we can just as easily rewrite our example using the concept of angular velocity (and acceleration) from <link linkend="chapter03_section2">Section 3.2</link>.  Assuming:</simpara>
<programlisting language="java" linenumbering="unnumbered">float angle = 0;
float aVelocity = 0.05;</programlisting>
<simpara>In <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, we can simply say:</simpara>
<programlisting language="java" linenumbering="unnumbered">angle += aVelocity;
float x = amplitude * cos(angle);</programlisting>
<simpara><emphasis role="strong"><phrase role="var">angle</phrase></emphasis> is our “some value that increments slowly.”</simpara>
<simpara id="chapter03_example6"><emphasis role="strong"><phrase role="example">Example 3.6 Simple Harmonic Motion II</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">float angle = 0;
float aVelocity = 0.05;

void setup() {
  size(200,200);
}

void draw() {
  background(255);

  float amplitude = 100;
  float x = amplitude * cos(angle);
  // Using the concept of angular velocity to increment an angle variable
  angle += aVelocity;

  ellipseMode(CENTER);
  stroke(0);
  fill(175);
  translate(width/2,height/2);
  line(0,0,x,0);
  ellipse(x,0,20,20);
}</programlisting>
<simpara>Just because we’re not referencing it directly doesn’t mean that we’ve eliminated the concept of <emphasis role="strong"><phrase role="var">period</phrase></emphasis>.  After all, the greater the angular velocity, the faster the circle will oscillate (therefore lowering the period).   In fact, the number of times it takes to add up the angular velocity to get to TWO_PI is the period or:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">period = TWO_PI / angular velocity</phrase></emphasis></simpara>
<simpara>Let’s expand this example a bit more and create an “Oscillator” class.  And let’s assume we want the oscillation to happen along both the x-axis (as above) and the y-axis.  To do this, we’ll need two angles, two angular velocities, and two amplitudes (one for each axis).   Another perfect opportunity for PVector!</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex07.png" canvas="processingjs/chapter03/_3_07_oscillating_objects/_3_07_oscillating_objects.pde processingjs/chapter03/_3_07_oscillating_objects/Oscillator.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex07.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example7"><emphasis role="strong"><phrase role="example">Example 3.7: Oscillator objects</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Oscillator  {

  // Using a PVector to track two angles!
  PVector angle;
  PVector velocity;
  PVector amplitude;

  Oscillator()  {
    angle = new PVector();
    // Random velocities and amplitudes
    velocity = new PVector(random(-0.05,0.05),random(-0.05,0.05));
    amplitude = new PVector(random(width/2),random(height/2));
  }

  void oscillate()  {
    angle.add(velocity);
  }

  void display()  {
    // Oscillating on the x-axis
    float x = sin(angle.x)*amplitude.x;
    // Oscillating on the y-axis
    float y = sin(angle.y)*amplitude.y;

    pushMatrix();
    translate(width/2,height/2);
    stroke(0);
    fill(175);
    // Drawing the oscillator as a line connecting a circle
    line(0,0,x,y);
    ellipse(x,y,16,16);
    popMatrix();
  }
}</programlisting>
<example id="chapter03_exercise7">
<title>Exercise 3.7</title>
<simpara>Try initializing each Oscillator object with velocities and amplitudes that are not random to create some sort of regular pattern.  Can you make the oscillators appear to be the legs of a insect-like creature?</simpara>
</example>
<example id="chapter03_exercise8">
<title>Exercise 3.8</title>
<simpara>Incorporate angular acceleration into the Oscillator object.</simpara>
</example>
</section>
<section id="chapter03_section8">
<title>3.8 Waves</title>
<simpara>If you’re saying to yourself, “Um, this is all great and everything, but what I really want is to just draw a wave onscreen,” well, then, the time has come.   The thing is, we’re about 90% there.  When we oscillate a single circle up and down according to the sine function, what we are doing is looking at a single point along the x-axis of a wave pattern.  With a little panache and a for loop, we can place a whole bunch of these oscillating circles next to each other.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex09.png" canvas="processingjs/chapter03/_3_09_wave/_3_09_wave.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex09.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This wavy pattern could be used in the design of the body or appendages of a creature, as well as to simulate a soft surface (such as water).</simpara>
<simpara>Here, we’re going to encounter the same questions of amplitude (height of pattern) and period.  Instead of period referring to time, however, since we’re looking at the full wave, we can talk about period as the width (in pixels) of a full wave cycle.    And just as with simple oscillation, we have the option of computing the wave pattern according to a precise period or simply following the model of angular velocity.</simpara>
<simpara>Let’s go with the simpler case, angular velocity.   We know we need to start with an angle, an angular velocity, and an amplitude:</simpara>
<programlisting language="java" linenumbering="unnumbered">float angle = 0;
float angleVel = 0.2;
float amplitude = 100;</programlisting>
<simpara>Then we’re going to loop through all of the <emphasis role="strong"><phrase role="var">x</phrase></emphasis> values where we want to draw a point of the wave.  Let’s say every 24 pixels for now.  In that loop, we’re going to want to do three things:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Calculate the y location according to amplitude and sine of the angle.
</simpara>
</listitem>
<listitem>
<simpara>
Draw a circle at the (x,y) location.
</simpara>
</listitem>
<listitem>
<simpara>
Increment the angle according to angular velocity.
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">  for (int x = 0; x &lt;= width; x += 24) {

    // 1) Calculate the y location according to
    // amplitude and sine of the angle.
    float y = amplitude*sin(angle);

    // 2) Draw a circle at the (x,y) location.
    ellipse(x,y+height/2,48,48);

    // 3) Increment the angle according to angular velocity.
    angle += angleVel;
  }</programlisting>
<simpara>Let’s look at the results with different values for <emphasis role="strong"><phrase role="var">angleVel</phrase></emphasis>:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex09a.png" canvas="processingjs/chapter03/_3_09_wave_a/_3_09_wave_a.pde" classname="three-col" />
  </imageobject>
  <textobject><phrase>angleVel = 0.05</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex09b.png" canvas="processingjs/chapter03/_3_09_wave_b/_3_09_wave_b.pde" classname="three-col" />
  </imageobject>
  <textobject><phrase>angleVel = 0.2</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex09c.png" canvas="processingjs/chapter03/_3_09_wave_c/_3_09_wave_c.pde" classname="three-col" />
  </imageobject>
  <textobject><phrase>angleVel = 0.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice how, although we’re not precisely computing the period of the wave, the higher the angular velocity, the shorter the period.  It’s also worth noting that as the period becomes shorter, it becomes more and more difficult to make out the wave itself as the distance between the individual points increases.  One option we have is to use <emphasis role="strong"><phrase role="function">beginShape()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">endShape()</phrase></emphasis> to connect the points with a line.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex08.png" canvas="processingjs/chapter03/_3_08_static_wave_lines/_3_08_static_wave_lines.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex08.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example8"><emphasis role="strong"><phrase role="example">Example 3.8: Static wave drawn as continuous line</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">float angle = 0;
float angleVel = 0.2;
float amplitude = 100;

size(400,200);
background(255);
smooth();

stroke(0);
strokeWeight(2);
noFill();

beginShape();
for (int x = 0; x &lt;= width; x += 5) {
  // Here’s an example of using the map() function
  // instead.
  float y = map(sin(angle),-1,1,0,height);
  // With beginShape() and endShape() you call
  // vertex() to set all the vertices of your shape.
  vertex(x,y);
  angle +=angleVel;
}
endShape();</programlisting>
<simpara>You may have noticed that the above example is static.  The wave never changes, never undulates.   This additional step is a bit tricky.  Your first instinct might be to say: “Hey, no problem, we’ll just let theta be a global variable and let it increment from one cycle through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> to another.”</simpara>
<simpara>While it’s a nice thought, it doesn’t work.   If you look at the wave, the righthand edge doesn’t match the lefthand; where it ends in one cycle of <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> can’t be where it starts in the next.  Instead, what we need to do is have a variable dedicated entirely to tracking what value of angle the wave should start with.   This angle (which we’ll call <emphasis role="strong"><phrase role="var">startAngle</phrase></emphasis>) increments with its own angular velocity.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex09.png" canvas="processingjs/chapter03/_3_09_wave/_3_09_wave.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex09.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example9"><emphasis role="strong"><phrase role="example">Example 3.9: The Wave</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">float startAngle = 0;
float angleVel = 0.1;

void setup() {
  size(400,200);
}

void draw() {
  background(255);

  startAngle += 0.02;
  // In order to move the wave, we start at a
  // different theta value each frame.
  float angle = startAngle;

  for (int x = 0; x &lt;= width; x += 24) {
    float y = map(sin(angle),-1,1,0,height);
    stroke(0);
    fill(0,50);
    ellipse(x,y,48,48);
    angle += angleVel;
  }
}</programlisting>
<example id="chapter03_exercise9">
<title>Exercise 3.9</title>
<simpara>Try using the Perlin noise function instead of sine or cosine.</simpara>
</example>
<example id="chapter03_exercise10">
<title>Exercise 3.10</title>
<simpara>Encapsulate the above examples into a Wave class and create a sketch that displays two waves (with different amplitudes/periods) as in the screenshot below.  (Move beyond plain circles and lines and try visualizing the wave in a more creative way.)</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_exc10.png" canvas="processingjs/chapter03/Ex_3_10_OOPWave/Ex_3_10_OOPWave.pde processingjs/chapter03/Ex_3_10_OOPWave/Wave.pde" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_exc10.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example id="chapter03_exercise11">
<title>Exercise 3.11</title>
<simpara>More complex waves can be produced by the values of multiple waves together.  Create a sketch that implements this, as in the screenshot below.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_exc11.png" canvas="processingjs/chapter03/Ex_3_11_AdditiveWave/Ex_3_11_AdditiveWave.pde" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_exc11.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter03_section9">
<title>3.9 Trigonometry and Forces: The Pendulum</title>
<simpara>Do you miss Newton’s laws of motion?  I know I sure do.  Well, lucky for you, it’s time to bring it all back home.  After all, it’s been nice learning about triangles and tangents and waves, but the core of this book is really simulating the physics of moving bodies.  Let’s take a look at how trigonometry can help us with this pursuit.</simpara>
<informalfigure id="chapter03_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_10.png" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Figure 3.10</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter03_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_11.png" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Figure 3.11</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>A pendulum is a bob suspended from a pivot.  Obviously a real-world pendulum would live in a 3D space, but we’re going to look at a simpler scenario, a pendulum in a 2D space—a Processing window (see Figure 3.10).</simpara>
<simpara>In Chapter 2, we learned how a force (such as the force of gravity in Figure 3.11) causes an object to accelerate. <emphasis role="strong"><phrase role="mono">F = M <literal>*</literal> A</phrase></emphasis> or <emphasis role="strong"><phrase role="mono">A = F / M</phrase></emphasis>.  In this case, however, the pendulum bob doesn’t simply fall to the ground because it is attached by an arm to the pivot point.  And so, in order to determine its <emphasis>angular</emphasis> acceleration, we not only need to look at the force of gravity, but also the force at the angle of the pendulum’s arm (relative to a pendulum at rest with an angle of zero).</simpara>
<simpara>And this is why we’re here in this chapter.   In the above case, since the pendulum’s arm is of fixed length, the only variable in the scenario is the angle.  We are going to simulate the pendulum’s motion through the use of angular velocity and acceleration.   The angular acceleration will be calculated using Newton’s second law with a little trigonometry twist.</simpara>
<simpara>Let’s zoom in on the right triangle from the pendulum diagram.</simpara>
<informalfigure id="chapter03_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_12.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We can see that the force of the pendulum (<emphasis role="strong"><phrase role="var">F<subscript>p</subscript></phrase></emphasis>) should point perpendicular to the arm of the pendulum in the direction that the pendulum is swinging.  After all, if there were no arm, the bob would just fall straight down.  It’s the tension force of the arm that keeps the bob accelerating towards the pendulum’s rest state. Since the force of gravity (<emphasis role="strong"><phrase role="var">F<subscript>p</subscript></phrase></emphasis>) points downward, by making a right triangle out of these two vectors, we’ve accomplished something quite magnificent.  We’ve made the force of gravity the hypotenuse of a right triangle and separated the vector into two components, one of which represents the force of the pendulum.   Since sine equals opposite over hypotenuse, we have:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">sine(θ) = F<subscript>p</subscript> / F<subscript>g</subscript></phrase></emphasis></simpara>
<simpara>therefore:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">F<subscript>p</subscript> = F<subscript>g</subscript> <literal>*</literal> sine(θ)</phrase></emphasis></simpara>
<simpara>Lest we forget, we’ve been doing all of this with a single question in mind:  What is the angular acceleration of the pendulum?    Once we have the angular acceleration, we’ll be able to apply our rules of motion to find the new angle for the pendulum.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">angular velocity = angular velocity + angular acceleration</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">angle = angle + angular velocity</phrase></emphasis></simpara>
<simpara>The good news is that with Newton’s second law, we know that there is a relationship between force and acceleration, namely F = M * A, or A = F / M.  So if the force of the pendulum is equal to the force of gravity times sine of the angle, then:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">pendudlum angular acceleration = acceleration due to gravity <literal>*</literal> sine (θ)</phrase></emphasis></simpara>
<simpara>This is a good time to remind ourselves that we’re Processing programmers and not physicists.   Yes, we know that the acceleration due to gravity on earth is 9.8 meters per second squared.  But this number isn’t relevant to us.  What we have here is just an arbitrary constant (we’ll call it <emphasis role="strong"><phrase role="var">gravity</phrase></emphasis>), one that we can use to scale the acceleration to something that feels right.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">angular acceleration = gravity <literal>*</literal> sine (θ)</phrase></emphasis></simpara>
<simpara>Amazing.  After all that, the formula is so simple.  You might be wondering, why bother going through the derivation at all?  I mean, learning is great and all, but we could have easily just said: Hey, the angular acceleration of a pendulum is some constant times the sine of the angle.   This is just another moment to remind ourselves that the purpose of the book is not to learn how pendulums swing or gravity works.  The point is to think creatively about how things can move about the screen in an computationally based graphics system.  The pendulum is just a case study.   If you can understand the approach to programming a pendulum, then however you choose to design your onscreen world, you can apply the same techniques.</simpara>
<simpara>Of course, we’re not finished yet.  We may be happy with our simple, elegant formula, but we still have to apply it in code.   This is most definitely a good time to practice our object-oriented programming skills and create a Pendulum class.  Let’s think about all the properties we’ve encountered in our pendulum discussion that the class will need:</simpara>
<itemizedlist>
<listitem>
<simpara>
arm length
</simpara>
</listitem>
<listitem>
<simpara>
angle
</simpara>
</listitem>
<listitem>
<simpara>
angular velocity
</simpara>
</listitem>
<listitem>
<simpara>
angular acceleration
</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered">class Pendulum  {

  // Length of arm
  float r;
  // Pendulum arm angle
  float angle;
  // Angular velocity
  float aVelocity;
  // Angular acceleration
  float aAcceleration;</programlisting>
<simpara>We’ll also need to write a function <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> to update the pendulum’s angle according to our formula&#8230;</simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {
    // Arbitrary constant
    float gravity = 0.4;
    // Calculate acceleration according to our formula.
    aAcceleration = -1 * gravity * sin(angle);
    // Increment velocity
    aVelocity += aAcceleration;
    // Increment angle
    angle += aVelocity;
  }</programlisting>
<informalfigure id="chapter03_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_13.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>&#8230;as well as a function <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> to draw the pendulum in the window, which begs the question: “Um, where do we draw the pendulum?”  We know the angle and the arm length, but how do we know the <emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y</phrase></emphasis> (Cartesian!) coordinates for both the pendulum’s pivot point (let’s call it “origin”) and bob location (let’s call it location)?  This may be getting a little tiring, but the answer, yet again, is trigonometry.</simpara>
<simpara>The origin is just something we make up, as is the arm length.  Let’s say:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector origin = new PVector(100,10);
float r = 125;</programlisting>
<simpara>We’ve got the current angle stored in our variable <emphasis role="strong"><phrase role="var">angle</phrase></emphasis>.   So relative to the origin, the pendulum’s location is a polar coordinate: (r,angle).  And we need it to be Cartesian.  Luckily for us, we just spent some time (Section 3.5) deriving the formula for converting from polar to Cartesian.  And so:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector location = new PVector(r*sin(angle),r*cos(angle));</programlisting>
<simpara>Since the location is relative to wherever the origin happens to be, we can just add origin to the location PVector:</simpara>
<programlisting language="java" linenumbering="unnumbered">location.add(origin);</programlisting>
<simpara>And all that remains is the little matter of drawing a line and ellipse (you should be more creative, of course).</simpara>
<programlisting language="java" linenumbering="unnumbered">stroke(0);
fill(175);
line(origin.x,origin.y,location.x,location.y);
ellipse(location.x,location.y,16,16);</programlisting>
<simpara>Before we put everything together, there’s one last little detail I neglected to mention.  Let’s think about the pendulum arm for a moment.  Is it a metal rod?  A string?  A rubber band?  How is it attached to the pivot point?  How long is it?  What is its mass?  Is it a windy day?  There are a lot of questions that we could continue to ask that would affect the simulation.  We’re living, of course, in a fantasy world, one where the pendulum’s arm is some idealized rod that never bends and the mass of the bob is concentrated in a single, infinitesimally small point.   Nevertheless, even though we don’t want to worry ourselves with all of the questions, we should add one more variable to our calculation of angular acceleration.   To keep things simple, in our derivation of the pendulum’s acceleration, we assumed that the length of the pendulum’s arm is 1.   In fact, the length of the pendulum’s arm affects the acceleration greatly: the longer the arm, the slower the acceleration.  To simulate a pendulum more accurately, we divide by that length, in this case <emphasis role="strong"><phrase role="var">r</phrase></emphasis>.  (For a more involved explanation, visit: <ulink url="http://calculuslab.deltacollege.edu/ODE/7-A-2/7-A-2-h.html">The Simple Pendulum</ulink>.)</simpara>
<programlisting language="java" linenumbering="unnumbered">aAcceleration = (-1 * G * sin(angle)) / r;</programlisting>
<simpara>Finally, a real-world pendulum is going to experience some amount of friction (at the pivot point) and air resistance.   With our code as is, the pendulum would swing forever, so to make it more realistic we can use a “damping” trick.  I say “trick” because rather than model the resistance forces with some degree of accuracy (as we did in Chapter 2), we can achieve a similar result by simply reducing the angular velocity during each cycle.  The following code reduces the velocity by 1% (or multiplies it by 99%) during each frame of animation:</simpara>
<programlisting language="java" linenumbering="unnumbered">aVelocity *= 0.99;</programlisting>
<simpara>Putting everything together, we have the following example (with the pendulum beginning at a 45-degree angle).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex10.png" canvas="processingjs/chapter03/_3_10_PendulumExample/_3_10_PendulumExample.pde processingjs/chapter03/_3_10_PendulumExample/Pendulum.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex10.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example10"><emphasis role="strong"><phrase role="example">Example 3.10: Swinging Pendulum</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">Pendulum p;

void setup() {
  size(200,200);
  smooth();
  // We make a new Pendulum object with
  // an origin location and arm length
  p = new Pendulum(new PVector(width/2,10),125);
}

void draw() {
  background(255);
  p.go();
}

class Pendulum  {
  // Many many variables to keep track of the pendulum’s various properties
  PVector location;    // Location of pendulum ball
  PVector origin;      // Location of arm origin
  float r;             // Length of arm
  float angle;         // Pendulum arm angle
  float aVelocity;     // Angle velocity
  float aAcceleration; // Angle acceleration
  float damping;       // Arbitrary damping amount

  Pendulum(PVector origin_, float r_) {
    origin = origin_.get();
    location = new PVector();
    r = r_;
    angle = PI/4;

    aVelocity = 0.0;
    aAcceleration = 0.0;
    // An arbitrary damping so that the pendulum slows
    // over time.
    damping = 0.995;
  }

  void go() {
    update();
    display();
  }

  void update() {
    float gravity = 0.4;
    // Formula we worked out for angular acceleration
    aAcceleration = (-1 * gravity / r) * sin(angle);


    // Standard angular motion algorithm
    aVelocity += aAcceleration;
    angle += aVelocity;

    // Apply some damping.
    aVelocity *= damping;
  }

  void display() {
    // Where is the bob relative to the origin?
    // Polar to Cartesian coordinates will tell us!
    location.set(r*sin(angle),r*cos(angle),0);
    location.add(origin);

    stroke(0);
    // The arm
    line(origin.x,origin.y,location.x,location.y);
    fill(175);
    // The bob
    ellipse(location.x,location.y,16,16);
  }
}</programlisting>
<simpara><emphasis>(Note that the version of the example posted on the web site has additional code to allow the user to grab the pendulum and swing it with the mouse.)</emphasis></simpara>
<example id="chapter03_exercise12">
<title>Exercise 3.12</title>
<simpara>String together a series of pendulums so that the endpoint of one is the origin point of another.  (Note that doing this may produce intriguing results but will be wildly inaccurate physically.  Simulating an actual double pendulum involves sophisticated equations, which you can read about here: <ulink url="http://scienceworld.wolfram.com/physics/DoublePendulum.html">http://scienceworld.wolfram.com/physics/DoublePendulum.html</ulink>).</simpara>
</example>
<example id="chapter03_exercise13">
<title>Exercise 3.13</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_exc13.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_exc13.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Using trigonometry, what is the magnitude of the “normal” force in the illustration on the right (the force perpendicular to the incline on which the sled rests)?   Note that, as indicated, the “normal” force is a component of the force of gravity.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/blank.png" />
  </imageobject>
  <textobject><phrase>imgs/blank.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example id="chapter03_exercise14">
<title>Exercise 3.14</title>
<simpara>Exercise part 2:  Create an example that simulates the box sliding down the incline with friction.  Note that the magnitude of the friction force is equal to the normal force.</simpara>
</example>
</section>
<section id="chapter03_section10">
<title>3.10 Spring Forces</title>
<informalfigure id="chapter03_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_14.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.14</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In <link linkend="chapter03_section6">Section 3.6</link>, we looked at modeling simple harmonic motion by mapping the sine wave to a pixel range. <link linkend="chapter03_exercise6">Exercise 3.6</link> asked you to use this technique to create a simulation of a spring hanging from a bob.  While using the <emphasis role="strong"><phrase role="function">sin()</phrase></emphasis> function is a quick-and-dirty, one-line-of-code way of getting something up and running, it won’t do if what we really want is to have a bob hanging from a spring in a two-dimensional space that responds to other forces in the environment (wind, gravity, etc.)  To accomplish a simulation like this (one that is identical to the pendulum example, only now the arm is a springy connection), we need to model the forces of a spring using PVector.</simpara>
<simpara>The force of a spring is calculated according to Hooke’s law, named for Robert Hooke, a British physicist who developed the formula in 1660.  Hooke originally stated the law in Latin:  “Ut tensio, sic vis” or “As the extension, so the force” <emphasis role="strong"><phrase role="notetoself">[Cite wikipedia?]</phrase></emphasis>.    Let’s think of it this way:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">The force of the spring is directly proportional to the extension of the spring.</phrase></emphasis></simpara>
<informalfigure id="chapter03_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_15.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 3.15: x = current length - rest length</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In other words, if you pull on the bob a lot, the force will be strong; if you pull on the bob a little, the force will be weak.  Mathematically, the law is stated as follows:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">F<subscript>spring</subscript> = - k <literal>*</literal> x</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">k</phrase></emphasis> is constant and its value will ultimately scale the force.  Is the spring highly elastic or quite rigid?
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">x</phrase></emphasis> refers to the displacement of the spring, i.e. the difference between the current length and the rest length.  The rest length is defined as the length of the spring in a state of equilibrium.
</simpara>
</listitem>
</itemizedlist>
<simpara>Now remember, force is a vector, so we need to calculate both magnitude and direction.  Let’s look at one more diagram of the spring and label all the givens we might have in a Processing sketch.</simpara>
<informalfigure id="chapter03_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_16.png" />
  </imageobject>
  <textobject><phrase>Figure 3.16</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s establish the following three variables as shown in Figure 3.16.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector anchor;
PVector location;
float restLength;</programlisting>
<simpara>First, let’s use Hooke’s law to calculate the magnitude of the force.  We need to know <emphasis role="strong"><phrase role="var">k</phrase></emphasis> and <emphasis role="strong"><phrase role="var">x</phrase></emphasis>.  <emphasis role="strong"><phrase role="var">k</phrase></emphasis> is easy; it’s just a constant, so let’s make something up.</simpara>
<programlisting language="java" linenumbering="unnumbered">float k = 0.1;</programlisting>
<simpara><emphasis role="strong"><phrase role="var">x</phrase></emphasis> is perhaps a bit more difficult.  We need to know the “difference between the current length and the rest length.”  The rest length is defined as the variable “restLength.”  What’s the current length?  The distance between the anchor and the bob.  And how can we calculate that distance?    How about the magnitude of a vector that points from the anchor to the bob?  (Note this is exactly the same process we employed when calculating distance in Example 2.9: gravitational attraction.)</simpara>
<programlisting language="java" linenumbering="unnumbered">// A vector pointing from anchor to bob
// gives us the current length of the spring.
PVector dir = PVector.sub(bob,anchor);
float currentLength = dir.mag();
float x = restLength - currentLength;</programlisting>
<simpara>Now that we’ve sorted out the elements necessary for the magnitude of the force (<emphasis role="strong"><emphasis>-1</emphasis></emphasis> * <emphasis role="strong"><phrase role="var">k</phrase></emphasis> * <emphasis role="strong"><phrase role="var">x</phrase></emphasis>), we need to figure out the direction, a unit vector pointing in the direction of the force.  The good news is that we already have this vector.  Right?  Just a moment ago we thought to ourselves: “How we can calculate that distance?  How about the magnitude of a vector that points from the anchor to the bob?”  Well, that is the direction of the force—it’s a vector that points from the anchor to the bob!</simpara>
<informalfigure id="chapter03_figure17">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_17.png" />
  </imageobject>
  <textobject><phrase>Figure 3.17</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In Figure 3.17, we can see that if we stretch the spring beyond its rest length, there should be a force pulling it back towards the anchor.  And if it shrinks below its rest length, the force should push it away from the anchor.   This reversal of direction is accounted for in the formula with the -1.  And so all we need is to normalize the PVector we used for the distance calculation!  Let’s take a look at the code, and rename that PVector variable to “force.”</simpara>
<programlisting language="java" linenumbering="unnumbered">// Magnitude of spring force according to Hooke’s law
float k = 0.1;
PVector force = PVector.sub(bob,anchor);
float currentLength = dir.mag();
float x = restLength - currentLength;

// Direction of spring force (unit vector)
force.normalize();

// Putting it together: direction and magnitude!
force.mult(-1 * k * x);</programlisting>
<simpara>Now that we have the algorithm worked out for computing the spring force vector, the question remains: what object-oriented programming structure should we use?   This, again, is one of those situations where there is no “correct” answer.  There are several possibilities; which one we choose depends on the program’s goals and one’s own personal coding style.   Still, since we’ve been working all along with a Mover class, let’s keep going with this same framework.  Let’s think of our Mover class as the spring’s “bob.”  The bob needs <emphasis role="strong"><phrase role="var">location</phrase></emphasis>, <emphasis role="strong"><phrase role="var">velocity</phrase></emphasis>, and <emphasis role="strong"><phrase role="var">acceleration</phrase></emphasis> vectors to move about the screen.  Perfect—we’ve got that already!  And perhaps the bob experiences a gravity force via the <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.  Just one more step—we need to apply the spring force:</simpara>
<programlisting language="java" linenumbering="unnumbered">Bob bob;

void setup() {
  bob = new Bob();
}

void draw()  {
  // Our Chapter 2 “make-up-a-gravity force”
  PVector gravity = new PVector(0,1);
  bob.applyForce(gravity);
  // We need to also calculate and apply a spring force!
  PVector springForce = _______________????  // [bold]
  bob.applyForce(spring); // [bold]

  // Our standard update() and display() functions
  bob.update();
  bob.display();
}</programlisting>
<informalfigure id="chapter03_figure18">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_18.png" />
  </imageobject>
  <textobject><phrase>Figure 3.18</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>One option would be to write out all of the spring force code in the main <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop.  But thinking ahead to when you might have multiple bobs and multiple spring connections, it makes a good deal of sense to write an additional class, a Spring class.  As shwon in Figure 3.18, the Bob object keeps track of the movements of the Bob; the Spring class keeps track of the Spring’s anchor and its rest length and calculates the Spring force on the Bob.</simpara>
<simpara>This allows us to write a lovely main program as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">Bob bob;
// Adding a Spring object
Spring spring;  // [bold]

void setup() {
  bob = new Bob();
  spring = new Spring();
}

void draw()  {
  PVector gravity = new PVector(0,1);
  bob.applyForce(gravity);

  // This new function in the Spring class will take care of
  // computing the force of the spring on the bob.
  spring.connect(bob); // [bold]

  bob.update();
  bob.display();
  spring.display();
}</programlisting>
<simpara>You may notice here that this is quite similar to what we did in <link linkend="chapter02_example6">Example 2.6</link>, the Attractor.   There, we said something like:</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector force = attractor.attract(mover);
  mover.applyForce(force);</programlisting>
<simpara>The analogous situation here with a spring would be:</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector force = spring.connect(bob);
  bob.applyForce(force);</programlisting>
<simpara>Nevertheless, in this example all we said was:</simpara>
<programlisting language="java" linenumbering="unnumbered">  spring.connect(bob);</programlisting>
<simpara>What gives?   Why don’t we need to call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> on the bob?  The answer is, of course, that we do need to call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> on the bob.  Only instead of doing it in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, we’re just demonstrating that a perfectly reasonable (and sometimes preferable) alternative is to ask the <emphasis role="strong"><phrase role="function">connect()</phrase></emphasis> function to internally handle calling <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> on the bob:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void connect(Bob b) {
    PVector force = some fancy calculations

    // The function connect() takes care of calling applyForce
    // and therefore doesn’t have to return a vector to the calling
    // area.
    b.applyForce(force);
  }</programlisting>
<simpara>Why do it one way with the Attractor and another way with the Spring?    When we were first learning about forces, it was a bit clearer to show all the forces being applied in the main <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop, and hopefully this helped you learn about force accumulation.  Now that we’re more comfortable with that, perhaps it’s simpler to embed some of the details inside the objects themselves.</simpara>
<simpara>Let’s take a look at the rest of the elements in the Spring class.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter03/ch03_ex11.png" canvas="processingjs/chapter03/_3_11_spring/_3_11_spring.pde processingjs/chapter03/_3_11_spring/Mover.pde processingjs/chapter03/_3_11_spring/Spring.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter03/ch03_ex11.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter03_example11"><emphasis role="strong"><phrase role="example">Example 3.11: A Spring connection</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Spring {

  // We need to keep track of the spring’s anchor location.
  PVector anchor;

  // Rest length and spring constant variables
  float len;
  float k = 0.1;

  //[full] The constructor initializes the anchor point and rest length.
  Spring(float x, float y, int l) {
    anchor = new PVector(x,y);
    len = l;
  }
  /[end]

  // Calculate spring force
  // Our implementation of Hooke’s Law.
  void connect(Bob b) {

    // Get a vector pointing from anchor to Bob location.
    PVector force = PVector.sub(b.location,anchor); // [bold]
    float d = force.mag(); // [bold]
    // Calculate the displacement between
    // distance and rest length.
    float stretch = d - len; // [bold]

    // Direction and magnitude together!
    force.normalize(); // [bold]
    force.mult(-1 * k * stretch); // [bold]

    // Call applyForce() right here!
    b.applyForce(force);
  }

  //[full] Draw the anchor.
  void display() {
    fill(100);
    rectMode(CENTER);
    rect(anchor.x,anchor.y,10,10);
  }
  //[end]

  //[full] Draw the spring connection between Bob location and anchor.
  void displayLine(Bob b) {
    stroke(255);
    line(b.location.x,b.location.y,anchor.x,anchor.y);
  }
  //[end]

}</programlisting>
<simpara>The full code for this example is included on the book web site, and the web version also incorporates two additional features: (1) Bob includes functions for mouse interactivity so that it can be dragged around the window.  (2) The Spring object includes a function to constrain the connection’s length between a minimum and a maximum.</simpara>
<example id="chapter03_exercise15">
<title>Exercise 3.15</title>
<simpara>Exercise: Before running to see the example online, take a look at this constrain function and see if you can fill in the blanks.</simpara>
<programlisting language="java" linenumbering="unnumbered">void constrainLength(Bob b, float minlen, float maxlen) {
  // Vector pointing from Bob to Anchor
  PVector dir = PVector.sub(______,______);
  float d = dir.mag();

  // Is it too short?
  if (d &lt; minlen) {
    dir.normalize();
    dir.mult(________);
    // Keep location within constraint
    b.location = PVector.add(______,______);
    b.velocity.mult(0);
  // Is it too long?
  } else if (____________) {
    dir.normalize();
    dir.mult(_________);
    // Keep location within constraint
    b.location = PVector.add(______,______);
    b.velocity.mult(0);
  }
}</programlisting>
</example>
<example id="chapter03_exercise16">
<title>Exercise 3.16</title>
<simpara>Exercise: Create a system of multiple bobs and spring connections.  How would you have a Bob connected to a Bob with no fixed anchor?</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 3 Exercise:</simpara>
<simpara>Take one of your creatures and incorporate oscillation into its motion.   You can use the Oscillator class from Example 3.x as a model.  The Oscillator object, however, oscillates around a single point (the middle of the window).   Try oscillating around a moving point.   In other words, design a creature that moves around the screen according to location, velocity, and acceleration.  But that creature isn’t just a static shape, it’s an oscillating body.  Consider tying the speed of oscillation to the speed of motion.  Think of a butterfly’s flapping wings or the legs of an insect.  Can you make it appear that the creature’s internal mechanics (oscillation) drive its locomotion?   For a sample, check out the “AttractionArrayWithOscillation” example with the code download.</simpara>
</tip>
</section>
</chapter>
<chapter id="_chapter_4_particle_systems">
<title>Chapter 4.  Particle Systems</title>
<blockquote>
<attribution>
Spock
</attribution>
<simpara>“That is wise. Were I to invoke logic, however, logic clearly dictates that the needs of the many outweigh the needs of the few.”</simpara>
</blockquote>
<simpara>In 1982, William T. Reeves, a researcher at Lucasfilm Ltd., was working on the film “Star Trek II: The Wrath of Khan.”   Much of the movie revolves around the Genesis Device, a torpedo that when shot at a barren, lifeless planet has the ability to reorganize matter and create a habitable world for colonization. During the sequence, a wall of fire ripples over the planet while it is being “terraformed.”   The term “particle system,” an incredibly common and useful technique in computer graphics, was coined in the creation of this particular effect.</simpara>
<simpara><emphasis>“A particle system is a collection of many many minute particles that together represent a fuzzy object. Over a period of time, particles are generated into a system, move and change from within the system, and die from the system.”</emphasis>
—William Reeves, “Particle Systems—a Technique for Modeling a Class of Fuzzy Objects,” <emphasis>ACM Transactions on Graphics</emphasis> 2:2 (April 1983), p. 92.</simpara>
<simpara>Since the early 1980s, particle systems have been used in countless video games, animations, digital art pieces, and installations to model various irregular types of natural phenomena, such as fire, smoke, waterfalls, fog, grass, bubbles, and so on.</simpara>
<simpara>This chapter will be dedicated to looking at implementation strategies for coding a particle system. How do we organize our code? Where do we store information related to individual particles vs. information related to the system as a whole?  The examples we’ll look at focus on managing the data associated with a particle system. The examples will use simple shapes for the particles and apply only the most basic behaviors (gravity, etc.). However, by using this framework and building in more interesting ways to render the particles and compute behaviors, you can achieve a variety of effects.</simpara>
<section id="chapter04_section1">
<title>4.1 Why We Need Particle Systems</title>
<simpara>We’ve defined a particle system to be a collection of independent objects, often represented by a simple shape or dot.  Why does this matter?    Certainly, the prospect of modeling some of the phenomena we listed (explosions!) is attractive and potentially useful.  But really, there’s an even better reason for us to concern ourselves with particle systems.  If we want to get anywhere in this nature of code life, we’re going to need to work with systems of <emphasis>many</emphasis> things.   We’re going to want to look at balls bouncing, birds flocking, ecosystems evolving, all sorts of things in plural.</simpara>
<simpara>Just about every chapter after this one is going to need to deal with a list of objects.  Yes, we’ve done this with an array in some of our first vector and forces examples.   But we need to go where no array has gone before.</simpara>
<simpara>First, we’re going to want to deal with flexible quantities of elements.  Sometimes we’ll have zero things, sometimes one thing, sometimes ten things, and sometimes ten thousand things. Second, we’re going to want to take a more sophisticated object-oriented approach.  Instead of simply writing a class to describe a single Particle, we’re also going to want to write a class that describes the collection of particles, the Particle System itself.   The goal here is to be able to write a main program that looks like the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Ah, isn’t this main program so simple and lovely?
ParticleSystem ps;

void setup() {
  size(200,200);
  ps = new ParticleSystem();
}

void draw() {
  background(255);
  ps.run();
}</programlisting>
<simpara>No single Particle is ever referenced in the above code, yet the result will be full of particles flying all over the screen.   Getting used to writing Processing sketches with multiple classes, and classes that keep lists of instances of other classes, will prove very useful as we get to more advanced chapters in this book.</simpara>
<simpara>Finally, working with Particle Systems is also a good excuse for us to tackle two other advanced object-oriented programming techniques: inheritance and polymorphism.   With the examples we’ve seen up until now, we’ve always had an array of a single type of object: “Movers” or “Oscillators.”  With inheritance (and polymorphism), we’ll see a convenient way to store a single list that contains objects of different types.  This way, a Particle System need not only be a system of a single type of particle.</simpara>
<simpara>Though it may seem obvious to you, I’d also like to point out that there are typical implementations of particle systems, and that’s where we will begin in this chapter.   However, the fact that the particles in this chapter look or behave a certain way should not limit your imagination.   Just because particle systems tend to look sparkly, fly forward, and fall with gravity doesn’t mean that’s how you should make yours.</simpara>
<simpara>The focus here is really just how to keep track of a system of many elements.  What those elements do and how those elements look is up to you.</simpara>
</section>
<section id="chapter04_section2">
<title>4.2 A Single Particle</title>
<simpara>Before we can get rolling on the system itself, we’ve got to work on writing the class to describe a single particle.  The good news: we’ve done this already.    Our <emphasis role="strong"><phrase role="klass">Mover</phrase></emphasis> class from Chapter 2 serves as the perfect template.  For us, a particle is an independent body that moves about the screen.  It has <emphasis role="strong"><phrase role="var">location</phrase></emphasis>, <emphasis role="strong"><phrase role="var">velocity</phrase></emphasis>, and <emphasis role="strong"><phrase role="var">acceleration</phrase></emphasis>, a constructor to initialize those variables, and functions to <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> itself and <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> its location.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  // A “Particle” object is just another name for our “Mover.”
  // It has location, velocity, and acceleration.
  PVector location;
  PVector velocity;
  PVector acceleration;

  Particle(PVector l) {
    location = l.get();
    acceleration = new PVector();
    velocity = new PVector();
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,8,8);
  }
}</programlisting>
<simpara>This is about as simple as a particle can get.  From here, we could take our particle in several directions.  We could add an <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function to affect the particle’s behavior (we’ll do precisely this in a future example.)  We could add variables to describe color and shape, or reference a <emphasis role="strong"><phrase role="klass">PImage</phrase></emphasis> to draw the particle.   For now, however, let’s focus on adding just one additional detail: <emphasis role="strong"><emphasis>lifespan</emphasis></emphasis>.</simpara>
<simpara>Typical particle systems involve something called an <emphasis role="strong"><emphasis>emitter</emphasis></emphasis>.  The emitter is the source of the particles and controls the initial settings for the particles, location, velocity, etc.  An emitter might emit a single burst of particles, or a continuous stream of particles, or both.  The point is that for a typical implementation such as this, a particle is born at the emitter but does not live forever.  If it were to live forever, our Processing sketch would eventually grind to a halt as the number of particles increases to an unwieldy number over time.   As new particles are born, we need old particles to die.  This creates the illusion of an infinite stream of particles, and the performance of our program does not suffer.   There are many different ways we could decide when a particle dies.  For example, it could come into contact with another object, or it could simply leave the screen.   For our first Particle class, however, we’re simply going to add a “lifespan” variable.   The timer will start at 255 and count down to 0, when the particle will be considered “dead.”  And so we expand the Particle class as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // A new variable to keep track of how long the particle
  // has been “alive”
  float lifespan; // [bold]

  Particle(PVector l) {
    location = l.get();
    acceleration = new PVector();
    velocity = new PVector();
    // We start at 255 and count down for convenience
    lifespan = 255; // [bold]
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    // Lifespan decreases
    lifespan -= 2.0; // [bold]
  }

  void display() {
    // Since our life ranges from 255 to 0 we can use it for alpha
    stroke(0,lifespan); // [bold]
    fill(175,lifespan); // [bold]
    ellipse(location.x,location.y,8,8);
  }
}</programlisting>
<simpara>The reason we chose to start the lifespan at 255 and count down to 0 is for convenience.  With those values, we can assign lifespan to act as the alpha transparency for the ellipse as well.   When the particle is “dead” it will also have faded away onscreen.</simpara>
<simpara>With the addition of the lifespan variable, we’ll also need one additional function —a function that can be queried (for a true or false answer) as to whether the particle is alive or dead.  This will come in handy when we are writing the ParticleSystem class, whose task will be to manage the list of particles themselves.  Writing this function is pretty easy; we just need to check and see if the value of lifespan is less than zero.  If it is we <emphasis>return true</emphasis>, if not we <emphasis>return false</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  boolean isDead() {
    if (lifespan &lt; 0.0) {
      // Is the particle still alive?
      return true;
    } else {
      return false;
    }
  }</programlisting>
<simpara>Before we get to the next step of making many particles, it’s worth taking a moment to make sure our Particle works correctly and create a sketch with one single Particle object.  Here is the full code below, with two small additions.  We add a convenience function called <emphasis role="strong"><phrase role="function">run()</phrase></emphasis> that simply calls both <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> for us.  In addition, we give the Particle a random initial velocity as well as a downward acceleration (to simulate gravity).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex01.png" canvas="processingjs/chapter04/_4_01_SingleParticle/_4_01_SingleParticle.pde processingjs/chapter04/_4_01_SingleParticle/Particle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter04_example1"><emphasis role="strong"><phrase role="example">Example 4.1: A single particle</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">Particle p;

void setup() {
  size(200,200);
  p = new Particle(new PVector(width/2,10));
  smooth();
}

void draw() {
  background(255);
  // Operating the single Particle
  p.run();
  if (p.isDead()) {
    println("Particle dead!");
  }
}

class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  Particle(PVector l) {
    //[offset-up] For demonstration purposes we assign the Particle an initial velocity and constant acceleration.
    acceleration = new PVector(0,0.05);
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
    lifespan = 255.0;
  }

  // Sometimes it’s convenient to have a “run”
  // function that calls all the other functions we need.
  void run() {
    update();
    display();
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    lifespan -= 2.0;
  }

  void display() {
    stroke(0,lifespan);
    fill(0,lifespan);
    ellipse(location.x,location.y,8,8);
  }

  // Is the Particle alive or dead?
  boolean isDead() {
    if (lifespan &lt; 0.0) {
      return true;
    } else {
      return false;
    }
  }
}</programlisting>
<example id="chapter04_exercise1">
<title>Exercise 4.1</title>
<simpara>Rewrite the example so that the Particle can respond to force vectors via an applyForce() function.</simpara>
</example>
<example id="chapter04_exercise2">
<title>Exercise 4.2</title>
<simpara>Add angular velocity (rotation) to the Particle.  Create your own non-circle Particle design.</simpara>
</example>
<simpara>Now that we have a class to describe a single Particle, we’re ready for the next big step.  How do we keep track of many particles, when we can’t ensure exactly how many particles we might have at any given time?</simpara>
</section>
<section id="chapter04_section3">
<title>4.3 The ArrayList</title>
<simpara>In truth, we could use a simple array to manage our Particle objects.  Some particle systems might have a fixed number of particles, and arrays are magnificently efficient in those instances.  Processing also offers <emphasis role="strong"><phrase role="function">expand()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">contract()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">subset()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">splice()</phrase></emphasis>, and other methods for resizing arrays.   However, for these examples, we’re going to take a more sophisticated approach and use the Java class ArrayList (found in the java.util package: <ulink url="http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html">ArrayList Documentation</ulink>).  Using an ArrayList is conceptually similar to a standard array, but the syntax is different. Here is some code (that assumes the existence of a generic Particle class) demonstrating identical results: first with an array, and second with an ArrayList.</simpara>
<simpara>The standard Array way:</simpara>
<programlisting language="java" linenumbering="unnumbered">int total = 10;
Particle[] parray = new Particle[total];

void setup() {
  // This is what we’re used to, accessing elements on
  // the array via an index and brackets—[]
  for (int i = 0; i &lt; parray.length; i++) {
    parray[i] = new Particle();
  }
}

void draw() {
  for (int i = 0; i &lt; parray.length; i++) {
    Particle p = parray[i];
    p.run();
  }
}</programlisting>
<simpara>The new ArrayList way (using Generics!):</simpara>
<programlisting language="java" linenumbering="unnumbered">int total = 10;

//[offset-down] Have you ever seen this syntax before? This is a new feature in Java 1.6 that Processing now supports. It allows us to specify in advance what type of object we intend to put in the ArrayList.
ArrayList&lt;Particle&gt; plist = new ArrayList&lt;Particle&gt;();
void setup() {
  for (int i = 0; i &lt; total; i++) {
    // An object is added to an ArrayList with add().
    plist.add(new Particle());
  }
}

void draw() {
  // The size of the ArrayList is returned by size().
  for (int i = 0; i &lt; plist.size(); i++) {
    // An object is accessed from the ArrayList with
    // get().  Because we are using “Generics,” we do not
    // need to specify a type when we pull objects out of
    // the ArrayList.
    Particle p = plist.get(i);
    p.run();
  }
}</programlisting>
<simpara>This last for loop looks pretty similar to our code that looped through a “regular” array.  We initialize a variable called “i” to 0 and count up by 1, accessing each element of the ArrayList until we get to the end.    However, if you use generics, i.e.</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;Particle&gt; plist = new ArrayList&lt;Particle&gt;();</programlisting>
<simpara>you can write something called an “enhanced for loop.”  It looks like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">for (Particle p: particles) {
  p.run();
}</programlisting>
<simpara>Let’s translate that.  Say “for each” instead of “for” and say “in” instead of “:”.  Now you have:</simpara>
<simpara>“For each Particle p in particles, run that Particle p!”</simpara>
<simpara>I know.  You cannot contain your excitement.  I can’t.  I know it’s not necessary, but I just have to type that again.</simpara>
<programlisting language="java" linenumbering="unnumbered">// This enhanced loop also works for regular arrays!
for (Particle p : particles) {
  p.run();
}</programlisting>
<simpara>Simple, elegant, concise, lovely.   Take a moment.   Breathe.   I have some bad news.  Yes, we love that enhanced loop and we will get to use it.  But not right now.  Our particle system examples will require a feature that makes using that loop impossible.  Let’s continue.</simpara>
<simpara>The code we’ve written above doesn’t take advantage of the ArrayList’s resizability, and it uses a fixed size of 10.   We need to design an example that fits with our particle system scenario, where we emit a continuous stream of Particle objects, adding one new particle with each cycle through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.   We’ll skip rehashing the Particle class code here, as it doesn’t need to change.</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;Particle&gt; particles;

void setup() {
  size(200,200);
  particles = new ArrayList&lt;Particle&gt;();
}

void draw() {
  background(255);

  //[offset-up] A new Particle object is added to the ArrayList every cycle through draw().
  particles.add(new Particle(new PVector(width/2,50)));

  for (int i = 0; i &lt; particles.size(); i++) {
    Particle p = particles.get(i);
    p.run();
  }
}</programlisting>
<simpara>Run the above code for a few minutes and you’ll start to see the frame rate slow down and down and down until the program grinds to a halt (my tests yielded horrific performance after fifteen minutes.)  The issue of course is that we are creating more and more and more particles without removing any.</simpara>
<simpara>Fortunately, the <emphasis role="strong"><phrase role="klass">ArrayList</phrase></emphasis> class has a convenient <emphasis role="strong"><phrase role="function">remove()</phrase></emphasis> function that allows us to delete a Particle (by referencing its index).    This is why we cannot use the new enhanced for loop we just learned; the enhanced loop provides no means for deleting elements while iterating.  Here, we want to call <emphasis role="strong"><phrase role="function">remove()</phrase></emphasis> when the Particle’s <emphasis role="strong"><phrase role="function">isDead()</phrase></emphasis> function returns true.</simpara>
<programlisting language="java" linenumbering="unnumbered">  for (int i = 0; i &lt; particles.size(); i++) {
    Particle p = particles.get(i);
    p.run();
    // If the Particle is “dead” we can go ahead and delete it from
    // the list.
    if (p.isDead()) {
      particles.remove(i);
    }
  }</programlisting>
<simpara>Although the above code will run just fine (and the program will never grind to a halt), we have opened up a medium-sized can of worms.  Whenever we manipulate the contents of a list while iterating through that very list, we can get ourselves into trouble.    Take, for example, the following code.</simpara>
<programlisting language="java" linenumbering="unnumbered">  for (int i = 0; i &lt; particles.size(); i++) {
    Particle p = particles.get(i);
    p.run();
    //[offset-up] Adding a new Particle to the list while iterating?
    particles.add(new Particle(new PVector(width/2,50)));
  }</programlisting>
<simpara>This is a somewhat extreme example (with flawed logic), but it proves the point.  In the above case, for each Particle in the list, we add a new Particle to the list (manipulating the <emphasis role="strong"><phrase role="function">size()</phrase></emphasis> of the ArrayList).  This will result in an infinite loop as i can never increment past the size of the ArrayList.</simpara>
<simpara>While removing elements from the ArrayList during a loop doesn’t cause the program to crash (as it does with adding), the problem is almost more insidious in that it leaves no evidence.  To discover the problem we must first establish an important fact.  When an object is removed from the ArrayList, all elements are shifted one spot to the left.  Note the diagram below where Particle “C” (index 2) is removed.  Particles A and B keep the same index, while Particles D and E shift from 3 and 4 to 2 and 3, respectively.</simpara>
<informalfigure id="chapter04_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_01.png" />
  </imageobject>
  <textobject><phrase>Figure 4.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s pretend we are <emphasis role="strong"><phrase role="var">i</phrase></emphasis> looping through the ArrayList.</simpara>
<simpara><emphasis>when i = 0 &#8594; Check Particle A &#8594; Do not delete</emphasis><?asciidoc-br?>
<emphasis>when i = 1 &#8594; Check Particle B -&#8594; Do not delete</emphasis><?asciidoc-br?>
<emphasis>when i = 2 &#8594; Check Particle C &#8594; Delete!  Slide Particles D and E back from slots 3,4 to 2,3</emphasis><?asciidoc-br?>
<emphasis>when i = 3 &#8594; Check Particle E &#8594; Do not delete</emphasis></simpara>
<simpara>Notice the problem?  We never checked Particle D!  When C was deleted from slot #2, D moved into slot #2, but i already moved on to equal 3.  This is not a disaster given that the next time around, Particle D will get checked. Still, the expectation is that we are writing code to iterate through every single element of the ArrayList.   Skipping an element is unacceptable.</simpara>
<simpara>There are two solutions to this problem.   The first solution is to simply iterate through the ArrayList backwards.  If you are sliding elements from right to left as elements are removed, it’s impossible to skip an element by accident.  Here’s how the code would look:</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Looping through the list backwards
  for (int i = particles.size()-1; i &gt;= 0; i--) { // [bold]
    Particle p = (Particle) particles.get(i);
    p.run();
    if (p.isDead()) {
      particles.remove(i);
    }
  }</programlisting>
<simpara>This is a perfectly fine solution in ninety-nine cases out of a hundred.  But sometimes, the order in which the elements are drawn could be important and you may not want to iterate backwards.  Java provides a special class—[klass]*Iterator*—that takes care of all of the details of iteration for you.  You get to say:</simpara>
<simpara><emphasis>Hey, I’d like to iterate through this ArrayList.  Could you continue to give me the next element in the list one at a time until we get to the end?  And if I remove elements or move them around in the list while we’re iterating, will you make sure I don’t look at any elements twice or skip any by accident?</emphasis></simpara>
<simpara>An ArrayList can produce an <emphasis role="strong"><phrase role="klass">Iterator</phrase></emphasis> object for you.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Note that with the Iterator object, we can also
// use the new &lt;ClassName&gt; generics syntax and
// specify the type that the Iterator will
// reference.
Iterator&lt;Particle&gt; it = particles.iterator();</programlisting>
<simpara>Once you’ve got the <emphasis role="strong"><phrase role="klass">Iterator</phrase></emphasis>, the <emphasis role="strong"><phrase role="function">hasNext()</phrase></emphasis> function will tell us whether there is a Particle for us to run and the <emphasis role="strong"><phrase role="function">next()</phrase></emphasis> function will grab that Particle object itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // An Iterator object doing the iterating for you
  while (it.hasNext()) {
    Particle p = it.next();
    p.run();
  }</programlisting>
<simpara>And if you call the <emphasis role="strong"><phrase role="function">remove()</phrase></emphasis> function on the <emphasis role="strong"><phrase role="klass">Iterator</phrase></emphasis> object during the loop, it will delete the current Particle object (and not skip ahead past the next one, as we saw with counting forward through the <emphasis role="strong"><phrase role="klass">ArrayList</phrase></emphasis>.)</simpara>
<programlisting language="java" linenumbering="unnumbered">  if (p.isDead()) {
    // An Iterator object doing the deleting for you
    it.remove();
   }</programlisting>
<simpara>Putting it all together, we have:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex02.png" canvas="processingjs/chapter04/_4_02_ArrayListParticles/_4_02_ArrayListParticles.pde processingjs/chapter04/_4_02_ArrayListParticles/Particle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter04_example2"><emphasis role="strong"><phrase role="example">Example 4.2: ArrayList of particles with iterator</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList particles;

void setup() {
  size(200,200);
  particles = new ArrayList();
}

void draw() {
  background(255);

  particles.add(new Particle(new PVector(width/2,50)));

  Iterator it = particles.iterator();
  // Using an Iterator object
  // instead of counting with int i
  while (it.hasNext()) {
    Particle p = it.next();
    p.run();
    if (p.isDead()) {
       it.remove();
    }
  }
}</programlisting>
</section>
<section id="chapter04_section4">
<title>4.4 The Particle System Class</title>
<simpara>OK, let’s review where we are.  We’ve done two things.  We’ve written a class to describe an individual <emphasis role="strong"><phrase role="klass">Particle</phrase></emphasis> object.  We’ve conquered the <emphasis role="strong"><phrase role="klass">ArrayList</phrase></emphasis> and used it to manage a list of many <emphasis role="strong"><phrase role="klass">Particle</phrase></emphasis> objects (with the ability to add and delete at will).</simpara>
<simpara>We could stop here. However, one additional step we can and should take is to write a class to describe the list of <emphasis role="strong"><phrase role="klass">Particle</phrase></emphasis> objects itself—the <emphasis role="strong"><phrase role="klass">ParticleSystem</phrase></emphasis> class.  This will allow us to remove the bulky logic of looping through all particles from the main tab, as well as open up the possibility of having more than one particle system.  A system of systems!</simpara>
<simpara>If you recall the goal we set at the beginning of this chapter, we wanted our main tab to look like:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Just one wee ParticleSystem!
ParticleSystem ps;

void setup() {
  size(200,200);
  ps = new ParticleSystem();
}

void draw() {
  background(255);
  ps.run();
}</programlisting>
<simpara>Let’s take the code from Example 4.2 and review a bit of object-oriented programming, looking at how each piece from the main tab can fit into the <emphasis role="strong"><phrase role="klass">ParticleSystem</phrase></emphasis> class.</simpara>
<passthrough><table class="code">
<tr>
<th>ArrayList in the main tab</th>
<th>ArrayList in the ParticleSystem class</th>
</tr>
<tr>
<td>
<pre>


<b>ArrayList&lt;Particle&gt; particles;</b>

void setup() {
  size(200,200);
  <b>particles = new ArrayList&lt;Particle&gt;();</b>
}

void draw() {
  background(255);

  <b>particles.add(new Particle());</b>



  <b>Iterator it = particles.iterator();
  while (it.hasNext()) {
    Particle p = it.next();
    p.run();
    if (p.isDead()) {
      it.remove();
    }
  }</b>
}
</pre>
</td>
<td>
<pre>
class ParticleSystem {
  <b>ArrayList&lt;Particle&gt; particles;</b>


  ParticleSystem() {
    <b>particles = new ArrayList&lt;Particle&gt;();</b>
  }



  void addParticle() {
    <b>particles.add(new Particle());</b>
  }

  void run() {
    <b>Iterator it = particles.iterator();
    while (it.hasNext()) {
      Particle p = it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }</b>
  }
}
</pre>
</td>
</tr>
</table></passthrough>
<simpara>We could also add some new features to the particle system itself.  For example, it might be useful for the <emphasis role="strong"><phrase role="klass">ParticleSystem</phrase></emphasis> class to keep track of an origin point where particles are made.  This fits in with the idea of a particle system being an “emitter,” a place where particles are born and sent out into the world.    The origin point should be initialized in the constructor:</simpara>
<simpara id="chapter04_example3"><emphasis role="strong"><phrase role="example">Example 4.3: Simple Single Particle System</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class ParticleSystem {
  ArrayList particles;
  // This particular ParticleSystem implementation
  // includes an origin point where each Particle begins.
  PVector origin; // [bold]

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList();
  }

  void addParticle() {
    // The origin is passed to each Particle when it is added.
    particles.add(new Particle(origin)); // [bold]
  }</programlisting>
<example id="chapter04_exercise3">
<title>Exercise 4.3</title>
<simpara>Make the origin point move dynamically.  Have the particles emit from the mouse location or use the concepts of velocity and acceleration to make the system move autonomously.</simpara>
</example>
<example id="chapter04_exercise4">
<title>Exercise 4.4</title>
<simpara>Building off Chapter 3’s “Asteroids” example, use a particle system to emit particles from the ship’s “thrusters” whenever a thrust force is applied.  The particles’ initial velocity should be related to the ship’s current direction.</simpara>
</example>
</section>
<section id="chapter04_section5">
<title>4.5 A System of Systems</title>
<simpara>Let’s review for a moment where we are.  We know how to talk about an individual Particle object.  We also know how to talk about a system of Particle objects, and this we call a “particle system.”  And we’ve defined a particle system as a collection of independent objects.  But isn’t a particle system itself an object?   If that’s the case (which it is), there’s no reason why we couldn’t also have a collection of many particle systems, i.e. a system of systems.</simpara>
<simpara>This line of thinking could of course take us even further, and you might lock yourself in a basement for days sketching out a diagram of a system of systems of systems of systems of systems of systems.  Of systems.   After all, this is how the world works.  An organ is a system of cells, a human body is a system of organs, a neighborhood is a system of human bodies, a city is a system of neighborhoods, and so on and so forth.   While this is an interesting road to travel down, it’s a bit beyond where we need to be right now.   It is, however, quite useful to know how to write a Processing sketch that keeps track of many particle systems, each of which keep track of many particles.  Let’s take the following scenario.</simpara>
<simpara>You start with a blank screen.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex04a.png" canvas="processingjs/chapter04/_4_04_SystemofSystems/_4_04_SystemofSystems.pde processingjs/chapter04/_4_04_SystemofSystems/Particle.pde processingjs/chapter04/_4_04_SystemofSystems/ParticleSystem.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex04a.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You click the mouse and generate a particle system at the mouse’s location.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex04b.png" canvas="processingjs/chapter04/_4_04_SystemofSystems_b/_4_04_SystemofSystems_b.pde processingjs/chapter04/_4_04_SystemofSystems_b/Particle.pde processingjs/chapter04/_4_04_SystemofSystems_b/ParticleSystem.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex04b.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each time you click the mouse a new particle system is created at the mouse’s location.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex04c.png" canvas="processingjs/chapter04/_4_04_SystemofSystems_c/_4_04_SystemofSystems_c.pde processingjs/chapter04/_4_04_SystemofSystems_c/Particle.pde processingjs/chapter04/_4_04_SystemofSystems_c/ParticleSystem.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex04c.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In Example <link linkend="chapter04_example3">4.3</link>, we stored a single reference to a particle system object in the variable <emphasis role="strong"><phrase role="var">ps</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">ParticleSystem ps;

void setup() {
  size(200,200);
  ps = new ParticleSystem(1,new PVector(width/2,50));
}

void draw() {
  background(255);
  ps.run();
  ps.addParticle();
}</programlisting>
<simpara>For this new example, what we want to do instead is create an <emphasis role="strong"><phrase role="klass">ArrayList</phrase></emphasis> to keep track of multiple instances of particle systems.  When the program starts (i.e. in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>), the ArrayList is empty.</simpara>
<simpara id="chapter04_example4"><emphasis role="strong"><phrase role="example">Example 4.4: System of Systems</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// This time the type of thing we are putting
// in the ArrayList is a ParticleSystem itself!
ArrayList&lt;ParticleSystem&gt; systems;
void setup() {
  size(600,200);
  systems = new ArrayList&lt;ParticleSystem&gt;();
}</programlisting>
<simpara>Whenever the mouse is pressed, a new ParticleSystem object is created and placed into the ArrayList.</simpara>
<programlisting language="java" linenumbering="unnumbered">void mousePressed() {
  systems.add(new ParticleSystem(1,new PVector(mouseX,mouseY)));
}</programlisting>
<simpara>And in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, instead of referencing a single ParticleSystem, we now look through all the systems in the ArrayList and call <emphasis role="strong"><phrase role="function">run()</phrase></emphasis> on each of them.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);
  // Since we aren’t deleting elements we
  // can use our enhanced loop!
  for (ParticleSystem ps: systems) {
    ps.run();
    ps.addParticle();
  }
}</programlisting>
<example id="chapter04_exercise5">
<title>Exercise 4.5</title>
<simpara>Rewrite example 4.4 so that each ParticleSystem doesn’t live forever.  When a ParticleSystem is empty (i.e. has no Particles left in its ArrayList) remove it from the ArrayList systems.</simpara>
</example>
<example id="chapter04_exercise6">
<title>Exercise 4.6</title>
<simpara>Create a simulation of an object shattering into many pieces. How can you turn one large shape into many small particles? What if there are several large shapes on the screen and they shatter when you click on them?</simpara>
</example>
</section>
<section id="chapter04_section6">
<title>4.6 Inheritance and Polymorphism: An Introduction</title>
<simpara>You may have encountered the terms <emphasis>inheritance</emphasis> and <emphasis>polymorphism</emphasis> in your programming life before this book.  After all, they are two of the three fundamental principles behind the theory of object-oriented programming (the other being <emphasis>encapsulation</emphasis>).   If you’ve read other Processing or Java programming books, chances are it’s been covered.   My beginner text, <emphasis>Learning Processing</emphasis>, has close to an entire chapter (#22) dedicated to these two topics.</simpara>
<simpara>Still, perhaps you’ve only learned about it in the abstract sense and never had a reason to really use inheritance and polymorphism.  If this is true, you’ve come to the right place.  Without these two topics, your ability to program a variety of particles and particle systems is extremely limited.   (In the next chapter, we’ll also see how understanding these topics will help us to use physics libraries.)</simpara>
<simpara>Imagine the following.   It’s a Saturday morning, you’ve just gone out for a lovely jog, had a delicious bowl of cereal, and are sitting quietly at your computer with a cup of warm chamomile tea.  It’s your old friend so and so’s birthday and you’ve decided you’d like to make a greeting card in Processing.  How about some confetti for a birthday?  Purple confetti, pink confetti, star-shaped confetti, square confetti, fast confetti, fluttery confetti, etc.  All of these pieces of confetti with different appearances and different behaviors explode onto the screen at once.</simpara>
<simpara>What we’ve got here is clearly a particle system—a collection of individual pieces of confetti (i.e. particles).  We might be able to cleverly design our Particle class to have variables that store its color, shape, behavior, etc.  And perhaps we initialize the values of these variables randomly.   But what if your particles are drastically different? This could become very messy, having all sorts of code for different ways of being a particle in the same class.  Well, you might consider doing the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">class HappyConfetti {

}

class FunConfetti {

}

class WackyConfetti {

}</programlisting>
<simpara>This is a nice solution: we have three different classes to describe the different kinds of pieces of confetti that could be part of our Particle System.   The ParticleSystem constructor could then have some code to pick randomly from the three classes when filling the ArrayList.  Note this probabilistic method is the same one we employed in our random walk examples in the <link linkend="intro_section2">Introduction</link>.</simpara>
<programlisting language="java" linenumbering="unnumbered">class ParticleSystem {
  ParticleSystem(int num) {
    particles = new ArrayList();
    for (int i = 0; i &lt; num; i++) {
      float r = random(1);
      //[offset-up] Randomly picking a "kind" of particle
      if      (r &lt; 0.33) { particles.add(new HappyConfetti()); }
      else if (r &lt; 0.67) { particles.add(new FunConfetti());   }
      else               { particles.add(new WackyConfetti()); }
    }
  }</programlisting>
<simpara>OK, we now need to pause for a moment.   We’ve done nothing wrong.   All we wanted to do was wish our friend a happy birthday and enjoy writing some code.  But while the reasoning behind the above approach is quite sound, we’ve opened up two major problems.</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Problem #1:  Aren’t we going to be copying/pasting a lot of code between the different “confetti” classes?</phrase></emphasis></simpara>
<simpara>Yes.  Even though our kinds of particles are different enough to merit our breaking them out into separate classes, there is still a ton of code that they will likely share.   They’ll all have PVectors to keep track of location, velocity, and acceleration; an <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> function that implements our motion algorithm, etc.</simpara>
<simpara>This is where <emphasis>inheritance</emphasis> comes in.  <emphasis>Inheritance</emphasis> allows us to write a class that <emphasis>inherits</emphasis> variables and functions from another class, all the while implementing its own custom features.</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Problem #2:  How will the ArrayList know which objects are which type?</phrase></emphasis></simpara>
<simpara>This is a pretty serious problem.  Remember, we were using generics to tell the <emphasis>ArrayList</emphasis> what type of objects we’re going to put inside it.  Are we suddenly going to need three different ArrayLists?</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;HappyConfetti&gt; a1 = new ArrayList&lt;HappyConfetti&gt;();
ArrayList&lt;FunConfetti&gt;   a2 = new ArrayList&lt;FunConfetti&gt;();
ArrayList&lt;WackyConfetti&gt; a3 = new ArrayList&lt;WackyConfetti&gt;();</programlisting>
<simpara>This seems awfully inconvenient, given that we really just want one list to keep track of all the stuff in the ParticleSystem.  That can be made possible with <emphasis>polymorphism</emphasis>.  Polymorphism will allow us to consider objects of different types as the same type and store them in a single ArrayList.</simpara>
<simpara>Now that we understand the problem, let’s look at these two concepts with a bit more detail and then create a Particle System example that implements both inheritance and polymorphism.</simpara>
</section>
<section id="chapter04_section7">
<title>4.7 Inheritance Basics</title>
<simpara>Let’s take a different example, the world of animals: dogs, cats, monkeys, pandas, wombats, and sea nettles.   Arbitrarily, let’s begin by programming a Dog class.   A Dog object will have an age variable (an integer), as well as <emphasis role="strong"><phrase role="function">eat()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">sleep()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">bark()</phrase></emphasis> functions.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Dog {
  int age;
  //[full] Dogs and cats have the same variables (age) and functions (eat, sleep).
  Dog() {
    age = 0;
  }

  void eat() {
    println("Yum!");
  }

  void sleep() {
    println("Zzzzzz");
  }
  //[end]

  //[full] A unique function for barking.
  void bark() {
    println("WOOF!");
  }
  //[end]
}</programlisting>
<simpara>Finishing with dogs, we can now move on to cats.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Cat {
  int age;

  Cat() {
    age = 0;
  }

  void eat() {
    println("Yum!");
  }

  void sleep() {
    println("Zzzzzz");
  }

  void meow() {
    println("MEOW!");
  }
}</programlisting>
<simpara>As we move onto fish, horses, koala bears, and lemurs, this process will become rather tedious as we rewrite the same code over and over again.  What if, instead, we could develop a generic Animal class to describe any type of animal?  After all, all animals eat and sleep.  We could then say the following:</simpara>
<itemizedlist>
<listitem>
<simpara>
A dog is an animal and has all the properties of animals and can do all the things animals do. Also, a dog can bark.
</simpara>
</listitem>
<listitem>
<simpara>
A cat is an animal and has all the properties of animals and can do all the things animals do. Also, a cat can meow.
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Inheritance</emphasis> allows us to program just this.  With inheritance, classes can inherit properties (variables) and functionality (methods) from other classes.  A Dog class is a child (aka <emphasis>subclass</emphasis>) of an Animal class.  Children automatically inherit all variables and functions from their parent (aka <emphasis>superclass</emphasis>).  Children can also include additional variables and functions not found in the parent.    Inheritance follows a tree-structure (much like a phylogenetic “tree of life.”)    Dogs can inherit from Canines which inherit from Mammals which inherit from Animals, etc.</simpara>
<informalfigure id="chapter04_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_02.png" />
  </imageobject>
  <textobject><phrase>Figure 4.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here is how the syntax works with inheritance.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The Animal class is the parent (or super) class.
class Animal {
  // The variable age is inherited by Dog and Cat.
  int age;

  Animal() {
    age = 0;
  }

  // The functions eat() and sleep() are inherited by Dog and Cat.
  void eat() {
    println("Yum!");
  }

  void sleep() {
    println("Zzzzzz");
  }
}

// The Dog class is the child (or sub) class.
// This is indicated with the code “extends Animal”.
class Dog extends Animal { // [bold]
  Dog() {
    // super() means execute code found in the parent class.
    super(); // [bold]
  }
  // Since bark() is not part of the parent class,
  // we have to define it in the child class.
  void bark() {
    println("WOOF!");
  }
}

class Cat extends Animal {
  Cat() {
    super();
  }
  void meow() {
    println("MEOW!");
  }
}</programlisting>
<simpara>The following new terms have been introduced:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>extends</emphasis></emphasis> – This keyword is used to indicate a parent for the class being defined.  Note that classes can only extend <emphasis role="strong">one</emphasis> class.   However, classes can extend classes that extend other classes, i.e.  Dog extends Animal, Terrier extends Dog.  Everything is inherited all the way down the line.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>super()</emphasis></emphasis> – This calls the Constructor in the parent class.   In other words, whatever you do in the parent constructor, do so in the child constructor as well.   Other code can be written into the constructor in addition to <emphasis role="strong"><phrase role="function">super()</phrase></emphasis>.   <emphasis role="strong"><phrase role="function">super()</phrase></emphasis> can also receive arguments if there is a parent constructor defined with matching arguments.
</simpara>
</listitem>
</itemizedlist>
<simpara>A subclass can be expanded to include additional functions and properties beyond what is contained in the superclass.  For example, let’s assume that a Dog object has a hair color variable in addition to age, which is set randomly in the constructor.  The class would now look like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Dog extends Animal {
  // A child class can introduce new variables not
  // included in the parent.
  color haircolor;
  Dog() {
    super();
    haircolor = color(random(255));
  }

  void bark() {
    println("WOOF!");
  }
}</programlisting>
<simpara>Note how the parent constructor is called via <emphasis role="strong"><phrase role="function">super()</phrase></emphasis>, setting the age to 0, but the hair color is set inside the Dog constructor itself.    Suppose a Dog object eats differently than the generic Animal.  Parent functions can be <emphasis>overridden</emphasis> by rewriting the function inside the sub class.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Dog extends Animal {
  color haircolor;

  Dog() {
     super();
     haircolor = color(random(255));
  }

  // A child can override a parent function if necessary.
  void eat() {
    // How a dog specifically eats
    println("Woof! Woof! Slurp.")
  }

  void bark() {
    println("WOOF!");
  }
}</programlisting>
<simpara>But what if a Dog should eat the same way an Animal does, albeit with some additional functionality?  A subclass can both run the code from a parent class and incorporate some custom code.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Dog extends Animal {
   color haircolor;

   Dog() {
     super();
     haircolor = color(random(255));
   }

   void eat() {
     // Call eat() from Animal
     // A child can execute a function from the parent
     // while adding its own code as well.
     super.eat(); // [bold]
     // Add some additional code
     // for how a dog specifically eats
     println("Woof!!!");
   }

   void bark() {
    println("WOOF!");
  }
}</programlisting>
</section>
<section id="chapter04_section8">
<title>4.8 Particles with Inheritance</title>
<simpara>Now that we’ve had an introduction to the theory of inheritance and its syntax, we can develop a working example in Processing based on our Particle class.</simpara>
<simpara>Let’s review a simple Particle implementation (further simplified from Example <emphasis role="strong"><phrase role="notetoself">4.x</phrase></emphasis>):</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;

  Particle(PVector l) {
    acceleration = new PVector(0,0.05);
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
  }

  void run() {
    update();
    display();
  }

  void update() {
    velocity.add(acceleration);
    location.add(velocity);
  }

  void display() {
    fill(0);
    ellipse(location.x,location.y,8,8);
  }
}</programlisting>
<simpara>Next, we create a subclass from Particle (let’s call it “Confetti”). It will inherit all the instance variables and methods from Particle. We write a new constructor with the name “Confetti” and execute the code from the parent class by calling <emphasis role="strong"><phrase role="function">super()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Confetti extends Particle {

  // We could add variables for only Confetti here

  Confetti(PVector l) {
    super(l);
  }

  // Inherits update() from parent

  // Override the display method
  void display() {
    rectMode(CENTER);
    fill(175);
    stroke(0);
    rect(location.x,location.y,8,8);
  }
}</programlisting>
<simpara>Let’s make this a bit more sophisticated.  Let’s say we want to have the “Confetti” particle rotate as it flies through the air.  We could, of course, model angular velocity and acceleration as we did in Chapter 3.  Instead, we’ll try a quick and dirty solution.</simpara>
<simpara>We know a particle has an x location somewhere between zero and the width of the window.   What if we said: when the particle’s x location is zero, its rotation should be zero; when its x location is equal to the width, its rotation should be equal to two PI?  Does this ring a bell?  Whenever we have a value with one range that we want to map to another range, we can use Processing’s <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function!  (See <link linkend="intro_section6">Introduction</link>.)</simpara>
<programlisting language="java" linenumbering="unnumbered">float angle = map(location.x,0,width,0,TWO_PI);</programlisting>
<simpara>And just to give it a bit more spin, we can actually map the angle’s range from 0 to TWO_PI*2.  Let’s look at how this code fits into the display() function.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    rectMode(CENTER);
    fill(0,lifespan);
    stroke(0,lifespan);
    // If we rotate() a shape in Processing,
    // we need to familiarize ourselves with transformations.
    // For more, visit: http://processing.org/learning/transform2d/
    pushMatrix();
    translate(location.x,location.y);
    float theta = map(location.x,0,width,0,TWO_PI*2);
    rotate(theta);
    rect(0,0,8,8);
    popMatrix();
  }</programlisting>
<example id="chapter04_exercise7">
<title>Exercise 4.7</title>
<simpara>Instead of using <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> to calculate theta, how would you model angular velocity and acceleration?</simpara>
</example>
<simpara>Now that we have a “Confetti” particle that extends our base Particle class, we need to figure out how our Particle System class can manage particles of different types within the same system.  To accomplish this goal, let’s return to the animal kingdom inheritance example and see how the concept extends into the world of polymorphism.</simpara>
</section>
<section id="chapter04_section9">
<title>4.9 Polymorphism Basics</title>
<simpara>Now that we have the concept of inheritance down, we can imagine how we would program a diverse animal kingdom using ArrayLists—an array of dogs, an array of cats, of turtles, of kiwis, etc. frolicking about.</simpara>
<programlisting language="java" linenumbering="unnumbered">//[full] Separate ArrayLists for each animal
ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();
ArrayList&lt;Cat&gt; cats = new ArrayList&lt;Cat&gt;();
ArrayList&lt;Turtle&gt; turtles = new ArrayList&lt;Turtle&gt;();
ArrayList&lt;Kiwi&gt; kiwis = new ArrayList&lt;Kiwi&gt;();
//[end]

for (int i = 0; i &lt; 10; i++) {
  dogs.add(new Dog());
}
for (int i = 0; i &lt; 15; i++) {
  cats.add(new Cat());
}
for (int i = 0; i &lt; 6; i++) {
  turtles.add(new Turtle());
}
for (int i = 0; i &lt; 98; i++) {
  kiwis.add(new Kiwi());
}</programlisting>
<simpara>As the day begins, the animals are all pretty hungry and are looking to eat.  So it’s off to looping time (enhanced looping time!)&#8230;</simpara>
<programlisting language="java" linenumbering="unnumbered">//[full] Separate loops for each animal
for (Dog d: dogs) {
  d.eat();
}
for (Cat c: cats) {
  c.eat();
}
for (Turtle t: turtles) {
  t.eat();
}
for (Kiwi k: kiwis) {
  k.eat();
}
//[end]</programlisting>
<simpara>This works great, but as our world expands to include many more animal species, we’re going to get stuck writing a lot of individual loops.  Is this really necessary?  After all, the creatures are all animals, and they all like to eat.  Why not just have one ArrayList of “Animal” objects and fill it with all different <emphasis>kinds</emphasis> of Animals?</simpara>
<programlisting language="java" linenumbering="unnumbered">//[offset-down] Just one ArrayList for all the animals!
ArrayList&lt;Animal&gt; kingdom = new ArrayList&lt;Animal&gt;();

for (int i = 0; i &lt; 1000; i++) {
  if (i &lt; 100) kingdom.add(new Dog());
  else if (i &lt; 400) kingdom.add(new Cat());
  else if (i &lt; 900) kingdom.add(new Turtle());
  else kingdom.add(new Kiwi());
}

for (Animal a: kingdom) {
  a.eat();
}</programlisting>
<simpara>The ability to treat a Dog object as either a member of the Dog class or the Animal class (its parent) is an example of polymorphism.  Polymorphism (from the Greek <emphasis>polymorphos</emphasis>, meaning many forms) refers to the treatment of a single instance of an object in multiple forms.    A Dog is certainly a Dog, but since Dog extends Animal, it can also be considered an Animal.  In code, we can refer to it both ways.</simpara>
<programlisting language="java" linenumbering="unnumbered">Dog rover = new Dog();
Animal spot = new Dog();</programlisting>
<simpara>Although the second line of code might initially seem to violate syntax rules, both ways of declaring a Dog object are legal.  Even though we declare spot as a Animal, we’re really making a Dog object and storing it in the spot variable.  And we can safely call all of the Animal methods on spot because the rules of inheritance dictate that a Dog can do anything an Animal can.</simpara>
<simpara>What if the Dog class, however, overrides the <emphasis role="strong"><phrase role="function">eat()</phrase></emphasis> function in the Animal class?  Even if spot is declared as an Animal, Java will determine that its true identity is that of a Dog and run the appropriate version of the <emphasis role="strong"><phrase role="function">eat()</phrase></emphasis> function.</simpara>
<simpara>This is particularly useful when we have an array or ArrayList.</simpara>
</section>
<section id="chapter04_section10">
<title>4.10 Particle Systems with Polymorphism</title>
<simpara>Let’s pretend for a moment that polymorphism doesn’t exist and rewrite a Particle System class to include many Particle objects and many Confetti objects.</simpara>
<programlisting language="java" linenumbering="unnumbered">class ParticleSystem {
  //[full] We’re stuck doing everything twice with two lists!
  ArrayList&lt;Particle&gt; particles; // [bold]
  ArrayList&lt;Confetti&gt; confetti; // [bold]
  //[end]
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;(); // [bold]
    confetti = new ArrayList&lt;Confetti&gt;(); // [bold]
  }

  void addParticle() {
    particles.add(new Particle(origin)); // [bold]
    particles.add(new Confetti(origin)); // [bold]
  }

  void run() {
    Iterator it = particles.iterator(); // [bold]
    while (it.hasNext()) {
      Particle p = it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
    it = confetti.iterator(); // [bold]
    while (it.hasNext()) {
      Confetti c = it.next();
      c.run();
      if (c.isDead()) {
        it.remove();
      }
    }

  }
}</programlisting>
<simpara>Notice how we have two separate lists, one for Particle objects and one for Confetti objects.  Every action we want to perform we have to do twice!   Polymorphism allows us to simplify the above by just making one ArrayList of Particle objects that contains both standard Particle objects as well as Confetti objects.  We don’t have to worry about which are which; this will all be taken care of for us!  (Also, note that the code for the main program and the classes has not changed so we aren’t including it here.  See website for full example.)</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex05.png" canvas="processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/_4_05_ParticleSystemInheritancePolymorphism.pde processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/Confetti.pde processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/Particle.pde processingjs/chapter04/_4_05_ParticleSystemInheritancePolymorphism/ParticleSystem.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter04_example5"><emphasis role="strong"><phrase role="example">Example 4.5: Particle System Inheritance and Polymorphism</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class ParticleSystem {
  // One list, for anything that is a Particle
  // or extends Particle
  ArrayList&lt;Particle&gt; particles;  // [bold]
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;();
  }

  void addParticle() {
    float r = random(1);
    // We have a 50% chance of adding each kind of Particle.
    if (r &lt; 0.5) {
      particles.add(new Particle(origin));  // [bold]
    } else {
      particles.add(new Confetti(origin));  // [bold]
    }
  }

  void run() {
    Iterator it = particles.iterator();
    while (it.hasNext()) {
      // Polymorphism allows us to treat everything as a
      // Particle, whether it is a Particle or a Confetti.
      Particle p = it.next(); // [bold]
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
  }
}</programlisting>
<example id="chapter04_exercise8">
<title>Exercise 4.8</title>
<simpara>Exercise:  Create a particle system with different “kinds” of particles in the same system.  Try varying more than just the look of the particles.  How do you deal with different behaviors using inheritance?</simpara>
</example>
</section>
<section id="chapter04_section11">
<title>4.11 Particle Systems with Forces</title>
<simpara>So far in this chapter, we’ve been focusing on structuring our code in an object-oriented way to manage a collection of Particle objects.   Maybe you noticed, or maybe you didn’t, but during this process we unwittingly took a couple steps backward from where we were in previous chapters.  Let’s examine the constructor of our simple Particle class.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Particle(PVector l) {
    // We’re setting acceleration to a constant value!
    acceleration = new PVector(0,0.05); // [bold]
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
    lifespan = 255.0;
  }</programlisting>
<simpara>And now let’s look at the <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {
    velocity.add(acceleration);
    location.add(velocity);

    [inline]// Where is the line of code to clear acceleration?

    lifespan -= 2.0;
  }</programlisting>
<simpara>Our Particle class is structured to have a constant acceleration, one that never changes.  A much better framework would be to follow Newton’s second law (F = M* A) and incorporate the force accumulation algorithm we worked so hard on in <link linkend="chapter02_section3">Chapter 2</link>.</simpara>
<simpara>Step 1 would be to add in the <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function. (Remember, we need to make a copy of the PVector before we divide it by mass.)</simpara>
<programlisting language="java" linenumbering="unnumbered">  void applyForce(PVector force) {
    PVector f = force.get();
    f.div(mass);
    acceleration.add(f);
  }</programlisting>
<simpara>Once we have this, we can add in one more line of code to clear the acceleration at the end of <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {
   velocity.add(acceleration);
   location.add(velocity);
   // There it is!
   acceleration.mult(0);
   lifespan -= 2.0;
  }</programlisting>
<simpara>And our Particle class is complete!</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  // We could vary mass for more interesting results.
  float mass = 1;

  Particle(PVector l) {
    // We now start with acceleration of 0.
    acceleration = new PVector(0,0);
    velocity = new PVector(random(-1,1),random(-2,0));
    location = l.get();
    lifespan = 255.0;
  }

  void run() {
    update();
    display();
  }

  // Newton’s second law &amp; force accumulation
  void applyForce(PVector force) {
    PVector f = force.get();
    f.div(mass);
    acceleration.add(f);
  }

  // Standard update
  void update() {
    velocity.add(acceleration);
    location.add(velocity);
    acceleration.mult(0);
    lifespan -= 2.0;
  }

  // Our Particle is a circle.
  void display() {
    stroke(255,lifespan);
    fill(255,lifespan);
    ellipse(location.x,location.y,8,8);
  }

  // Should the Particle be deleted?
  boolean isDead() {
    if (lifespan &lt; 0.0) {
      return true;
    } else {
      return false;
    }
  }
}</programlisting>
<simpara>Now that the Particle class is completed, we have a very important question to ask.  Where do we call the <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function?  Where in the code is it appropriate to apply a force to a particle?   The truth of the matter is that there’s no right or wrong answer; it really depends on the exact functionality and goals of a particular Processing sketch.  Still, we can create a generic situation that would likely apply to most cases and create a model for applying forces to individual particles in a system.</simpara>
<simpara>Let’s consider the following goal: Apply a force globally every time through draw() to all particles.</simpara>
<simpara>Let’s just pick an easy one: a force pointing down, like gravity.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector gravity = new PVector(0,0.1);</programlisting>
<simpara>We said it should always be applied, i.e. in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, so let’s take a look at our <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> function as it stands.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(100);
  ps.addParticle();
  ps.run();
}</programlisting>
<simpara>Well, it seems that we have a small problem.  <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> is a method written inside the Particle class, but we don’t have any reference to the individual particles themselves, only the ParticleSystem object: the variable ps.</simpara>
<simpara>Since we want all particles to receive the force, however, we can decide to apply the force to the particle system and let it manage applying the force to all the individual particles:</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(100);

  PVector gravity = new PVector(0,0.1);
  // Applying a force to the system as a whole
  ps.applyForce(gravity);

  ps.addParticle();
  ps.run();
}</programlisting>
<simpara>Of course, if we call a new function on the ParticleSystem object in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, well, we have to write that function in the ParticleSystem class.   Let’s describe the job that function needs to perform:</simpara>
<note>
<simpara>Receive a force as a PVector and apply that force to all the particles._</simpara>
</note>
<simpara>Now in code:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void applyForce(PVector f) {
    for (Particle p: particles) {
      p.applyForce(f);
    }
  }</programlisting>
<simpara>It almost seems silly to write this function.   What we’re saying is “apply a force to a particle system so that the system can apply that force to all of the individual particles.”   Nevertheless, it’s really quite reasonable.  After all, the ParticleSystem object is in charge of managing the particles, so if we want to talk to the particles, we’ve got to talk to them through their manager.  (Also, here’s a chance for the enhanced loop since we aren’t deleting particles!)</simpara>
<simpara>Here is the full example (assuming the existence of the Particle class written above; no need to include it again since nothing has changed):</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex06.png" canvas="processingjs/chapter04/_4_06_ParticleSystemForces/_4_06_ParticleSystemForces.pde processingjs/chapter04/_4_06_ParticleSystemForces/Particle.pde processingjs/chapter04/_4_06_ParticleSystemForces/ParticleSystem.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter04_example6"><emphasis role="strong"><phrase role="example">Example 4.6: Particle system with forces</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">ParticleSystem ps;

void setup() {
  size(200,200);
  smooth();
  ps = new ParticleSystem(new PVector(width/2,50));
}

void draw() {
  background(100);

  // Apply a force to all particles.
  PVector gravity = new PVector(0,0.1); // [bold]
  ps.applyForce(gravity); // [bold]

  ps.addParticle();
  ps.run();
}


class ParticleSystem {
  ArrayList&lt;Particle&gt; particles;
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;();
  }

  void addParticle() {
    particles.add(new Particle(origin));
  }

  // Using an enhanced loop to apply the force to all particles
  void applyForce(PVector f) {
    for (Particle p: particles) {
      p.applyForce(f);
    }
  }

  void run() {
    // Can’t use the enhanced loop because we
    // want to check for particles to delete
    Iterator it = particles.iterator();
    while (it.hasNext()) {
      Particle p = (Particle) it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
  }
}</programlisting>
</section>
<section id="chapter04_section12">
<title>4.12 Particle Systems with Repellers</title>
<simpara>What if we wanted to take this example one step further and add a “Repeller” object (the inverse of the Attractor object we covered in <link linkend="chapter02_section9">Chapter 2</link> that pushes any particles away that get close?  This requires a bit more sophistication because, unlike the gravity force, each force an Attractor or Repeller exerts on a particle must be calculated for each Particle.</simpara>
<informalfigure id="chapter04_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_03.png" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Figure 4.3: Gravity force: Vectors are all identical</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter04_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_04.png" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Figure 4.4: Attractor force: Vectors are all different</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s start solving this problem by examining how we would incorporate a new Repeller object into our simple particle system plus forces example.  We’re going to need two major additions to our code:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
A Repeller object (declared, initialized, and displayed).
</simpara>
</listitem>
<listitem>
<simpara>
A function that passes the Repeller object into the ParticleSystem so that it can apply a force to each particle object.
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">ParticleSystem ps;
// New thing #1: we need a Repeller class.
Repeller repeller; // [bold]

void setup() {
  size(200,200);
  smooth();
  ps = new ParticleSystem(new PVector(width/2,50));
  // New thing #1: we need a Repeller class.
  repeller = new Repeller(width/2-20,height/2); // [bold]
}

void draw() {
  background(100);
  ps.addParticle();

  PVector gravity = new PVector(0,0.1);
  ps.applyForce(gravity);

  // New thing #2: we need a function to apply
  // a force from a repeller.
  ps.applyRepeller(repeller); // [bold]

  ps.run();
  // New thing #1: we need a Repeller class.
  repeller.display(); // [bold]
}</programlisting>
<simpara>Making a Repeller object is quite easy; it’s a duplicate of the Attractor class from Chapter 2 (<link linkend="chapter02_example6">Example 2.6</link>).</simpara>
<programlisting language="java" linenumbering="unnumbered">class Repeller {
  // A Repeller doesn’t move, so you just need location.
  PVector location;
  float r = 10;

  Repeller(float x, float y)  {
    location = new PVector(x,y);
  }

  void display() {
    stroke(255);
    fill(255);
    ellipse(location.x,location.y,r*2,r*2);
  }
}</programlisting>
<simpara>The more difficult question is, how do we write the <emphasis role="strong"><phrase role="function">applyRepeller()</phrase></emphasis> function?  Instead of passing a PVector into a function like we do with <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis>, we’re going to instead pass a Repeller object into <emphasis role="strong"><phrase role="function">applyRepeller()</phrase></emphasis> and ask that function to do the work of calculating the force between the Repeller and all particles.  Let’s look at both of these functions side by side.</simpara>
<passthrough><table class="code">
<tr>
<th>applyForce()</th>
<th>applyRepeller</th>
</tr>
<tr>
<td>
<pre>
void applyForce(PVector f) {
  for (Particle p: particles) {
    p.applyForce(f);
  }
}
</pre>
</td>
<td>
<pre>
void applyRepeller(Repeller r) {
  for (Particle p: particles) {
    PVector force = r.repel(p);
    p.applyForce(force);
  }
}
</pre>
</td>
</tr>
</table></passthrough>
<simpara>The functions are almost identical.  There are only two differences. One we mentioned before—a Repeller object is the argument, not a PVector.  The second difference is the important one.   We must calculate a custom PVector force for each and every particle and apply that force.  How is that force calculated?   In a function called <emphasis role="strong"><phrase role="function">repel()</phrase></emphasis>, which is the inverse of the <emphasis role="strong"><phrase role="function">attract()</phrase></emphasis> function we wrote for the Attractor class.</simpara>
<programlisting language="java" linenumbering="unnumbered">   // All the same steps we had to calculate an attractive force, only pointing in the opposite direction.
  PVector repel(Particle p) {
    // 1) Get force direction
    PVector dir = PVector.sub(location,p.location);
    // 2) Get distance (constrain distance)
    float d = dir.mag();
    dir.normalize();
    d = constrain(d,5,100);
    // 3) Calculate magnitude
    float force = -1 * G / (d * d);
    // 4) Make a vector out of direction and magnitude
    dir.mult(force);
    return dir;
  }</programlisting>
<simpara>Notice how throughout this entire process of adding a Repeller to the environment, we’ve never once considered editing the Particle class itself.   A particle doesn’t actually have to know anything about the details of its environment; it simply needs to manage its location, velocity, and acceleration, as well as have the ability to receive an external force and act on it.</simpara>
<simpara>So we can now look at this example in its entirety, again leaving out the Particle class, which hasn’t changed.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex07.png" canvas="processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/_4_07_ParticleSystemForcesRepeller.pde processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/Repeller.pde processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/Particle.pde processingjs/chapter04/_4_07_ParticleSystemForcesRepeller/ParticleSystem.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex07.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter04_example7"><emphasis role="strong"><phrase role="example">Example 4.7: ParticleSystem with repeller</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// One Particle System
ParticleSystem ps;
// One Repeller
Repeller repeller;

void setup() {
  size(200,200);
  smooth();
  ps = new ParticleSystem(new PVector(width/2,50));
  repeller = new Repeller(width/2-20,height/2);
}

void draw() {
  background(100);
  ps.addParticle();

  // We’re applying a universal gravity.
  PVector gravity = new PVector(0,0.1);
  ps.applyForce(gravity);

  // Applying the repeller
  ps.applyRepeller(repeller);

  ps.run();
  repeller.display();
}


// The ParticleSystem manages all the Particles.
class ParticleSystem {
  ArrayList&lt;Particle&gt; particles;
  PVector origin;

  ParticleSystem(PVector location) {
    origin = location.get();
    particles = new ArrayList&lt;Particle&gt;();
  }

  void addParticle() {
    particles.add(new Particle(origin));
  }

  // Applying a force as a PVector
  void applyForce(PVector f) {
    for (Particle p: particles) {
      p.applyForce(f);
    }
  }

  // Calculating a force for each Particle based on a Repeller
  void applyRepeller(Repeller r) {
    for (Particle p: particles) {
      PVector force = r.repel(p);
      p.applyForce(force);
    }
  }

  void run() {
    Iterator it = particles.iterator();
    while (it.hasNext()) {
      Particle p = (Particle) it.next();
      p.run();
      if (p.isDead()) {
        it.remove();
      }
    }
  }
}

class Repeller {

  // How strong is the repeller?
  float strength = 100;
  PVector location;
  float r = 10;

  Repeller(float x, float y)  {
    location = new PVector(x,y);
  }

  void display() {
    stroke(255);
    fill(255);
    ellipse(location.x,location.y,r*2,r*2);
  }

  // This is the same repel algorithm we used
  // in Chapter 2: forces based on
  // gravitational attraction.
  PVector repel(Particle p) {
    PVector dir = PVector.sub(location,p.location);
    float d = dir.mag();
    dir.normalize();
    d = constrain(d,5,100);
    float force = -1 * strength / (d * d);
    dir.mult(force);
    return dir;
  }
}</programlisting>
<example id="chapter04_exercise9">
<title>Exercise 4.9</title>
<simpara>Expand the above example to include many Repellers (using an array or ArrayList).</simpara>
</example>
<example id="chapter04_exercise10">
<title>Exercise 4.10</title>
<simpara>Create a particle system in which each particle responds to every other particle.  (Note we’ll be doing this in detail in Chapter 6.)</simpara>
</example>
</section>
<section id="chapter04_section13">
<title>4.13 Image Textures and Additive Blending</title>
<simpara>Even though this book is really about behaviors and algorithms rather than computer graphics and design, I don’t think we would be able to live with ourselves if we went through a discussion of particle systems and never once looked at an example that involves texturing each particle with an image.  The way you choose to draw a particle is a big part of the puzzle in terms of designing certain types of visual effects.</simpara>
<simpara>Let’s try to create a smoke simulation in Processing.  Take a look at the following two images:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex08b.png" canvas="processingjs/chapter04/_4_08_ParticleSystemSmoke_b/_4_08_ParticleSystemSmoke_b.pde processingjs/chapter04/_4_08_ParticleSystemSmoke_b/Particle.pde processingjs/chapter04/_4_08_ParticleSystemSmoke_b/ParticleSystem.pde" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>White circles</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex08a.png" canvas="processingjs/chapter04/_4_08_ParticleSystemSmoke/_4_08_ParticleSystemSmoke.pde processingjs/chapter04/_4_08_ParticleSystemSmoke/Particle.pde processingjs/chapter04/_4_08_ParticleSystemSmoke/ParticleSystem.pde" classname="two-col-borderless" />
  </imageobject>
  <textobject><phrase>Fuzzy images with transparency</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Both of these images were generated from identical algorithms. The only difference is that a white circle is drawn in image A for each particle and a “fuzzy” blob is drawn for each in B.</simpara>
<informalfigure id="chapter04_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_05.png" />
  </imageobject>
  <textobject><phrase>Figure 4.5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The good news here is that you get a lot of bang for very little buck.   Before you write any code, however, you’ve got to make your image texture!  I recommend using PNG format, as Processing will retain the alpha channel (i.e. transparency) when drawing the image, which is needed for blending the texture as particles layer on top of each other.  Once you’ve made your PNG and deposited it in your sketch’s “data” folder, you are on your way with just a few lines of code.</simpara>
<simpara>First, we’ll need to declare a PImage object.</simpara>
<simpara id="chapter04_example8"><emphasis role="strong"><phrase role="example">Example 4.8: Image texture particle system</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">PImage img;</programlisting>
<simpara>Load the image in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  // Loading the PNG
  img = loadImage("texture.png");
}</programlisting>
<simpara>And when it comes time to draw the particle, we’ll use the image reference instead of drawing an ellipse or rectangle.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void render() {
    imageMode(CENTER);
    // Note how tint() is the image equivalent of shape’s fill().
    tint(255,lifespan);
    image(img,loc.x,loc.y);
  }</programlisting>
<simpara>Incidentally, this smoke example is a nice excuse to revisit a Gaussian number distribution (see <link linkend="intro_section4">Introduction Section 4</link>).  To make the smoke appear a bit more realistic, we don’t want to launch all the particles in a purely random direction.  Instead, by creating initial velocity vectors mostly around a mean value (with a lower probability of outliers), we’ll get an effect that appears less fountain-like and more like smoke (or fire).</simpara>
<simpara>Assuming a Random object called “generator”, we could create initial velocities as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">    float vx = (float) generator.nextGaussian()*0.3;
    float vy = (float) generator.nextGaussian()*0.3 - 1.0;
    vel = new PVector(vx,vy);</programlisting>
<simpara>Finally, in this example, a wind force is applied to the smoke mapped from the mouse’s horizontal location.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(0);

  float dx = map(mouseX,0,width,-0.2,0.2);
  // Wind force points towards mouseX.
  PVector wind = new PVector(dx,0);
  ps.applyForce(wind);
  ps.run();
  // Two particles are added each cycle through draw().
  for (int i = 0; i &lt; 2; i++) {
    ps.addParticle();
  }
}</programlisting>
<example id="chapter04_exercise11">
<title>Exercise 4.11</title>
<simpara>Exercise: Try creating your own textures for different types of effects.  Can you make it look like fire, instead of smoke?</simpara>
</example>
<example id="chapter04_exercise12">
<title>Exercise 4.12</title>
<simpara>Exercise: Use an array of images and assign each Particle object a different image.  Even though single images are drawn by multiple particles, make sure you don’t call loadImage() any more than you need to, i.e once for each image file.</simpara>
</example>
<simpara>Finally, it’s worth noting that there are many different algorithms for blending colors in computer graphics. These are often referred to as “blend modes.”  By default, when we draw something on top of something else in Processing, we only see the top layer—this is commonly referred to as a “normal” blend mode.  When the pixels have alpha transparency (as they do in the smoke example), Processing uses an alpha compositing algorithm that combines a percentage of the background pixels with the new foreground pixels based on the alpha values.</simpara>
<simpara>However, it’s possible to draw using other blend modes, and a much loved blend mode for particle systems is “additive.”  Additive blending in Processing was pioneered by flight404.com [Robert Hodgin] in his famous particle system and forces exploration, Magnetosphere, (which later became the iTunes visualizer.  For more see: <ulink url="http://roberthodgin.com/magnetosphere-part-2/">Magnetosphere</ulink>)</simpara>
<simpara>Additive blending is in fact one of the simplest blend algorithms and involves adding the pixel values of one layer with another (capping all values at 255 of course).  This results in a space-age glow effect due to the colors getting brighter and brighter with more layers.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter04/ch04_ex09.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter04/ch04_ex09.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To achieve additive blending in Processing, you’ll need to use the P2D or P3D renderer.</simpara>
<simpara id="chapter04_example9"><emphasis role="strong"><phrase role="example">Example 4.9: Additive blending</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  // Using the P2D  renderer
  size(200,200,P2D);
}</programlisting>
<simpara>Then, before you go to draw anything, you set the blend mode using <emphasis role="strong"><phrase role="function">blendMode()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  // Additive blending
  blendMode(ADD);

  // Note the “glowing” effect of additive
  // blending will not work with a white
  // (or very bright) background.
  background(0);

  [inline]// All your other particle stuff would go here.

}</programlisting>
<example id="chapter04_exercise13">
<title>Exercise 4.13</title>
<simpara>Use <emphasis role="strong"><phrase role="function">tint()</phrase></emphasis> in combination with additive blending to create a rainbow effect.</simpara>
</example>
<example id="chapter04_exercise14">
<title>Exercise 4.14</title>
<simpara>Try blending with other modes, such as: <emphasis role="strong"><phrase role="var">SUBTRACT</phrase></emphasis>, <emphasis role="strong"><phrase role="var">LIGHTEST</phrase></emphasis>, <emphasis role="strong"><phrase role="var">DARKEST</phrase></emphasis>, <emphasis role="strong"><phrase role="var">DIFFERENCE</phrase></emphasis>, <emphasis role="strong"><phrase role="var">EXCLUSION</phrase></emphasis>, <emphasis role="strong"><phrase role="var">MULTIPLY</phrase></emphasis>.</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 4 Exercise:</simpara>
<simpara>Take your creature from step 3 and build a system of creatures.   How can they interact with each other?  Can you use inheritance and polymorphism to create a variety of creatures, derived from the same code base?   Develop a methodology for how they compete for resources (for example, food).   Can you track a creature’s “health” much like we tracked a particle’s lifespan, removing creatures when appropriate?  What rules can you incorporate to control how creatures are born?</simpara>
<simpara>(Also, you might consider using a particle system itself in the design of a creature.  What happens if your emitter is tied to the creature’s location?)</simpara>
</tip>
</section>
</chapter>
<chapter id="_chapter_5_physics_libraries">
<title>Chapter 5.  Physics Libraries</title>
<blockquote>
<attribution>
Victor Hugo
</attribution>
<simpara>“A library implies an act of faith/Which generations still in darkness hid/Sign in their night in witness of the dawn.”</simpara>
</blockquote>
<simpara>Before we move on to anything else, let’s revisit some of the things we’ve done in the first four chapters. We have:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Learned about concepts from the world of physics — What is a vector? What is a force? What is a wave? etc.
</simpara>
</listitem>
<listitem>
<simpara>
Understood the math and algorithms behind such concepts.
</simpara>
</listitem>
<listitem>
<simpara>
Implemented the algorithms in Processing with an object-oriented approach.
</simpara>
</listitem>
</orderedlist>
<simpara>These activities have yielded a set of motion simulation examples, allowing us to creatively define the physics of the worlds we build (whether realistic or fantastical).  Of course, we aren’t the first to try this. The world of computer graphics and programming is full of source code dedicated to simulation. Just try Googling “open-source physics engine” and you could spend the rest of your day pouring through rich and complex code.    And so we must ask the question: If a code library will take care of physics simulation, why should we bother learning how to write any of the algorithms ourselves?</simpara>
<simpara>Here is where the philosophy behind this book comes into play.  While many of the libraries out there give us physics (and super awesome advanced physics at that) for free, there are significant reasons for learning the fundamentals from scratch before diving into libraries. First, without an understanding of vectors, forces, and trigonometry, we’d be completely lost just reading the documentation of a library.   Second, even though a library may take care of the math for us, it won’t necessarily simplify our code.  As we’ll see in a moment, there can be a great deal of overhead in simply understanding how a library works and what it expects from you code-wise.  Finally, as wonderful as a physics engine might be, if you look deep down into your hearts, it’s likely that you seek to create worlds and visualizations that stretch the limits of imagination. A library is great, but it provides a limited set of features. It’s important to know both when to live within limitations in the pursuit of a Processing project and when those limits prove to be confining.</simpara>
<simpara>This chapter is dedicated to examining two open-source physics libraries—Box2D and toxiclibs’ VerletPhysics engine.   With each library, we’ll evaluate its pros and cons and look at reasons why you might choose one of these libraries for a given project.</simpara>
<section id="chapter05_section1">
<title>5.1 What is Box2D and When Might I Use It?</title>
<simpara>Box2D began as a set of physics tutorials written in C++ by Erin Catto for the Game Developer’s Conference in 2006. Over the last five years it has evolved into an elaborate and rich open-source physics engine.   It’s been used for countless projects, most notably highly successful games such as the award-winning puzzle game Crayon Physics and the runaway mobile and tablet hit Angry Birds.</simpara>
<simpara>One of the key things to realize about Box2D is that it is a true physics engine.  Box2D knows nothing about computer graphics and the world of pixels; it is simply a library that takes in numbers and spits out more numbers. And what are those numbers?  Meters, kilograms, seconds, etc.  All of Box2D’s measurements and calculations are for real-world measurements, only its “world” is a two-dimensional plane with a top, bottom, left and right edge.  You tell it things like: “The world has a gravitational force of 9.5 Newtons, and a circle with a radius of four meters and a mass of fifty kilograms is located ten meters above the world’s bottom.”   Box2D will then tell you things like “One second later, the rectangle is at five meters from the bottom; two seconds later, it is ten meters below,” etc.  While this provides for an amazing and realistic physics engine, it also necessitates lots of complicated code in order to translate back and forth between the physics “world” (a key term in Box2D) and the world we want to draw on —the “pixel” world of Processing.</simpara>
<simpara>So when is it worth it to have this additional overhead?  If I just want to simulate a circle falling down a Processing window with gravity, do I really need to write all the extra Box2D code just to get that effect?  Certainly, the answer is no.  We saw how to do this rather easily in just the first chapter of this book.    Let’s consider another scenario.  What if I want to have a hundred of those circles falling?  And what if those circles aren’t circles at all—rather, irregularly shaped polygons?  And what if I want these polygons to bounce off each other in a realistic manner when they collide?</simpara>
<simpara>You may have noticed that the first four chapters of this book, while covering motion and forces in detail, has skipped over a rather important aspect of physics simulation—<emphasis>collisions</emphasis>.   Let’s pretend for a moment that you aren’t reading a chapter about libraries and that we decided right now to cover how to handle collisions in a particle system.   We’d have to evaluate and learn two distinct algorithms that address these questions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
How do I determine if two shapes are colliding (i.e. intersecting)?
</simpara>
</listitem>
<listitem>
<simpara>
How do I determine the shapes’ velocity after the collision?
</simpara>
</listitem>
</orderedlist>
<simpara>If we’re thinking about shapes like rectangles or circles, question #1 isn’t too tough.  You’ve likely encountered this before.  For example, we know two circles are intersecting if the distance between them is less than the sum of their radii.</simpara>
<informalfigure id="chapter05_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_01.png" />
  </imageobject>
  <textobject><phrase>Figure 5.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>OK. Now that we know how to determine if two circles are colliding, how do we calculate their velocities after the collision?   This is where we’re going to stop our discussion.   Why, you ask?  It’s not that understanding the math behind collisions isn’t important or valuable.  (In fact, I’m including additional examples on the web site related to collisions without a physics library.)  The reason for stopping is that life is short (let this also be a reason for you to consider going outside and frolicking instead of programming altogether.)  We can’t expect to master every detail of physics simulation.  And while we could continue this discussion for circles, it’s only going to lead us to wanting to work with rectangles.  And strangely shaped polygons.  And curved surfaces.  And swinging pendulums colliding with springy springs.  And and and and and.</simpara>
<simpara>Working with collisions in our Processing sketch while still having time to spend with our friends and family—that’s the reason for this chapter.   Erin Catto spent years developing solutions to these kinds of problems so you don’t need to engineer them yourselves, at least for now.</simpara>
<simpara>In conclusion, if you find yourself describing an idea for a Processing sketch and the word “collisions” comes up, then it’s likely time to learn Box2D.   (We’ll also encounter other words that might lead you down this path to Box2D, such as “joint”, “hinge”, “pulley”, “motor”, etc.)</simpara>
</section>
<section id="chapter05_section2">
<title>5.2 How do I get Box2D in Processing?</title>
<simpara>So, if Box2D is a physics engine that knows nothing about pixel-based computer graphics and is written in C++, how are we supposed to use it in Processing?</simpara>
<simpara>The good news is that Box2D is such an amazing and useful library that everyone wants to use it—Flash, Javascript, Python, Ruby programmers.  Oh, and Java programmers.  There is something called JBox2D, a Java port of Box2D.  And because Processing is built on top of Java, JBox2D can be used directly in Processing!</simpara>
<simpara>So here’s where we are so far.</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://www.box2d.org/">Box2D Site</ulink> for reference.
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://www.jbox2d.org/">JBox2D Site</ulink> for Processing compatibility.
</simpara>
</listitem>
</itemizedlist>
<simpara>This is all you need to get started writing Box2D code in Processing.  However, as we are going to see in a moment, there are several pieces of functionality we’ll repeatedly need in our Processing code, and so it’s worth having one additional layer between our sketches and JBox2D.  I’m calling this PBox2D—a Processing Box2d “helper” library included as part of this book’s code example downloads.</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/shiffman/PBox2D">PBox2D Github Repository</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>It’s important to realize that PBox2D is not a Processing wrapper for all of Box2D.   After all, Box2D is a thoughtfully organized and well-structured API and there’s no reason to take it apart and re-implement it.  However, it’s useful to have a small set of functions that help you get your Box2D world set up as well as help you figure out where to draw your Box2D shapes.  And this is what PBox2D will provide.</simpara>
<simpara>I should also mention before we move forward that there are other Processing libraries that wrap Box2D for you. One I would recommend taking a look at is <ulink url="http://www.ricardmarxer.com/fisica/">Fisica</ulink> by Ricard Marxer.</simpara>
</section>
<section id="chapter05_section3">
<title>5.3 Box2D Basics</title>
<simpara>Do not despair! We really are going to get to the code very soon, and in some ways we’ll blow our previous work out of the water.  But before we’re ready to do that, it’s important to walk through the overall process of using Box2D in Processing.   Let’s begin by writing a pseudocode generalization of all of our examples in Chapters 1 through 4.</simpara>
<simpara><emphasis role="strong"><emphasis>SETUP:</emphasis></emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Create all the objects in our world.
</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong"><emphasis>DRAW:</emphasis></emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Calculate all the forces in our world.
</simpara>
</listitem>
<listitem>
<simpara>
Apply all the forces to our objects (F = M * A).
</simpara>
</listitem>
<listitem>
<simpara>
Update the locations of all the objects based on their acceleration.
</simpara>
</listitem>
<listitem>
<simpara>
Draw all of our objects.
</simpara>
</listitem>
</orderedlist>
<simpara>Great.  Let’s rewrite this pseudocode as it will appear in our Box2D examples.</simpara>
<informalfigure id="chapter05_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_02.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 5.2: DELETE THIS FIGURE???</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><emphasis>SETUP:</emphasis></emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Create all the objects in our world.
</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong"><emphasis>DRAW:</emphasis></emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Draw all of our objects.
</simpara>
</listitem>
</orderedlist>
<simpara>This, of course, is the fantasy of Box2D.  We’ve eliminated all of those painful steps of figuring out how the objects are moving according to velocity and acceleration.  Box2D is going to take care of this for us!   The good news is that this does accurately reflect the overall process.  Let’s imagine Box2D as a magic box.</simpara>
<simpara>In <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>, we’re going to say to Box2D: “Hello there. Here are all of the things I want in my world.”  In <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, we’re going to politely ask Box2D: “Oh, hello again. If it’s not too much trouble, I’d like to draw all of those things in my world.  Could you tell me where they are?”</simpara>
<simpara>The bad news: it’s not as simple as the above explanation would lead you to believe.   For one, making the stuff that goes in the Box2D world involves wading through the documentation for how different kinds of shapes are built and configured.  Second, we have to remember that we can’t tell Box2D anything about pixels, as it will simply get confused and fall apart.  Before we tell Box2D what we want in our world, we have to convert our pixel units to Box2D “world” units.  And the same is true when it comes time to draw our stuff. Box2D is going to tell us the location of the things in its world, which we then have to translate for the pixel world.</simpara>
<informalfigure id="chapter05_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_03.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 5.3: DELETE THIS FIGURE???</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic"><title>SETUP</title>
<listitem>
<simpara>
Create everything that lives in our pixel world.
</simpara>
</listitem>
<listitem>
<simpara>
Translate the pixel world into the Box2D world.
</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic"><title>DRAW</title>
<listitem>
<simpara>
Ask Box2D where everything is.
</simpara>
</listitem>
<listitem>
<simpara>
Translate Box2D’s answer into the pixel world.
</simpara>
</listitem>
<listitem>
<simpara>
Draw everything.
</simpara>
</listitem>
</orderedlist>
<simpara>Now that we understand that anything we create in our Processing sketch has to be placed into the Box2D world, let’s look at an overview of the elements that make up that world.</simpara>
<orderedlist numeration="arabic"><title>Core Elements of a Box2D World:</title>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>World</emphasis></emphasis>: The Box2D “World” manages the physics simulation.  It knows everything about the overall coordinate space and also stores lists of every element in the world (see 2-4 below).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Body</emphasis></emphasis>: The primary element in the Box2D world. It has a location. It has a velocity. Sound familiar? The Body is essentially the class we’ve been writing on our own in our vectors and forces examples.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Shape</emphasis></emphasis>: Keeps track of all the necessary collision geometry attached to a Body.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Fixture</emphasis></emphasis>:  Attaches a Shape to a Body and sets properties such as density, friction, and restitution.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Joint</emphasis></emphasis>: A connection between two bodies (or between one body and the world itself).
</simpara>
</listitem>
</orderedlist>
<simpara>In the next four sections, we are going to walk through each of the above elements in detail, building several examples along the way.   But first there is one other important element we should briefly discuss.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Vec2</emphasis></emphasis>: A Box2D “Vec2” describes a vector in the Box2D world.
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong"><phrase role="notetoself">[manually make this #6, parser won&#8217;t catch that]</phrase></emphasis></simpara>
<simpara>And so here we are, arriving with trepidation at an unfortunate truth in the world of using physics libraries.   Any physics simulation is going to involve the concept of a vector.  This is the good part.  After all, we just spent several chapters familiarizing ourselves with what it means to describe motion and forces with vectors.   We don’t have to learn anything new conceptually.</simpara>
<simpara>Now the part that makes the single tear fall from my eye: we don’t get to use PVector. It’s nice that Processing has PVector for us, but anytime you use a physics library you will probably discover that the library includes its own vector implementation.  This makes sense, after all; why should Box2D be expected to know about PVector?   And in many cases, the physics engine will want to implement a vector class it in a specific way so that it is especially compatible with the rest of the library’s code.   So while we don’t have to learn anything new conceptually, we do have to get used to some new naming conventions and syntax.  Let’s quickly demonstrate a few of the basics in <emphasis role="strong"><phrase role="klass">Vec2</phrase></emphasis> as compared to those in <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis>.</simpara>
<simpara>Let’s say we want to add two vectors together.</simpara>
<passthrough><table class="code">
<tr>
<th>PVector</th>
<th>Vec2</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
a.addLocal(b);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
Vec2 c = a.add(b);
</pre>
</td>
</tr>
</table></passthrough>
<simpara>How about if we want to multiply and scale them?</simpara>
<passthrough><table class="code">
<tr>
<th>PVector</th>
<th>Vec2</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float n = 5;
a.mult(n);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
a.mulLocal(n);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float n = 5;
PVector c = PVector.mult(a,n);
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
Vec2 c = a.mul(n);
</pre>
</td>
</tr>
</table></passthrough>
<simpara>Magnitude and normalize?</simpara>
<passthrough><table class="code">
<tr>
<th>PVector</th>
<th>Vec2</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();
</pre>
</td>
<td>
<pre>
Vec2 a = new Vec2(1,-1);
float m = a.length();
a.normalize();
</pre>
</td>
</tr>
</table></passthrough>
<simpara>As you can see, the concepts are the same, but the function names and the arguments are slightly different.  For example, instead of static and non-static <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">mult()</phrase></emphasis>, if a <emphasis role="strong"><phrase role="klass">Vec2</phrase></emphasis> is altered, the word “local” is included in the function name—<emphasis role="strong"><phrase role="function">addLocal()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">multLocal()</phrase></emphasis>.</simpara>
<simpara>We’ll cover the basics of what you need to know here, but if you are looking for more, full documentation of <emphasis role="strong"><phrase role="klass">Vec2</phrase></emphasis> can be found by downloading the <ulink url="http://code.google.com/p/jbox2d/">JBox2D Source</ulink>.</simpara>
</section>
<section id="chapter05_section4">
<title>5.4 Living in a Box2D World</title>
<simpara>The Box2D “World” object is in charge of everything. It manages the coordinate space of the world, all of the stuff that lives in the world, and decides when time moves forward in the world.</simpara>
<simpara>In order to have Box2D as part of our Processing sketches, the “World” is the very first thing that needs to be set up.  Here is where PBox2D comes in handy and takes care of making the world for us.</simpara>
<programlisting language="java" linenumbering="unnumbered">PBox2D box2d;

void setup() {
  box2d = new PBox2D(this);
  // Initializes a Box2D world with default settings
  box2d.createWorld();
}</programlisting>
<simpara>When you call <emphasis role="strong"><phrase role="function">createWorld()</phrase></emphasis>, PBox2D will set up a default gravity for you (pointing down); however, you can always alter the gravity of your world by saying:</simpara>
<programlisting language="java" linenumbering="unnumbered">  box2d.setGravity(0, -10);</programlisting>
<simpara>It’s worth noting that gravity doesn’t have to be fixed, nor does it always have to point downwards; you can adjust the gravity vector while your program is running.  Gravity can be turned off by setting it to a (0,0) vector.</simpara>
<simpara>So, what are those numbers 0 and -10?   This should remind us of one of the most important details of using Box2D: the Box2D coordinate system is not your pixel coordinate system!   Let’s look at how Box2D and a Processing window think differently of their worlds.</simpara>
<informalfigure id="chapter05_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_04.png" />
  </imageobject>
  <textobject><phrase>Figure 5.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice how in Box2D (0,0) is in the center and up is the positive direction along the y-axis!   Box2D’s coordinate system is just like that lovely old-fashioned Cartesian coordinate system you might have learned about in a high school geometry class.  Processing, on the other hand, uses a traditional computer graphics coordinate system where (0,0) is in the top left corner and down is the positive direction along the y-axis.  This is why if we want gravity to point down, we need to give Box2D a vector with a negative y-value.</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2 gravity = new Vec2(0, -10);</programlisting>
<simpara>Luckily for us, if we prefer to think in terms of pixel coordinates (which as Processing programmers, we are likely to do), PBox2D offers a series of helper functions that convert between pixel space and Box2D space.  Before we move onto the next section and look at creating Box2D bodies, let’s take a look at how these helper functions work.</simpara>
<simpara>Let’s say we want to tell Box2D where the mouse is in its world.  We know the mouse is located at <emphasis role="strong"><phrase role="var">(mouseX,mouseY)</phrase></emphasis> in Processing.  To convert it we say we want to convert a “coordinate” from “pixels” to “world”—<emphasis role="strong"><phrase role="function">coordPixelsToWorld()</phrase></emphasis>.  Or:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Convert mouseX,mouseY to
// coordinate in Box2D world
Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);</programlisting>
<simpara>What if we had a Box2D world coordinate and wanted to translate it to our pixel space?</simpara>
<programlisting language="java" linenumbering="unnumbered">// To demonstrate, let’s just make up a world position.
Vec2 worldPos = new Vec2(-10,25);

// Convert to pixel space
// This is necessary because ultimately we
// are going to want to draw the elements in our window
Vec2 pixelPos = box2d.coordWorldToPixels(worldPos);
ellipse(pixelPos.x, pixelPos.y,16,16);</programlisting>
<simpara>PBox2D has a set of functions to take care of translating back and forth between the Box2D world and pixels.  It’s probably easier to learn about all of these functions during the course of actually implementing our examples, but let’s quickly look over the list of the possibilities.</simpara>
<passthrough><table class="code">
<tr>
<th>Task</th>
<th>Function</th>
</tr>
<tr>
<td>Convert location from World to Pixels</td>
<td><pre>Vec2 coordWorldToPixels(Vec2 world)</pre></td>
</tr>
<tr>
<td>Convert location from World to Pixels</td>
<td><pre>Vec2 coordWorldToPixels(float worldX, float worldY)</pre></td>
</tr>
<tr>
<td>Convert location from Pixels to World</td>
<td><pre>Vec2 coordPixelsToWorld(Vec2 screen)</pre></td>
</tr>
<tr>
<td>Convert location from Pixels to World</td>
<td><pre>Vec2 coordPixelsToWorld(float pixelX, float pixelY)</pre></td>
</tr>

<tr>
<td>Scale a dimension (such as height, width, or radius) from Pixels to World</td>
<td><pre>float scalarPixelsToWorld(float val)</pre></td>
</tr>

<tr>
<td>Scale a dimension from World to Pixels</td>
<td><pre>float scalarWorldToPixels(float val)</pre></td>
</tr>

</table></passthrough>
<simpara>There are also additional functions that allow you to pass or receive a PVector when translating back and forth, but since we are only working with Box2D in the examples in this chapter, it’s easiest to stick with the Vec2 class for all vectors.</simpara>
<simpara>Once the world is initialized, we are ready to actually put stuff in the world—Box2D bodies.</simpara>
</section>
<section id="chapter05_section5">
<title>5.5 Building a Box2D Body</title>
<simpara>A Box2D body is the primary element in the Box2D world.  It’s the equivalent to the “Mover” class we built on our own in previous chapters—the thing that moves around the space and experiences forces. It can also be static (meaning fixed and not moving). It’s important to note, however, that a Body has no geometry; it isn’t anything physical.   Rather, bodies have Box2D Shapes attached to them (this way, a Body can be a single rectangle or a rectangle attached to a circle, etc.) We’ll look at Shapes in a moment; first, let’s build a Body.</simpara>
<section id="_step_1_define_a_body">
<title>Step 1:  Define a Body.</title>
<simpara>The first thing we have to do is create a “Body Definition.” This will let us define the properties of the Body we intend to make.  This may seem a bit awkward at first, but it’s how Box2D is structured.  Anytime you want to make a “thing,” you have to make a “thing definition” first.  This will hold true for bodies, shapes, and joints.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Make a Body Definition before making a Body.
BodyDef bd = new BodyDef();</programlisting>
</section>
<section id="_step_2_configure_the_body_definition">
<title>Step 2:  Configure the Body Definition.</title>
<simpara>The Body Definition is where we can set specific properties or attributes of the Body we intend to make.  One attribute of a Body, for example, is its starting location.  Let’s say we want to position the Body in the center of the Processing window.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A Vec2 in the center of the Processing window
Vec2 center = new Vec2(width/2,height/2);</programlisting>
<simpara>Danger, danger!  I’m not going to address this with every single example, but it’s important to at least point out the perilous path we are taking with the above line of code.  Remember, if we are going to tell Box2D where we want the Body to start, we must give Box2D a world coordinate!  Yes, we want to think of its location in terms of pixels, but Box2D doesn’t care.  And so before we pass that position to the Body Definition, we must make sure to use one of our helper conversion functions.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A Vec2 in the center of the
// Processing window converted to Box2D World coordinates!
Vec2 center = box2d.coordPixelsToWorld(width/2,height/2));
// Setting the position attribute of the Box2D Body Definition
bd.position.set(center);</programlisting>
<simpara>The Body definition must also specify the “type” of Body we want to make.  There are three possibilities:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Dynamic.</emphasis></emphasis>  This is what we will use most often—a “fully simulated” body.  A dynamic body moves around the world, collides with other bodies, and responds to the forces in its environment.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Static.</emphasis></emphasis> A static body is one that cannot move (as if it had an infinite mass).  We’ll use static bodies for fixed platforms and boundaries.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Kinematic.</emphasis></emphasis>  A kinematic body can be moved manually by setting its velocity directly.  If you have a user-controlled object in your world, you can use a kinematic body.   Note that kinematic bodies collide only with dynamic bodies and not other static or kinematic ones.
</simpara>
</listitem>
</itemizedlist>
<simpara>There are several other properties you can set in the Body definition.  For example, if you want to body to have a fixed rotation (i.e. never rotate) you can say:</simpara>
<programlisting language="java" linenumbering="unnumbered">bd.fixedRotation = true;</programlisting>
<simpara>You can also set a value for linear or angular damping, so that the object continuously slows as if there is friction.</simpara>
<programlisting language="java" linenumbering="unnumbered">bd.linearDamping = 0.8;
bd.angularDamping = 0.9;</programlisting>
<simpara>In addition, fast-moving objects in Box2D should be set as bullets.  This tells the Box2D engine that the object may move very quickly and to check its collisions more carefully so that it doesn’t accidentally jump over another body.</simpara>
<programlisting language="java" linenumbering="unnumbered">bd.bullet = true;</programlisting>
</section>
<section id="_step_3_create_the_body">
<title>Step 3:  Create the Body.</title>
<simpara>Once we’re done with the definition (BodyDef), we can create the Body object itself.  PBox2D provides a helper function for this—<emphasis role="strong"><phrase role="function">createBody</phrase></emphasis>().</simpara>
<programlisting language="java" linenumbering="unnumbered">// The Body object is created by passing in the Body
// Definition. (This allows for making multiple bodies from
// one definition.)
Body body = box2d.createBody(bd);</programlisting>
</section>
<section id="_step_4_set_any_other_conditions_for_the_body_s_starting_state">
<title>Step 4:  Set any other conditions for the Body’s starting state.</title>
<simpara>Finally, though not required, if you want to set any other initial conditions for the Body, such as linear or angular velocity, you can do so with the newly created Body object.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Setting an arbitrary initial velocity
body.setLinearVelocity(new Vec2(0,3));
// Setting an arbitrary initial angular velocity
body.setAngularVelocity(1.2);</programlisting>
</section>
</section>
<section id="chapter05_section6">
<title>5.6 Three’s Company: Bodies and Shapes and Fixtures</title>
<simpara>A Body on its own doesn’t physically exist in the world. It’s like a soul with no human form to inhabit. For a Body to have mass, we must first define a Shape and attach that Shape to the Body with something known as a Fixture.</simpara>
<simpara>The job of a Box2D Shape is to keep track of all the necessary collision geometry attached to a Body.  A Shape also has several important properties that affect the Body’s motion.  There is density, which ultimately determines that Body’s mass.  Shapes also have <emphasis>friction</emphasis> and <emphasis>restitution</emphasis> (“bounciness”) which will be defined through a Fixture. One of the nice things about Box2D’s methodology, which separates the concepts of Bodies and Shapes into two separate objects, is that you can attach multiple shapes to a single Body in order to create more complex forms.  We’ll see this in a future example.</simpara>
<simpara>To create a Shape, we need to first decide what kind of shape we want to make.  For most non-circular shapes, a PolygonShape will work just fine. For example, let’s look at how we define a rectangle.</simpara>
<section id="_step_1_define_a_shape">
<title>Step 1:  Define a Shape.</title>
<programlisting language="java" linenumbering="unnumbered">// Define the shape: a polygon
PolygonShape ps = new PolygonShape();</programlisting>
<simpara>Next up, we have to define the width and height of the rectangle. Let’s say we want our rectangle to be 150×100 pixels. Remember, pixel units are no good for Box2D shapes! So we have to use our helper functions to convert them first.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Scale dimensions from pixels to Box2D world.
float box2Dw = box2d.scalarPixelsToWorld(150);
float box2Dh = box2d.scalarPixelsToWorld(100);

// Use setAsBox() function to define shape as a rectangle.
ps.setAsBox(box2Dw, box2Dh);</programlisting>
</section>
<section id="_step_2_create_a_fixture">
<title>Step 2:  Create a Fixture.</title>
<simpara>The Shape and and Body are made as two separate entities.  In order to attach a Shape to a Body, we must make a Fixture.   A fixture is created, just as with the Body, via a FixtureDef (i.e. Fixture definition) and assigned a Shape.</simpara>
<programlisting language="java" linenumbering="unnumbered">FixtureDef fd = new FixtureDef();
// The fixture is assigned the PolygonShape we just made.
fd.shape = ps;</programlisting>
<simpara>Once we have the Fixture Definition, we can set parameters that affect the physics for the Shape being attached.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The coefficient of friction for the
// shape, typically between 0 and 1
fd.friction = 0.3;
// The Shape’s restitution (i.e. elasticity),
// typically between 0 and 1
fd.restitution = 0.5;
// The Shape’s density, measured in
// kilograms per meter squared
fd.density = 1.0;</programlisting>
</section>
<section id="_step_3_attach_the_shape_to_the_body_with_the_fixture">
<title>Step 3:  Attach the Shape to the Body with the Fixture.</title>
<simpara>Once the Fixture is defined, all we have left to do is attach the Shape to the Body with the Fixture by calling the <emphasis role="strong"><phrase role="function">createFixture()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Creates the Fixture and attaches the Shape to the Body object
body.createFixture(fd);</programlisting>
<simpara>I should note that Step 2 can be skipped if you do not need to set the physics properties (Box2D will use default values.)  You can create a Fixture and attach the Shape all in one step by saying:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Creates the Fixture and attaches the Shape with a density of 1
body.createFixture(ps,1);</programlisting>
<simpara>While most of our examples will take care of attaching Shapes only once when the Body is first built, this is not a limitation of Box2D.   Box2D allows for Shapes to be created and destroyed on the fly.</simpara>
<simpara>Before we put any of this code we’ve been writing into a Processing sketch, let’s review all the steps we took to construct a Body.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Define a Body using BodyDef (set any properties, such as location).
</simpara>
</listitem>
<listitem>
<simpara>
Create the Body from the Body Definition.
</simpara>
</listitem>
<listitem>
<simpara>
Define a Shape using PolygonShape, CircleShape, or any other Shape class.
</simpara>
</listitem>
<listitem>
<simpara>
Define a Fixture using FixtureDef and assign the Fixture a Shape (set any properties, such as friction, density, and restitution).
</simpara>
</listitem>
<listitem>
<simpara>
Attach the Shape to the Body.
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">// Step 1. Define the Body.
BodyDef bd = new BodyDef();
bd.position.set(box2d.coordPixelsToWorld(width/2,height/2));

// Step 2. Create the Body.
Body body = box2d.createBody(bd);

// Step 3. Define the Shape.
PolygonShape ps = new PolygonShape();
float w = box2d.scalarPixelsToWorld(150);
float h = box2d.scalarPixelsToWorld(100);
ps.setAsBox(w, h);

// Step 4. Define the Fixture.
FixtureDef fd = new FixtureDef();
fd.shape = ps;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

// Step 5. Attach the Shape to the Body with the Fixture.
body.createFixture(fd);</programlisting>
<example id="chapter05_exercise1">
<title>Exercise 5.1</title>
<simpara>Knowing what you know about Box2D so far, fill in the blank in the code below that demonstrates how to make a circular shape in Box2D.</simpara>
<programlisting language="java" linenumbering="unnumbered">CircleShape cs = new CircleShape();
float radius = 10;
cs.m_radius = ____________________;
FixtureDef fd = new FixtureDef();
fd.shape = cs;
fd.density = 1;
fd.friction = 0.1;
fd.restitution = 0.3;

body.createFixture(fd);</programlisting>
</example>
</section>
</section>
<section id="chapter05_section7">
<title>5.7  Box2D and Processing: Reunited and It Feels So Good</title>
<simpara>Once a Body is made, it lives in the Box2D physics world. Box2D will always know it’s there, check it for collisions, move it appropriately according to the forces, etc. It’ll do all that for you without you having to lift a finger! What it won’t do, however, is display the Body for you. This is a good thing. This is your time to shine. When working with Box2D, what we’re essentially saying is, “I want to be the designer of my world, and I want you, Box2D, to compute all the physics.”</simpara>
<simpara>Now, Box2D will keep a list of all the Bodies that exist in the world. This can be accessed by calling the World object’s getBodyList() function. Nevertheless, what I’m going to demonstrate here is a technique for keeping your own Body lists. Yes, this may be a bit redundant and we perhaps sacrifice a bit of efficiency. But we more than make up for that with ease of use. This methodology will allow us to program like we’re used to in Processing, and we can easily keep track of which Bodies are which and render them appropriately. Let’s consider the structure of the following Processing sketch:</simpara>
<informalfigure id="chapter05_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_05.png" />
  </imageobject>
  <textobject><phrase>Figure 5.5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This looks like any ol’ Processing sketch. We have a main tab called “Boxes” and a “Boundary” and “Box” tab. Let’s think about the Box tab for a moment. The Box tab is where we will write a simple class to describe a Box object, a rectangular body in our world.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Box  {

  // Our Box object has an x,y location and a width and a height.
  float x,y;
  float w,h;

  Box() {
    // Our Box object starts at the mouse location.
    x = mouseX;
    y = mouseY;
    w = 16;
    h = 16;
  }

  void display() {
    // We draw the Box object using Processing’s rect() function.
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }
}</programlisting>
<simpara>Let’s write a main tab that creates a new Box whenever the mouse is pressed and stores all the Box objects in an ArrayList.  (This is very similar to our approach in the particle system examples from Chapter 4.)</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex01.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example1"><emphasis role="strong"><phrase role="example">Example 5.1: A Comfortable and Cozy Processing Sketch That Needs a Little Box2D</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// A list to store all Box objects
ArrayList&lt;Box&gt; boxes;

void setup() {
  size(400,300);
  boxes = new ArrayList&lt;Box&gt;();
}

void draw() {
  background(255);

  // When the mouse is pressed, add a new Box object.
  if (mousePressed) {
    Box p = new Box(mouseX,mouseY);
    boxes.add(p);
  }

  // Display all the Box objects.
  for (Box b: boxes) {
    b.display();
  }
}</programlisting>
<simpara>Now, here’s our assignment. Take the above example verbatim, but instead of drawing fixed boxes on the screen, draw boxes that experience physics (via Box2D) as soon as they appear.</simpara>
<simpara>We’ll need two major steps to accomplish our goal.</simpara>
<section id="_step_1_add_box2d_to_our_main_program_i_e_setup_and_draw">
<title>Step 1: Add Box2D to our main program (i.e. setup() and draw()).</title>
<simpara>This part is not too tough.  We saw this already in our discussion of building a Box2D world.  This is taken care of for us by the PBox2D helper class.  We can create a PBox2D object and initialize it in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">PBox2D box2d;

void setup() {
  // Initialize and create the Box2D world.
  box2d = new PBox2D(this);
  box2d.createWorld();
}</programlisting>
<simpara>Then in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, we need to make sure we call one very important function: <emphasis role="strong"><phrase role="function">step()</phrase></emphasis>. Without this function, nothing would ever happen! <emphasis role="strong"><phrase role="function">step()</phrase></emphasis> advances the Box2D world a step further in time. Internally, Box2D sweeps through and looks at all of the Bodies and figures out what to do with them. Just calling <emphasis role="strong"><phrase role="function">step()</phrase></emphasis> on its own moves the Box2D world forward with default settings; however, it is customizable (and this is documented in the PBox2D source).</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  // We must always step through time!
  box2d.step();
}</programlisting>
</section>
<section id="_step_2_link_every_processing_box_object_with_a_box2d_body_object">
<title>Step 2: Link every Processing Box object with a Box2D Body object.</title>
<simpara>As of this moment, the Box class includes variables for location and width and height.  What we now want to say is:</simpara>
<simpara>“I hereby relinquish the command of this object’s position to Box2D.  I no longer need to keep track of anything related to location, velocity, and acceleration.  Instead, I only need to keep track of a Box2D body and have faith that Box2D will do the rest.”</simpara>
<programlisting language="java" linenumbering="unnumbered">class Box  {

  // Instead of any of the usual variables,
  // we will store a reference to a Box2D Body.
  Body body;
  float w;
  float h;</programlisting>
<simpara>We don’t need (x,y) anymore since, as we’ll see, the Body itself will keep track of its location.   The Body technically could also keep track of the width and height for us, but since Box2D isn’t going to do anything to alter those values over the life of the Box object, we might as well just hold onto them ourselves until it’s time to draw the Box.</simpara>
<simpara>Then, in our constructor, in addition to initializing the width and height, we can go ahead and include all of the Body and Shape code we learned in the previous two sections!</simpara>
<programlisting language="java" linenumbering="unnumbered">  Box() {
    w = 16;
    h = 16;

    // Build Body
    BodyDef bd = new BodyDef();
    bd.position.set(box2d.coordPixelsToWorld(mouseX,mouseY));
    body = box2d.createBody(bd);


    // Build Shape
    PolygonShape ps = new PolygonShape();
    float box2dW = box2d.scalarPixelsToWorld(w/2);

    // Box2D considers the width and height of a
    // rectangle to be the distance from the
    // center to the edge (so half of what we
    // normally think of as width or height).
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    ps.setAsBox(box2dW, box2dH);

    FixtureDef fd = new FixtureDef();
    fd.shape = ps;
    fd.density = 1;
    // Set physics parameters.
    fd.friction = 0.3;
    fd.restitution = 0.5;

    // Attach the Shape to the Body with the Fixture.
    body.createFixture(fd);
 }</programlisting>
<simpara>OK, we’re almost there. Before we introduced Box2D, it was easy to draw the Box. The object’s location was stored in variables x and y.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Drawing the object using rect()
  void display() {
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }</programlisting>
<simpara>But now Box2D manages the object’s motion. So we can no longer use our own variables to display the shape. But not to fear! Our Box object has a reference to the Box2D Body associated with it. So all we need to do is politely ask the Body, “Pardon me, where are you located?” Since this is a task we’ll need to do quite often, PBox2D includes a helper function: <emphasis role="strong"><phrase role="function">getBodyPixelCoord()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2 pos = box2d.getBodyPixelCoord(body);</programlisting>
<simpara>Just knowing the location of a Body isn’t enough; we also need to know its angle of rotation.</simpara>
<programlisting language="java" linenumbering="unnumbered">float a = body.getAngle();</programlisting>
<simpara>Once we have the location and angle, it’s easy to display the object using translate and rotate.  Note, however, that the Box2D coordinate system considers rotation in the opposite direction from Processing, so we need to multiply the angle by -1.</simpara>
<informalfigure id="chapter05_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_06.png" />
  </imageobject>
  <textobject><phrase>Figure 5.6</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    // We need the Body’s location and angle.
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    pushMatrix();
    // Using the Vec2 position and float angle
    // to translate and rotate the rectangle
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(0,0,w,h);
    popMatrix();
  }</programlisting>
<simpara>In case we want to have objects that can be removed from the Box2D world, it’s also useful to include a function to destroy a Body, such as:</simpara>
<programlisting language="java" linenumbering="unnumbered">  // This function removes a Body from the Box2D world.
  void killBody() {
    box2d.destroyBody(body);
  }</programlisting>
<example id="chapter05_exercise2">
<title>Exercise 5.2</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc02.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the code downloads for this chapter, find the sketch named “box2d_exercise.”  Using the methodology outlined in this chapter, add the necessary code to the main and Box tabs to implement Box2D physics.  The result should appear as in the screenshot above.   Be more creative in how you render the boxes.</simpara>
</example>
</section>
</section>
<section id="chapter05_section8">
<title>5.8  Fixed Box2D Objects</title>
<simpara>In the example we just created, the Box objects appear at the mouse location and fall downwards due to Box2D’s default gravity force.  What if we wanted to install some immovable boundaries in the Box2D world that would block the path of the Box objects (as in the illustration below)?</simpara>
<simpara>￼Box2D makes this easy for us by providing a means to lock a Body (and any associated Shapes) in place.   Just set the BodyDef type to STATIC.</simpara>
<programlisting language="java" linenumbering="unnumbered"> BodyDef bd = new BodyDef();
 // When BodyDef type = STATIC, the
 // Body is locked in place.
 bd.type = BodyType.STATIC;</programlisting>
<simpara>We can add this feature to our Boxes example by writing a class called “Boundary” and having each Boundary object create a fixed Box2D body.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex02.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example2"><emphasis role="strong"><phrase role="example">Example 5.2: Falling boxes hitting boundaries</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Boundary {

  // A boundary is a simple rectangle with x,y,width,and height.
  float x,y;
  float w,h;
  Body b;

  Boundary(float x_,float y_, float w_, float h_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;

    // Build the Box2D Body and Shape.
    BodyDef bd = new BodyDef();
    bd.position.set(box2d.coordPixelsToWorld(x,y));
    // Make it fixed by setting type to STATIC!
    bd.type = BodyType.STATIC;
    b = box2d.createBody(bd);

    float box2dW = box2d.scalarPixelsToWorld(w/2);
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    PolygonShape ps = new PolygonShape();

    // Using the createFixture() shortcut
    b.createFixture(ps,1);
  }

  // Since we know it can never move, we can just draw it
  // the old-fashioned way, using our original
  // variables. No need to query Box2D.
  void display() {
    fill(0);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }

}</programlisting>
</section>
<section id="chapter05_section9">
<title>5.9  A Curvy Boundary</title>
<simpara>If you want a fixed boundary that is a curved surface (as opposed to a polygon), this can be achieved with the Shape <emphasis role="strong"><phrase role="klass">ChainShape</phrase></emphasis>.</simpara>
<simpara>The <emphasis role="strong"><phrase role="klass">ChainShape</phrase></emphasis> is another Shape like <emphasis role="strong"><phrase role="klass">PolygonShape</phrase></emphasis> or <emphasis role="strong"><phrase role="klass">CircleShape</phrase></emphasis>, so to include one in our system, we follow the same steps.</simpara>
<section id="_step_1_define_a_body_2">
<title>Step 1: Define a Body.</title>
<programlisting language="java" linenumbering="unnumbered">// The Body does not need a position; the
// EdgeShape will take care of that for us.
// It also does not need a type as it is STATIC
// by default.
BodyDef bd = new BodyDef();
Body body = box2d.world.createBody(bd);</programlisting>
</section>
<section id="_step_2_define_the_shape">
<title>Step 2: Define the Shape.</title>
<programlisting language="java" linenumbering="unnumbered">ChainShape chain = new ChainShape();</programlisting>
</section>
<section id="_step_3_configure_the_shape">
<title>Step 3: Configure the Shape.</title>
<simpara>The <emphasis role="strong"><phrase role="klass">ChainShape</phrase></emphasis> is a series of connected vertices.  To create the chain, we must first specify an array of vertices (each as a <emphasis role="strong"><phrase role="klass">Vec2</phrase></emphasis> object).  For example, if we wanted a straight line from the left-hand side of our window to the right-hand side, we would just need an array of two vertices: (0,150) and (width,150).  (Note that if you want to create a loop where the first vertex connects to the last vertex in a loop you can use the <emphasis role="strong"><phrase role="klass">ChainLoop</phrase></emphasis> class instead.)</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2[] vertices = new Vec2[2];
// Adding a vertex on the right side of window
vertices[0] = box2d.coordPixelsToWorld(0,150);
// Adding a vertex on the left side of window
vertices[1] = box2d.coordPixelsToWorld(width,150);</programlisting>
<simpara>To create the chain with the vertices, the array is then passed into a function called <emphasis role="strong"><phrase role="function">createChain()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">// If you don’t want to use the entire array,
// you can specify a value less than length.
chain.createChain(vertices, vertices.length);</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex03.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section id="_step_4_attach_the_shape_to_the_body_with_a_fixture">
<title>Step 4: Attach the Shape to the Body with a Fixture.</title>
<simpara>A Shape is not part of Box2D unless it is attached to a Body.  Even if it is a fixed boundary and never moves, it must still be attached.  Just as with other shapes, the ChainShape can be given properties like restitution and friction with a Fixture.</simpara>
<programlisting language="java" linenumbering="unnumbered">FixtureDef fd = new FixtureDef();
// A fixture assigned to the ChainShape
fd.shape = chain;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

body.createFixture(fd);</programlisting>
<simpara>Now, if we want to include an ChainShape in our sketch, we can follow the same strategy as we did with a fixed boundary.  Let’s write a class called Surface:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex04.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example3"><emphasis role="strong"><phrase role="example">Example 5.3: ChainShape with three hard-coded vertices</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Surface {
  ArrayList&lt;Vec2&gt; surface;

  Surface() {

    surface = new ArrayList&lt;Vec2&gt;();
    // 3 vertices in pixel coordinates
    surface.add(new Vec2(0, height/2+50));
    surface.add(new Vec2(width/2, height/2+50));
    surface.add(new Vec2(width, height/2));

    ChainShape chain = new ChainShape();

    // Make an array of Vec2 for the ChainShape.
    Vec2[] vertices = new Vec2[surface.size()];
    for (int i = 0; i &lt; vertices.length; i++) {
      // Convert each vertex to Box2D World coordinates
      vertices[i] = box2d.coordPixelsToWorld(surface.get(i));
    }

    // Create the ChainShape with array of Vec2
    chain.createChain(vertices, vertices.length);

    // Attach the Shape to the Body
    BodyDef bd = new BodyDef();
    Body body = box2d.world.createBody(bd);

    body.createFixture(chain, 1);
  }</programlisting>
<simpara>Notice how the above class includes an <emphasis role="strong"><phrase role="klass">ArrayList</phrase></emphasis> to store a series of <emphasis role="strong"><phrase role="klass">Vec2</phrase></emphasis> objects.   Even though we fully intend to store the coordinates of the chain in the ChainShape itself, we are choosing the ease of redundancy and keeping our own list of those points as well.  Later, when we go to draw the ChainShape, we don’t have to ask Box2D for the locations of the vertices.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    strokeWeight(1);
    stroke(0);
    noFill();
    beginShape();
    for (Vec2 v: surface) {
      // Draw the ChainShape as a series of vertices.
      vertex(v.x,v.y);
    }
    endShape();
  }
}</programlisting>
<simpara>What we need in the main tab for our Surface object is quite simple, given that Box2D takes care of all of the physics for us.</simpara>
<programlisting language="java" linenumbering="unnumbered">PBox2D box2d;

Surface surface;

void setup() {
  size(500,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  // Make a Surface object.
  surface = new Surface();
}

void draw() {
  box2d.step();

  background(255);
  // Draw the Surface.
  surface.display();
}</programlisting>
<example id="chapter05_exercise3">
<title>Exercise 5.3</title>
<simpara>Review how we learned to draw a wave pattern in Chapter 3.  Create a ChainShape out of a sine wave.  Try using Perlin noise (see <link linkend="intro_section6">Introduction</link>) as well.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc03a.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Sine Wave</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc03b.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Perlin Noise</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/blank.png" />
  </imageobject>
  <textobject><phrase>imgs/blank.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
</section>
<section id="chapter05_section10">
<title>5.10  Complex Forms</title>
<informalfigure id="chapter05_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_07.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 5.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now that we’ve seen how easy it is to make simple geometric forms in Box2D, let’s imagine that you want to have a more complex form, such as a little alien stick figure.  ￼</simpara>
<simpara>There are two strategies in Box2D for making forms that are more advanced than a basic circle or square.   One is to use a <emphasis role="strong"><phrase role="klass">PolygonShape</phrase></emphasis> in a different way.  In our previous examples, we used <emphasis role="strong"><phrase role="klass">PolygonShape</phrase></emphasis> to generate a rectangular shape with the <emphasis role="strong"><phrase role="function">setAsBox()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PolygonShape ps = new PolygonShape();
  ps.setAsBox(box2dW, box2dH);</programlisting>
<simpara>This was a good way to start because of the inherent simplicity of working with rectangles.  However, <emphasis role="strong"><phrase role="klass">PolygonShape</phrase></emphasis> can also be generated from a array of vectors, which allows you to build a completely custom shape as a series of connected vertices.  This works very similarly to <emphasis role="strong"><phrase role="klass">ChainShape</phrase></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex05.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example4"><emphasis role="strong"><phrase role="example">Example 5.4: Polygon shapes</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2[] vertices = new Vec2[4];  // An array of 4 vectors
vertices[0] = box2d.vectorPixelsToWorld(new Vec2(-15, 25));
vertices[1] = box2d.vectorPixelsToWorld(new Vec2(15, 0));
vertices[2] = box2d.vectorPixelsToWorld(new Vec2(20, -15));
vertices[3] = box2d.vectorPixelsToWorld(new Vec2(-10, -10));

// Making a polygon from that array
PolygonShape ps = new PolygonShape();
ps.set(vertices, vertices.length);</programlisting>
<simpara>When building your own polygon in Box2D, you must remember two important details.</simpara>
<informalfigure id="chapter05_figure08">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_08.png" classname="half-width-left" />
  </imageobject>
  <textobject><phrase>Figure 5.8</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Order of vertices!  If you are thinking in terms of pixels (as above) the vertices should be defined in counterclockwise order.  (When they are translated to Box2D world vectors, they will actually be in clockwise order since the vertical axis is flipped.)
</simpara>
</listitem>
<listitem>
<simpara>
Convex shapes only!  A concave shape is one where the surface curves inward. Convex is the opposite (see illustration below).  Note how in a concave shape every internal angle must be 180 degrees or less.  Box2D is not capable of handling collisions for “concave” shapes.  If you need a concave shape, you will have to build one out of multiple convex shapes (more about that in a moment).
</simpara>
</listitem>
</orderedlist>
<informalfigure id="chapter05_figure09">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_09.png" />
  </imageobject>
  <textobject><phrase>Figure 5.9: A concave shape can be drawn with multiple convex shapes.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now, when it comes time to display the shape in Processing, we can no longer just use <emphasis role="strong"><phrase role="function">rect()</phrase></emphasis> or <emphasis role="strong"><phrase role="function">ellipse()</phrase></emphasis>.  Since the shape is built out of custom vertices, we’ll want to use Processing’s <emphasis role="strong"><phrase role="function">beginShape()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">endShape()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">vertex()</phrase></emphasis> functions.   As we saw with the ChainShape, we could choose to store the pixel locations of the vertices in our own ArrayList for drawing.  However, it’s also useful to see how we can ask Box2D to report back to use the vertex locations.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    // First we get the Fixture attached to the Body...
    Fixture f = body.getFixtureList();
    // ...then the Shape attached to the Fixture.
    PolygonShape ps = (PolygonShape) f.getShape();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    beginShape();
    // We can loop through that array and
    // convert each vertex from Box2D
    // space to pixels.
    for (int i = 0; i &lt; ps.getVertexCount(); i++) {
      Vec2 v = box2d.vectorWorldToPixels(ps.getVertex(i));
      vertex(v.x,v.y);
    }
    endShape(CLOSE);
    popMatrix();
  }</programlisting>
<example id="chapter05_exercise4">
<title>Exercise 5.4</title>
<simpara>Using PolygonShape, create your own Polygon design (remember, it must be concave).  Some possibilities below.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc04.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc04.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara>A polygon shape will get us pretty far in Box2D.  Nevertheless, the convex shape requirement ￼will severely limit the range of possibilities.  The good news is that we can completely eliminate this limit by creating a single Box2D body out of multiple shapes!  Let’s return to our little alien creature and simplify the shape to be a thin rectangle with a circle on top.</simpara>
<simpara>How can we build a single Body with two Shapes?  Let’s first review how we built a single Body with one Shape.</simpara>
<simpara><emphasis>Step 1:  Define the Body.</emphasis><?asciidoc-br?>
<emphasis>Step 2: Create the Body.</emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 3: Define the Shape.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 4: Attach the Shape to the Body.</emphasis></emphasis><?asciidoc-br?>
<emphasis>Step 5: Finalize the Body’s mass.</emphasis></simpara>
<simpara>Attaching more than one Shape to a Body is as simple as repeating steps 3 and 4 over and over again.</simpara>
<simpara><emphasis role="strong"><emphasis>Step 3a: Define Shape 1.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 4a: Attach Shape 1 to the Body.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 3b: Define Shape 2.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 4b: Attach Shape 2 to the Body.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>etc. etc. etc.</emphasis></emphasis><?asciidoc-br?></simpara>
<simpara>Let’s see what this would look like with actual Box2D code.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Making the Body
BodyDef bd = new BodyDef();
bd.type = BodyType.DYNAMIC;
bd.position.set(box2d.coordPixelsToWorld(center));
body = box2d.createBody(bd);

// Making Shape 1 (the rectangle)
PolygonShape ps = new PolygonShape();
float box2dW = box2d.scalarPixelsToWorld(w/2);
float box2dH = box2d.scalarPixelsToWorld(h/2);
sd.setAsBox(box2dW, box2dH);

// Making Shape 2 (the circle)
CircleShape cs = new CircleShape();
cs.m_radius = box2d.scalarPixelsToWorld(r);

// Attach both shapes with a Fixture.
body.createFixture(ps,1.0);
body.createFixture(cs, 1.0);</programlisting>
<simpara>The above looks pretty good, but sadly, if we run it, we’ll get the following result:</simpara>
<informalfigure id="chapter05_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_10.png" />
  </imageobject>
  <textobject><phrase>Figure 5.10</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When you attach a Shape to a Body, by default, the center of the Shape will be located at the center of the Body.  But in our case, if we take the center of the rectangle to be the center of the Body, we want the center of the circle to be offset along the y-axis from the Body’s center.</simpara>
<informalfigure id="chapter05_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_11.png" />
  </imageobject>
  <textobject><phrase>Figure 5.11</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is achieved by using the local position of a Shape, accessed via a Vec2 variable called <emphasis role="strong"><phrase role="var">m_p</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Our offset in pixels
Vec2 offset = new Vec2(0,-h/2);
// Converting the vector to Box2D world
offset = box2d.vectorPixelsToWorld(offset);
// Setting the local position of the circle
circle.m_p.set(offset.x,offset.y);</programlisting>
<simpara>Then when we go to draw the Body, we use both <emphasis role="strong"><phrase role="function">rect()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">ellipse()</phrase></emphasis> with the circle offset the same way.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex06.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example5"><emphasis role="strong"><phrase role="example">Example 5.5: Multiple Shapes on one Body</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    // First the rectangle at (0,0)
    rect(0,0,w,h);
    // Then the ellipse offset at (0,-h/2)
    ellipse(0,-h/2,r*2,r*2);
    popMatrix();
  }</programlisting>
<simpara>Finishing off this section, I want to stress the following: the stuff you draw in your Processing window doesn’t magically experience physics simply because we created some Box2D Bodies and Shapes.  These examples work because we very carefully matched how we draw our elements with how we defined the Bodies and Shapes we put into the Box2D world.   If you accidentally draw your shape differently, you won’t get an error, not from Processing or from Box2D.  However, your sketch will look odd and the physics won’t work correctly.  For example, what if we had written:</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2 offset = new Vec2(0,-h/2);</programlisting>
<simpara>when we created the Shape, but:</simpara>
<programlisting language="java" linenumbering="unnumbered">ellipse(0,h/2,r*2,r*2);</programlisting>
<simpara>when it came time to display the Shape?</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex07.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex07.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The results would look like the image above, where clearly, the collisions are not functioning as expected.  This is not because the physics is broken; it’s because we did not communicate properly with Box2D, either when we put stuff in the magic world or queried the world for locations.</simpara>
<example id="chapter05_exercise5">
<title>Exercise 5.5</title>
<simpara>Make your own little alien being using multiple Shapes attached to a single Body.  Try using more than one Polygon to make a concave shape.   Remember, you aren’t limited to using the shape drawing functions in Processing; you can use images, colors, add hair with lines, etc.  Think of the Box2D shapes only as skeletons for your creative and fantastical design!</simpara>
</example>
</section>
<section id="chapter05_section11">
<title>5.11 Feeling Attached—Box2D Joints</title>
<informalfigure id="chapter05_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_12.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 5.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Box2D joints allow you to connect one Body to another, enabling more advanced simulations of swinging pendulums, elastic bridges, squishy characters, wheels spinning on an axle, etc.  There are many different kinds of Box2D joints. In this chapter we’re going to look at three: distance joints, revolute joints, and “mouse” joints.</simpara>
<simpara>Let’s begin with a distance joint, a joint that connects two Bodies with a fixed length.  The joint is attached to each Body at a specified anchor point (a point relative to the Body’s center.)  For any Box2D joint, we need to follow these steps.  This, of course, is similar to the methodology we used to build Bodies and Shapes, with some quirks.</simpara>
<simpara><emphasis role="strong"><emphasis>Step 1. Make sure you have two Bodies ready to go.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 2. Define the Joint.</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 3. Configure the Joint’s properties (What are the Bodies? Where are the anchors? What is its rest length? Is it elastic or rigid?)</emphasis></emphasis><?asciidoc-br?>
<emphasis role="strong"><emphasis>Step 4. Create the Joint.</emphasis></emphasis><?asciidoc-br?></simpara>
<simpara>Let’s assume we have two Particle objects that each store a reference to a Box2D Body.  We’ll call them Particles p1 and p2.</simpara>
<programlisting language="java" linenumbering="unnumbered">Particle p1 = new Particle();
Particle p2 = new Particle();</programlisting>
<simpara>OK, onto Step 2.  Let’s define the Joint.</simpara>
<programlisting language="java" linenumbering="unnumbered">DistanceJointDef djd = new DistanceJointDef();</programlisting>
<simpara>Easy, right?  Now it’s time to configure the Joint.   First we tell the Joint which two Bodies it connects:</simpara>
<programlisting language="java" linenumbering="unnumbered">djd.bodyA = p1.body;
djd.bodyB = p2.body;</programlisting>
<simpara>Then we set up a rest length.  Remember, if our rest length is in pixels, we need to convert it!</simpara>
<programlisting language="java" linenumbering="unnumbered">djd.length = box2d.scalarPixelsToWorld(10);</programlisting>
<simpara>A distance joint also includes two optional settings that can make the joint soft, like a spring connection: frequencyHz and damping ratio.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Measured in Hz, like the frequency of harmonic
  // oscillation; try values between 1 and 5
  djd.frequencyHz  = ___;
  // Dampens the spring; typically a number between 0 and 1
  djd.dampingRatio = ___;</programlisting>
<simpara>Finally, we create the Joint.</simpara>
<programlisting language="java" linenumbering="unnumbered">DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);</programlisting>
<simpara>Box2D won’t keep track of what kind of Joint we are making, so we have to cast it as a DistanceJoint upon creation.</simpara>
<simpara>We can create Box2D joints anywhere in our Processing sketch.  Here’s an example of how we might write a class to describe two Box2D bodies connected with a single joint.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex08.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex08.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example6"><emphasis role="strong"><phrase role="example">Example 5.6: DistanceJoint</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Pair {

  Particle p1;          // Two objects that each have a Box2D body
  Particle p2;
  float len = 32;               // Arbitrary rest length

  Pair(float x, float y) {

    p1 = new Particle(x,y);
    // Problems can result if the bodies are
    // initialized at the same location.
    p2 = new Particle(x+random(-1,1),y+random(-1,1));

    // Making the joint!
    DistanceJointDef djd = new DistanceJointDef();
    djd.bodyA = p1.body;
    djd.bodyB = p2.body;
    djd.length = box2d.scalarPixelsToWorld(len);
    djd.frequencyHz = 0;  // Try a value less than 5
    djd.dampingRatio = 0; // Ranges between 0 and 1

    // Make the joint.  Note we aren't storing a reference to the
    // joint anywhere! We might need to someday, but for now it's OK.
    DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);
  }

  void display() {
    Vec2 pos1 = box2d.getBodyPixelCoord(p1.body);
    Vec2 pos2 = box2d.getBodyPixelCoord(p2.body);
    stroke(0);
    line(pos1.x,pos1.y,pos2.x,pos2.y);

    p1.display();
    p2.display();
  }
}</programlisting>
<example id="chapter05_exercise6">
<title>Exercise 5.6</title>
<simpara>Create a simulation of a bridge by using distance joints to connect a sequence of circles (or rectangles) as illustrated to the right.  Assign a density of zero to lock the endpoints in place.  Experiment with different values to make the bridge more or less “springy.”   It should also be noted that the joints themselves have no physical geometry, so in order for your bridge not to have holes, spacing between the nodes will be important.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc06.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc06.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<informalfigure id="chapter05_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_13.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 5.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Another joint you can create in Box2D is a <emphasis>Revolute Joint</emphasis>.</simpara>
<simpara>A revolute connects two Box2D bodies at a common anchor point, which can also be referred to as a “hinge.”   The joint has an “angle” that describes the relative rotation of each Body.   To use a Revolute Joint, we follow the same steps we did with the Distance Joint.</simpara>
<section id="_step_1_make_sure_you_have_two_bodies_ready_to_go">
<title>Step 1: Make sure you have two bodies ready to go.</title>
<simpara>Let’s assume we have two “Box” objects, each of which stores a reference to a Box2D Body.</simpara>
<programlisting language="java" linenumbering="unnumbered">Box box1 = new Box();
Box box2 = new Box();</programlisting>
</section>
<section id="_step_2_define_the_joint">
<title>Step 2: Define the Joint.</title>
<simpara>Now we want a RevoluteJointDef.</simpara>
<programlisting language="java" linenumbering="unnumbered">RevoluteJointDef rjd = new RevoluteJointDef();</programlisting>
</section>
<section id="_step_3_configure_the_joint_s_properties">
<title>Step 3: Configure the Joint’s properties.</title>
<simpara>The most important properties of a RevoluteJoint are the two bodies it connects as well as their mutual anchor point (i.e. where they are connected).   There are set with the function <emphasis role="strong"><phrase role="function">initialize()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());</programlisting>
<simpara>Notice how the first two arguments specify the bodies and the second point specifies the anchor, which in this case is located at the center of the first body.</simpara>
<simpara>An exciting aspect to the RevoluteJoint is that you can motorize it so it spins autonomously.  For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Turn on the motor.
rjd.enableMotor = true;
 // How fast is the motor?
rjd.motorSpeed = PI*2;
// How powerful is the motor?
rjd.maxMotorTorque = 1000.0;</programlisting>
<simpara>The motor can be enabled and disabled while the program is running.</simpara>
<simpara>Finally, the ability for a RevoluteJoint to spin can be constrained between two angles. (By default, it can rotate a full 360 degrees, or TWO_PI radians.)</simpara>
<programlisting language="java" linenumbering="unnumbered">rjd.enableLimit = true;
rjd.lowerAngle = -PI/8;
rjd.upperAngle = PI/8;</programlisting>
</section>
<section id="_step_4_create_the_joint">
<title>Step 4: Create the Joint</title>
<programlisting language="java" linenumbering="unnumbered">RevoluteJoint joint = (RevoluteJoint) box2d.world.createJoint(rjd);</programlisting>
<simpara>Let’s take a look at all of these steps together in a class called <emphasis role="strong"><phrase role="class">Windmill</phrase></emphasis>, which connects two boxes with a revolute joint.  In this case, “box1” has a density of zero, so only “box2” spins around a fixed point.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex09.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex09.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example7"><emphasis role="strong"><phrase role="example">Example 5.7: Spinning Windmill</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Windmill {

  // Our “Windmill” is two boxes and one joint
  RevoluteJoint joint;
  Box box1;
  Box box2;

  Windmill(float x, float y) {
    // In this example, the Box class expects a boolean
    // argument argument that will be used to determine if the
    // Box is fixed or not.  See web site for the Box class code.
    box1 = new Box(x,y,120,10,false);
    box2 = new Box(x,y,10,40,true);

    RevoluteJointDef rjd = new RevoluteJointDef();
    // The Joint connects two Bodies and
    // is anchored at the center of the first body.
    rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());

    // A Motor!
    rjd.motorSpeed = PI*2;
    rjd.maxMotorTorque = 1000.0;
    rjd.enableMotor = true;

    // Create the Joint
    joint = (RevoluteJoint) box2d.world.createJoint(rjd);
  }

  // Turning the motor on or off
  void toggleMotor() {
    boolean motorstatus = joint.isMotorEnabled();
    joint.enableMotor(!motorstatus);
  }

  void display() {
    box1.display();
    box2.display();
  }
}</programlisting>
<example id="chapter05_exercise7">
<title>Exercise 5.7</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc07.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc07.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Use a RevoluteJoint for the wheels of a Car.  Use motors so that the car drives autonomously.  Try using a ChainShape for the road’s surface.</simpara>
</example>
<simpara>The last joint we’ll look at is the MouseJoint.  The MouseJoint is typically used for moving a Body with the mouse.  However, it can also be used to drag an object around the screen according to some arbitrary x and y.   The joint functions by pulling the Body towards a “target” position.</simpara>
<simpara>Before we look at the MouseJoint itself, let’s ask ourselves why we even need it in the first place.  If you look at the Box2D documentation, there is a function called <emphasis role="strong"><phrase role="function">setTransform()</phrase></emphasis> that specifically “sets the position of the body&#8217;s origin and rotation (radians).”  If a Body has a position, can’t we just assign the Body’s position to the mouse?</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2 mouse = box2d.screenToWorld(x,y);
body.setTransform(mouse,0);</programlisting>
<simpara>While this will in fact move the Body, it also will have the unfortunate result of breaking the physics.  Let’s imagine you built a teleportation machine that allows you to teleport from your bedroom to your kitchen (good for late night snacking).   Now, go ahead and rewrite Newton’s laws of motion to account for the possibility of teleportation.  Not so easy, right?  Box2D has the same problem.  If you manually assign the location of an body, it’s like saying “teleport that body” and Box2D no longer knows how to compute the physics properly.  However, Box2D does allow you to tie a rope to yourself and get a friend of yours to stand in the kitchen and drag you there.  This is what the MouseJoint does. It’s like a string you attach to a Body and pull towards a target.</simpara>
<simpara>Let’s look at making this joint, assuming we have a Box object: box.  This code will look identical to our distance joint with one small difference.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Just like before, define the Joint.
MouseJointDef md = new MouseJointDef();

// Whoa, this is new!
md.bodyA = box2d.getGroundBody(); // [bold]
// Attach the Box Body.
md.bodyB = box.body;

// Set properties.
md.maxForce = 5000.0;
md.frequencyHz = 5.0;
md.dampingRatio = 0.9;

// Create the Joint
MouseJoint mouseJoint = (MouseJoint) box2d.world.createJoint(md);.</programlisting>
<simpara>So, what’s this line of code all about?</simpara>
<programlisting language="java" linenumbering="unnumbered">md.bodyA = box2d.getGroundBody(); // [bold]</programlisting>
<simpara>Well, as we’ve stated, a joint is a connection between <emphasis>two</emphasis> bodies.  With the MouseJoint, we’re saying that the second body is, well, the ground.  Hmm.  What the heck is the <emphasis>ground</emphasis> in Box2D?   One way to imagine it is to think of the screen as the ground.  What we’re doing is making a joint that connects a rectangle drawn on the window with the Processing window itself.  And the point in the window to which the connection is tied is a moving target.</simpara>
<simpara>Once we have a MouseJoint, we’ll want to update the target location continually while the sketch is running.</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);
mouseJoint.setTarget(mouseWorld);</programlisting>
<simpara>To make this work in an actual Processing sketch, we’ll want to have the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
*<emphasis>Box class</emphasis>*—An object that references a Box2D Body.
</simpara>
</listitem>
<listitem>
<simpara>
*<emphasis>Spring class</emphasis>*—An object that manages the MouseJoint that drags the Box object around.
</simpara>
</listitem>
<listitem>
<simpara>
*<emphasis>Main tab</emphasis>*—Whenever mousePressed() is called, the MouseJoint is created; whenever mouseReleased() is called, the MouseJoint is destroyed.  This allows us to interact with a Body only when the mouse is pressed.
</simpara>
</listitem>
</orderedlist>
<simpara>Let’s take a look at the main tab.  You can find the rest of the code for the Box and Spring classes on the book web site.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex10.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex10.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example8"><emphasis role="strong"><phrase role="example">Example 5.8: MouseJoint demonstration</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">PBox2D box2d;

// One Box
Box box;
// Object to manage MouseJoint
Spring spring;

void setup() {
  size(400,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  box = new Box(width/2,height/2);
  // The MouseJoint is really null until we click the mouse.
  spring = new Spring();
}

void mousePressed() {
  // Was the mouse clicked inside the Box?
  if (box.contains(mouseX, mouseY)) {
    // If so, attach the MouseJoint.
    spring.bind(mouseX,mouseY,box);
  }
}

void mouseReleased() {
  // When the mouse is released, we’re done with the Joint.
  spring.destroy();
}

void draw() {
  background(255);

  box2d.step();

  // We must always update the MouseJoint’s target.
  spring.update(mouseX,mouseY);

  box.display();
  spring.display();
}</programlisting>
<example id="chapter05_exercise8">
<title>Exercise 5.8</title>
<simpara>Exercise: Use a MouseJoint to move a Box2D Body around the screen according to an algorithm or input other than the mouse.  For example, assign it a location according to Perlin noise or key presses.  Or build your own controller using an <ulink url="http://www.arduino.cc/">Arduino</ulink>.</simpara>
</example>
<simpara>It’s worth noting that while the technique for dragging an object around using a MouseJoint is useful, Box2D also allows a Body to have a “kinematic” body type.</simpara>
<programlisting language="java" linenumbering="unnumbered">BodyDef bd = new BodyDef();
// Setting the body type to Kinematic
bd.type = BodyType.KINEMATIC;</programlisting>
<informalfigure id="chapter05_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_14.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 5.14</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Kinematic bodies can be controlled by the user through setting their velocity directly.    For example, let’s say you want an object to follow a target (like your mouse).  You could create a vector that points from a body’s location to a target.</simpara>
<programlisting language="java" linenumbering="unnumbered">Vec2 pos = body.getWorldCenter();
Vec2 target = box2d.coordPixelsToWorld(mouseX,mouseY);
// A vector pointing from the Body position to the Mouse
Vec2 v = target.sub(pos);</programlisting>
<simpara>Once you have that vector, you could assign it to the body’s velocity so that it moves to the target.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Assigning a body’s velocity directly, overriding physics!
body.setLinearVelocity(v);</programlisting>
<simpara>You can also do the same with angular velocity (or leave it alone and allow the physics to take over).</simpara>
<simpara>It is important to note that kinematic bodies do not collide with other kinematic or static bodies.    In these cases, the <emphasis role="strong"><phrase role="klass">MouseJoint</phrase></emphasis> strategy is preferable.</simpara>
<example id="chapter05_exercise9">
<title>Exercise 5.9</title>
<simpara>Redo your previous exercise, but use a kinematic body instead.</simpara>
</example>
</section>
</section>
<section id="chapter05_section12">
<title>5.12 Bringing It All Back Home to Forces</title>
<simpara>In Chapter 2, we spent a lot of time thinking about building environments with multiple forces.  An object might respond to gravitational attraction, wind, air resistance, etc.  Clearly there are forces at work in Box2D as we watch rectangles and circles spin and fly around the screen.  But so far, we’ve only had the ability to manipulate a single global force—gravity.</simpara>
<programlisting language="java" linenumbering="unnumbered">  box2d = new PBox2D(this);
  box2d.createWorld();
  // Setting the global gravity force
  box2d.setGravity(0, -20);</programlisting>
<simpara>If we want to use any of our Chapter 2 techniques with Box2D, we need look no further than our trusty <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.   In our Mover class we wrote a function called <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis>, which received a vector, divided it by mass, and accumulated it into the Mover’s acceleration.  With Box2D, the same function exists, but we don’t need to write it ourselves.  Instead, we can call the Box2D Body’s <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function!</simpara>
<programlisting language="java" linenumbering="unnumbered">class Box {
  Body body;

  // etc. etc.
  void applyForce(Vec2 force) {
    Vec2 pos = body.getWorldCenter();
    body.applyForce(force, pos);
  }
}</programlisting>
<simpara>Here we are receiving a force vector and passing it along to the Box2D Body object.  The key difference is that Box2D is a more sophisticated engine than our examples from Chapter 2.   Our earlier forces examples assumed that the force was always applied at the Mover’s center.  Here we get to specify exactly where on the Body the force is applied.  In the above code, we’re just applying it to the center by asking the Body for its center, but this could be adjusted.</simpara>
<simpara>Let’s say we wanted to use a gravitational attraction force.  Remember the code we wrote back in Chapter 2 in our Attractor class?</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector attract(Mover m) {
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  distance = constrain(distance,5.0,25.0);
  force.normalize();
  float strength = (g * mass * m.mass) / (distance * distance);
  force.mult(strength);
  return force;
}</programlisting>
<simpara>We can rewrite the exact same function using Vec2 instead and use it in a Box2D example.  Note how for our force calculation we can stay completely within the Box2D coordinate system and never think about pixels.</simpara>
<simpara>Vec2 attract(Mover m) {
  // We have to ask Box2D for the locations first!
  Vec2 pos = body.getWorldCenter();
  Vec2 moverPos = m.body.getWorldCenter();
  Vec2 force = pos.sub(moverPos);
  float distance = force.length();
  distance = constrain(distance,1,5);
  force.normalize();
  float strength = (G * 1 * m.body.m_mass) / (distance * distance);
  // Remember, it’s mulLocal() for Vec2.
  force.mulLocal(strength);
  return force;
}</simpara>
<example id="chapter05_exercise10">
<title>Exercise 5.10</title>
<simpara>Exercise: Take any example you made previously using a force calculation and bring that force calculation into Box2D.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc10.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc10.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter05_section13">
<title>5.13 Collision Events</title>
<simpara>Now we’ve seen a survey of what can be done with Box2D.   Since this book is not called “The Nature of Box2D,” it’s not my intention to cover every single possible feature of the Box2D engine.  But hopefully by looking at the basics of building bodies, shapes, and joints, when it comes time to use an aspect of Box2D that we haven’t covered, the skills we’ve gained here will make that process considerably less painful.  There is one more feature of Box2D, however, that I do think is worth covering.</simpara>
<simpara>Let’s ask a question you’ve likely been wondering:</simpara>
<simpara><emphasis>What if I want something to happen when two Box2D bodies collide?   I mean, don’t get me wrong—I’m thrilled that Box2D is handling all of the collisions for me. But if it takes care of everything for me, how am I supposed to know when things are happening?</emphasis></simpara>
<simpara>Your first thoughts when considering an event during which two objects collide might be as follows:  Well, if I know all the bodies in the system, and I know where they are all located, then I can just start comparing the locations, see which ones are intersecting, and determine that they’ve collided.  That’s a nice thought, but hello??!?  The whole point of using Box2D is that Box2D will take care of that for us.  If we are going to do the geometry to test for intersection ourselves, then all we’re doing is re-implementing Box2D.</simpara>
<simpara>Of course, Box2D has thought of this problem before.  It’s a pretty common one.  After all, if you intend to make a bajillion dollars selling some game called Angry Birds, you better well make something happen when an ill-tempered pigeon smashes into a cardboard box.   Box2D alerts you to moments of collision with something called an “interface.”  It’s worth learning about interfaces, an advanced feature of object-oriented programming. You can take a look at the <ulink url="http://download.oracle.com/javase/tutorial/java/concepts/interface.html">Java Interface Tutorial</ulink> as well as the JBox2D ContactListener class. (I have also included an example on the web site that demonstrates using the interface directly.)</simpara>
<simpara>If you are using PBox2D, as we are here, you don’t need to implement your own interface.  Detecting collision events is done through a callback function no different than mousePressed().</simpara>
<programlisting language="java" linenumbering="unnumbered">// The mousePressed event with which we are comfortable.
void mousePressed() {
  println("The mouse was pressed!");
}

// What our "beginContact" event looks like.
void beginContact(Contact cp) {
  println("Something collided in the Box2D World!");
}</programlisting>
<simpara>Before the above will work, you must first let PBox2D know you intend to listen for collisions. (This allows the library to reduce overhead by default; it won’t bother listening if it doesn’t have to.)</simpara>
<simpara>void setup() {
  box2d = new PBox2D(this);
  box2d.createWorld();
  // Add this line if you want to listen for collisions.
  box2d.listenForCollisions();
}</simpara>
<simpara>There are four collision event callbacks.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">beginContact()</phrase></emphasis> —Triggered whenever two shapes first come into contact with each other.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">endContact()</phrase></emphasis> —Triggered over and over again as long as shapes continue to be in contact.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">preSolve()</phrase></emphasis> —Triggered before Box2D solves the outcome of the collision (i.e. before beginContact()).  It can be used to disable a collision if necessary.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="function">postContact()</phrase></emphasis> —Triggered after the outcome of the collision is solved. It allows you to gather information about that “solution” (known as an “impulse”).
</simpara>
</listitem>
</orderedlist>
<simpara>The details behind <emphasis role="strong"><phrase role="function">preSolve()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">postSolve()</phrase></emphasis> are beyond the scope of this book; however, we are going to take a close look at <emphasis role="strong"><phrase role="function">beginContact()</phrase></emphasis>, which will cover the majority of conventional cases in which you want to trigger an action when a collision occurs.  <emphasis role="strong"><phrase role="function">endContact()</phrase></emphasis> works identically to <emphasis role="strong"><phrase role="function">beginContact()</phrase></emphasis>, the only difference being that it occurs the moment bodies separate.</simpara>
<simpara><emphasis role="strong"><phrase role="function">beginContact()</phrase></emphasis> is written as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">void beginContact(Contact cp) {

}</programlisting>
<simpara>Notice that the function above includes an argument of type <emphasis role="strong"><phrase role="klass">Contact</phrase></emphasis>.  A Contact object includes all the data associated with a collision—the geometry and the forces.  Let’s say we have a Processing sketch with Particle objects that store a reference to a Box2D body.    Here is the process we are going to follow.</simpara>
<section id="_step_1_contact_could_you_tell_me_what_two_things_collided">
<title>Step 1: Contact, could you tell me what two things collided?</title>
<simpara>Now, what has collided here?  Is it the bodies?  The shapes? The fixtures?   Box2D detects collisions between shapes; after all, these are the entities that have geometry.  However, because shapes are attached to bodies with fixtures, what we really want to ask Box2D is: “Could you tell me which two fixtures collided?”</simpara>
<programlisting language="java" linenumbering="unnumbered">// The Contact stores the fixtures as A and B.
Fixture f1 = cp.getFixtureA();
Fixture f2 = cp.getFixtureB();</programlisting>
</section>
<section id="_step_2_fixtures_could_you_tell_me_which_body_you_are_attached_to">
<title>Step 2: Fixtures, could you tell me which Body you are attached to?</title>
<programlisting language="java" linenumbering="unnumbered">// getBody() gives us the Body to which the Fixture is attached.
Body b1 = f1.getBody();
Body b2 = f2.getBody();</programlisting>
</section>
<section id="_step_3_bodies_could_you_tell_me_which_particles_you_are_associated_with">
<title>Step 3: Bodies, could you tell me which Particles you are associated with?</title>
<simpara>OK, this is the harder part.  After all, Box2D doesn’t know anything about our code.  Sure, it is doing all sorts of stuff to keep track of the relationships between Shapes and Bodies and Joints, but it’s up to us to manage our own objects and their associations with Box2D elements.   Luckily for us, Box2D provides a function that allows us to attach our Processing object (a Particle) to a Box2D Body via the <emphasis role="strong"><phrase role="function">setUserData()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">getUserData()</phrase></emphasis> methods.</simpara>
<simpara>Let’s take a look at the constructor in our Particle class where the Body is made.   We are expanding our Body-making procedure by one line of code, noted below.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  Body body;

  Particle(float x, float y, float r) {
    BodyDef bd = new BodyDef();
    bd.position = box2d.coordPixelsToWorld(x, y);
    bd.type = BodyType.DYNAMIC;
    body = box2d.createBody(bd);
    CircleShape cs = new CircleShape();
    cs.m_radius = box2d.scalarPixelsToWorld(r);
    body.createFixture(fd,1);

    // "this" refers to this Particle object.
    // We are telling the Box2D Body to store a
    // reference to this Particle that we can
    // access later.
    body.setUserData(this);  // [bold]
  }</programlisting>
<simpara>Later, in our <emphasis role="strong"><phrase role="function">addContact()</phrase></emphasis> function, once we know the Body, we can access the Particle object with <emphasis role="strong"><phrase role="function">getUserData()</phrase></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex11.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex11.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example9"><emphasis role="strong"><phrase role="example">Example 5.9: CollisionListening</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void beginContact(Contact cp) {

  Fixture f1 = cp.getFixtureA();
  Fixture f2 = cp.getFixtureB();

  Body b1 = f1.getBody();
  Body b2 = f2.getBody();

  // When we pull the “user data” object out of the
  // Body object, we have to remind our program that it
  // is a Particle object.  Box2D doesn’t know this.
  Particle p1 = (Particle) b1.getUserData();
  Particle p2 = (Particle) b2.getUserData();
  p1.change();
  // Once we have the particles, we can do anything to them.  Here we
  // just call a function that changes their color.
  p2.change();
}</programlisting>
<simpara>Now, in many cases, we cannot assume that the objects that collided are all Particle objects.  We might have a sketch with Boundary objects, Particle objects, Box objects, etc.  So often we will have to query the “user data” and find out what kind of object it is before proceeding.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Getting a generic object
  Object o1 = b1.getUserData();
  // Asking that object if it’s a Particle
  if (o1.getClass() == Particle.class) {
    Particle p = (Particle) o1;
    p.change();
  }</programlisting>
<simpara>It should also be noted that due to how Box2D triggers these callbacks, you cannot create or destroy Box2D entities inside of <emphasis role="strong"><phrase role="function">beginContact()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">endContact()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">preSolve()</phrase></emphasis>, or <emphasis role="strong"><phrase role="function">postSolve()</phrase></emphasis>.  If you want to do this, you’ll need to set a variable inside an object (something like: <emphasis>markForDeletion = true</emphasis>), which you check during <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> and then delete objects.</simpara>
<example id="chapter05_exercise11">
<title>Exercise 5.11</title>
<simpara>Consider how polymorphism could help in the above case.  Build an example in which several classes extend one class and therefore eliminate the need for such testing.</simpara>
</example>
<example id="chapter05_exercise12">
<title>Exercise 5.12</title>
<simpara>Exercise:  Create a simulation in which Particle objects disappear when they collide.  Use the methodology I just described.</simpara>
</example>
</section>
</section>
<section id="chapter05_section14">
<title>5.14 A Brief Interlude—Integration Methods</title>
<simpara>Has the following ever happened to you?  You’re at a fancy cocktail party regaling your friends with tall tales of software physics simulations.   Someone pipes up: “Enchanting! But what integration method are you using?”  “What?!” you think to yourself.  “Integration?”</simpara>
<simpara>Maybe you’ve heard the term before.  Along with “differentiation,” it’s one of the two main operations in calculus.  Right, calculus.  The good news is, we’ve gotten through about 90% of the material in this book related to physics simulation and we haven’t really needed to dive into calculus.  But as we’re coming close to finishing this topic, it’s worth taking a moment to examine the calculus behind what we have been doing and how it relates to the methodology in certain physics libraries (like Box2D and the upcoming toxiclibs).</simpara>
<simpara>Let’s begin by answering the question: “What does integration have to do with location, velocity, and acceleration?”   Well, first let’s define differentiation.    The derivative of a function is a measure of how a function changes over time.  Consider location and its derivative.  Location is a point in space, while velocity is change in location over time.  Therefore, velocity can be described as the “derivative” of location.   What is acceleration?  The change in velocity over time—i.e. the “derivative” of velocity.</simpara>
<simpara>Now that we understand the derivative (differentiation), we can define the integral (integration) as the inverse of the derivative.  In other words, the integral of an object&#8217;s velocity over time tells us the object’s new location when that time period ends.   Location is the integral of velocity, and velocity is the integral of acceleration.  Since our physics simulation is founded upon the process of calculating acceleration based on forces, we need integration to figure out where the object is after a certain period of time (like one frame of animation!).</simpara>
<simpara>So we’ve been doing integration all along!  It looks like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">velocity.add(acceleration);
location.add(velocity);</programlisting>
<simpara>The above methodology is known as Euler Integration (named for the mathematician Leonhard Euler, pronounced “Oiler”) or the Euler Method.    It’s essentially the simplest form of integration and very easy to implement in our code (see the two lines above!)  However, it is not necessarily the most efficient form, nor is it close to being the most accurate.    Why is Euler inaccurate?  Let’s think about it this way.  When you drive a car down the road pressing the gas pedal with your foot and accelerating, does the car sit in one location at time equals one second, then disappear and suddenly reappear in a new location at time equals two seconds, and do the same thing for three seconds, and four, and five?  No, of course not.  The car moves continuously down the road.  But what’s happening in our Processing sketch?  A circle is at one location at frame 0, another at frame 1, another at frame 2.  Sure, at thirty frames per second, we’re seeing the illusion of motion.  But we only calculate a new location every N units of time, whereas the real world is perfectly continuous.   This results in some inaccuracies, as shown in the diagram below:</simpara>
<informalfigure id="chapter05_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_15.png" />
  </imageobject>
  <textobject><phrase>Figure 5.15</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The “real world” is the curve; Euler simulation is the series of line segments.</simpara>
<simpara>One option to improve on Euler is to use smaller timesteps—instead of once per frame, we could recalculate an object’s location twenty times per frame.  But this isn’t practical; our sketch would then run too slowly.</simpara>
<simpara>I still believe that Euler is the best method for learning the basics, and it’s also perfectly adequate for most of the projects we might make in Processing.  Anything we lose in efficiency or inaccuracy we make up in ease of use and understandability.    For better accuracy, Box2D uses something called symplectic Euler (or semi-explicit Euler), a slight modification of Euler (see: <ulink url="http://en.wikipedia.org/wiki/Symplectic_Euler_method">Symplectic Euler Method</ulink>).</simpara>
<simpara>There is also an integration method called Runge–Kutta (named for German mathematicians C. Runge and M.W. Kutta), which is used in some physics engines.</simpara>
<simpara>A very popular integration method that our next physics library uses is known as “Verlet integration.”  A simple way to describe Verlet integration is to think of our typical motion algorithm without velocity.  After all, we don&#8217;t really need to store the velocity.  If we always know where an object was at one point in time and where it is now, we can extrapolate its velocity.  Verlet integration does precisely this, though instead of having a variable for velocity, it calculates velocity while the program is running.   Verlet iIntegration is particularly well suited for particle systems, especially particle systems with spring connections between the particles.    We don&#8217;t need to worry about the details because toxiclibs, as we’ll see below, takes care of them for us.  However, if you are interested, here is the seminal paper on Verlet physics, from which just about every Verlet computer graphics simulation is derived:</simpara>
<simpara><ulink url="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">Verlet Simulation</ulink></simpara>
<simpara>And of course, you can find out more about Verlet integration via Wikipedia:</simpara>
<simpara><ulink url="http://en.wikipedia.org/wiki/Verlet_integration">Verlet Integration</ulink></simpara>
</section>
<section id="chapter05_section15">
<title>5.15 Verlet Physics with toxiclibs</title>
<simpara>From toxiclibs.org:</simpara>
<simpara><emphasis>“toxiclibs is an independent, open-source library collection for computational design tasks with Java &amp; Processing developed by Karsten “toxi” Schmidt (thus far). The classes are purposefully kept fairly generic in order to maximize re-use in different contexts ranging from generative design, animation, interaction/interface design, data visualization to architecture and digital fabrication, use as teaching tool and more.”</emphasis></simpara>
<simpara>In other words, we should thank our lucky stars for toxiclibs.  We are only going to focus on a few examples related to Verlet physics, but toxiclibs includes a suite of other wonderful packages that help with audio, color, geometry, and more.  In particular, if you are looking to work with form and fabrication in Processing, take a look at the geometry package.   Demos can be at <ulink url="http://www.openprocessing.org/portal/?userID=4530">Open Processing</ulink>.</simpara>
<simpara>We should note that toxiclibs was designed specifically for use with Processing.  This is great news.  The trouble we had with making Box2D work in Processing (multiple coordinate systems, Box2D vs. JBox2D vs. PBox2D) is not an issue here.  toxiclibs is a library that you just download, stick in your libraries folder, and use.  And the coordinate system that we’ll use for the physics engine is the coordinate system of Processing, so no translating back and forth.   In addition, toxiclibs is not limited to a 2D world; all of the physics simulations and functions work in both two and three dimensions.  So how do you decide which library you should use?  Box2D or toxiclibs?  If you fall into one of the following two categories, your decision is a bit easier:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">My project involves collisions.   I have circles, squares, and other strangely shaped objects that knock each other around and bounce off each other.</phrase></emphasis></simpara>
<simpara>In this case, you are going to need Box2D.  toxiclibs does not handle collisions.</simpara>
<simpara>[highlight]*
My project involves lots of particles flying around the screen.  Sometimes they attract each other.  Sometimes they repel each other.  And sometimes they are connected with springs.*</simpara>
<simpara>In this case, toxiclibs is likely your best choice.  It is simpler to use than Box2D and particularly well suited to connected systems of particles.  toxiclibs is also very high performance, due to the speed of the Verlet integration algorithm (not to mention the fact that the program gets to ignore all of the collision geometry.)</simpara>
<simpara>Here is a little chart that covers some of the features for each physics library.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Feature </entry>
<entry align="left" valign="top">Box2D </entry>
<entry align="left" valign="top"> Toxiclibs VerletPhysics</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Collision geometry</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3D physics</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Particle attraction / repulsion forces</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spring connections</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Other connections: revolute, pulley, gear, prismatic</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Motors</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Friction</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section id="_getting_toxiclibs">
<title>Getting toxiclibs</title>
<simpara>Everything you need to download and install toxiclibs can be found at:</simpara>
<simpara><ulink url="http://toxiclibs.org/">Toxiclibs</ulink></simpara>
<simpara>When you download the library, you’ll notice that it comes with eight modules (i.e. sub-folders), each a library in its own right.  For the examples in this chapter, you will only need “verletphysics” and “toxiclibscore”; however, I recommend you take a look at and consider using all of the modules!</simpara>
<simpara>Once you have the library installed to your Processing library folder (see: <ulink url="http://wiki.processing.org/w/How_to_Install_a_Contributed_Library">How to Install</ulink>), you are ready to start looking at the following examples.</simpara>
</section>
<section id="_core_elements_of_verletphysics">
<title>Core Elements of VerletPhysics</title>
<simpara>We spent a lot of time working through the core elements of a Box2D world: world, body, shape, joint.   This gives us a head start on understanding toxiclibs, since it follows a similar structure.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Box2D  </entry>
<entry align="left" valign="top">Toxiclibs VerletPhysics</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>World</simpara></entry>
<entry align="left" valign="top"><simpara>VerletPhysics</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Body</simpara></entry>
<entry align="left" valign="top"><simpara>VerletParticle</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Shape</simpara></entry>
<entry align="left" valign="top"><simpara>Nothing!  Toxiclibs does not handle shape geometry</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Fixture</simpara></entry>
<entry align="left" valign="top"><simpara>Nothing!  Toxiclibs does not handle shape geometry</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Joint</simpara></entry>
<entry align="left" valign="top"><simpara>VerletSpring</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_vectors_with_toxiclibs">
<title>Vectors with toxiclibs</title>
<simpara>Here we go again.  Remember all that time we spent learning the ins and outs of <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>?  Then remember how when we got to Box2D, we had to translate all those concepts to a Box2D vector class: <emphasis role="strong"><phrase role="class">Vec2</phrase></emphasis>?  Well, it’s time to do it again.  toxiclibs also includes its own vector classes, one for two dimensions and one for three:  <emphasis role="strong"><phrase role="class">Vec2D</phrase></emphasis> and <emphasis role="strong"><phrase role="class">Vec3D</phrase></emphasis>.</simpara>
<simpara>Again, toxiclibs vectors are the same conceptually, but we need to learn a bit of new syntax.  You can find all of the documentation for these vector classes here:</simpara>
<simpara><ulink url="http://toxiclibs.org/docs/core/toxi/geom/Vec2D.html">Vec2D</ulink><?asciidoc-br?>
<ulink url="http://toxiclibs.org/docs/core/toxi/geom/Vec3D.html">Vec3D</ulink></simpara>
<simpara>And let’s just review some of the basic vector math operations with PVector translated to Vec2D (we’re sticking with 2D for simplicity’s sake).</simpara>
<passthrough><table class="code">
<tr>
<th>PVector</th>
<th>Vec2D</th>
</tr>
<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);
</pre>
</td>
<td>
<pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
a.addSelf(b);
</pre>
</td>
</tr>

<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);
</pre>
</td>
<td>
<pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
Vec2D c = a.add(b);
</pre>
</td>
</tr>

<tr>
<td>
<pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();
</pre>
</td>
<td>
<pre>
Vec2D a = new Vec2D(1,-1);
float m = a.magnitude();
a.normalize();
</pre>
</td>
</tr>

</table></passthrough>
</section>
<section id="_building_the_toxiclibs_physics_world">
<title>Building the toxiclibs Physics World</title>
<simpara>The first thing we need to do to use VerletPhysics in our examples is import the library itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Importing the libraries
import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;</programlisting>
<simpara>Then we’ll need a reference to our physics world, a VerletPhysics or VerletPhysics2D object (depending on whether we are working in two or three dimensions.)  The examples in this chapter will operate in 2D only for simplicity, but they could easily be extended into 3D (and 3D versions are available with the chapter download).</simpara>
<programlisting language="java" linenumbering="unnumbered">VerletPhysics2D physics;

void setup() {
  // Creating a Toxiclibs verlet physics world
  physics=new VerletPhysics2D();</programlisting>
<simpara>Once you have your VerletPhysics object, you can set some global properties for your world.  For example, if you want it to have hard boundaries past which objects cannot travel, you can set its limits:</simpara>
<programlisting language="java" linenumbering="unnumbered">  physics.setWorldBounds(new Rect(0,0,width,height));</programlisting>
<simpara>In addition, you can add gravity to the physics world with a GravityBehavior object.  A GravityBehavior requires a vector—how strong and in what direction is the gravity?</simpara>
<programlisting language="java" linenumbering="unnumbered">  physics.addBehavior(new GravityBehavior(new Vec2D(0,0.5)));
}</programlisting>
<simpara>Finally, in order to calculate the physics of the world and move the objects in the world, we have to call <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>.  Typically this would happen once per frame in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  // This is the same as Box2D’s “step()” function
  physics.update();
}</programlisting>
</section>
</section>
<section id="chapter05_section16">
<title>5.16 Particles and Springs in Toxiclibs</title>
<simpara>In the Box2D examples, we saw how we can create our own class (called, say, Particle) and include a reference to a Box2D Body.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  Body body;</programlisting>
<simpara>This technique is somewhat redundant since Box2D itself keeps track of all of the Bodies in its world.  However, it allows us to manage which Body is which (and therefore how each Body is drawn) without having to rely on iterating through Box2D’s internal lists.</simpara>
<simpara>Let’s look at how we might take the same approach with the class VerletParticle2D in toxiclibs. We want to make our own Particle class so that we can draw our Particle a certain way and include any custom properties. We’d probably write our code as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle {
  // Our Particle has a reference to a VerletParticle.
  VerletParticle2D p;

  Particle(Vec2D pos) {
    // A VerletParticle needs an initial location (an x and y).
    p = new VerletParticle2D(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    // When it comes time to draw the Particle, we ask the
    // VerletParticle for its x and y coordinate.
    ellipse(p.x,p.y,16,16);
  }
}</programlisting>
<simpara>Looking at the above, we should first be thrilled to notice that drawing the Particle is as simple as grabbing the x and y and using them.  No awkward conversions between coordinate systems here since toxiclibs is designed to think in pixels.    Second, you might notice that this Particle class’s sole purpose is to store a reference to a VerletParticle2D.  This hints at something.  Remember our discussion of inheritance back in Chapter 4: Particle Systems?</simpara>
<simpara>What is a Particle object other than an “augmented” VerletParticle?  Why bother making a VerletParticle inside a Particle when we could simply extend VerletParticle?</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    // Calling super() so that the object is initialized properly
    super(loc);
  }

  // We want to be just like a VerletParticle, only with a display() method.
  void display() {
    fill(175);
    stroke(0);
    // We’ve inherited x and y from VerletParticle!
    ellipse(x,y,16,16);
  }
}</programlisting>
<simpara>Remember our multi-step process with the Box2D examples?  We had to ask the Body for its location, then convert that location to pixels, then use that location in a drawing function.  Now, because we have inherited everything from VerletParticle, our only step is to draw the shape at the x and y!</simpara>
<simpara>Incidentally, it’s interesting to note that the VerletParticle2D class is a subclass of Vec2D. So in addition to inheriting everything from VerletParticle2D, our Particle class actually has all of the Vec2D functions available as well.</simpara>
<simpara>We can now create Particle objects anywhere within our sketch.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Particle p1 = new Particle(new Vec2D(100,20));
  Particle p2 = new Particle(new Vec2D(100,180));</programlisting>
<simpara>Just making a Particle object isn’t enough, however.  We have to make sure we tell our physics world about them with the <emphasis role="strong"><phrase role="function">addParticle()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">  physics.addParticle(p1);
  physics.addParticle(p2);</programlisting>
<simpara>If you look at the toxiclibs documentation, you’ll see that the <emphasis role="strong"><phrase role="function">addParticle()</phrase></emphasis> expects a VerletParticle2D object.</simpara>
<simpara><emphasis role="strong"><phrase role="function">addParticle(VerletParticle2D particle)</phrase></emphasis></simpara>
<simpara>And how can we then pass into the function our own “Particle” object?   Remember that other tenet of object-oriented programming—polymorphism?   Here, because our Particle class extends VerletParticle2D, we can choose to treat our Particle object in multiple ways—as a Particle or as a VerletParticle2D.   This is an incredibly powerful feature of object-oriented programming.  If we build our custom classes based on classes from toxiclibs, we can use our objects in conjunction with all of the functions toxiclibs has to offer.</simpara>
<simpara>In addition to the VerletParticle class, toxiclibs has a set of classes that allow you to connect particles with spring forces.  There are three types of springs in toxiclibs:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="klass">VerletSpring</phrase></emphasis>: This class creates a springy connection between two VerletParticles in space. A Spring’s properties can be configured in such a way as to create a stiff stick-like connection or a highly elastic stretchy connection. A Particle can also be locked so that only one end of the Spring can move.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="klass">VerletConstrainedSpring</phrase></emphasis>: A VerletConstrainedSpring is a spring whose maximum distance can be limited. This can help the whole spring system achieve better stability.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="klass">VerletMinDistanceSpring</phrase></emphasis>: A VerletMinDistanceSpring is a Spring that only enforces its rest length if the current distance is less than its rest length. This is handy if you want to ensure objects are at least a certain distance from each other, but don’t care if the distance is bigger than the enforced minimum.
</simpara>
</listitem>
</itemizedlist>
<simpara>The inheritance and polymorphism technique we employed in the previous section also proves to be useful when creating VerletSprings. A VerletSpring expects two VerletParticles when the spring is created. And again, because our Particle class extends VerletParticle, VerletSpring will accept our Particles passed into the constructor.  Let’s take a look at some example code that assumes the existence of our two previous Particles p1 and p2 and creates a connection between them with a given rest length and strength.</simpara>
<programlisting language="java" linenumbering="unnumbered">// What is the rest length of the spring?
float len = 80;
// How strong is the spring?
float strength = 0.01;
VerletSpring2D spring=new VerletSpring2D(p1,p2,len,strength);</programlisting>
<simpara>Just as with Particles, in order for the connection to actually be part of the physics world, we need to explicitly add it.</simpara>
<programlisting language="java" linenumbering="unnumbered">physics.addSpring(spring);</programlisting>
</section>
<section id="chapter05_section17">
<title>5.17 Putting It All Together: A Simple Interactive Spring</title>
<simpara>One thing we saw with Box2D is that the physics simulation broke down when we overrode it and manually set the location of a Body. With toxiclibs’ VerletPhysics, we don’t have this problem.  If we want to move the location of a Particle, we can simply set its x and y location manually.  However, before we do so, it’s generally a good idea to call the <emphasis role="strong"><phrase role="function">lock()</phrase></emphasis> function.</simpara>
<simpara><emphasis role="strong"><phrase role="function">lock()</phrase></emphasis> is typically used to lock a Particle in place and is identical to setting a Box2D body’s density to zero.   However, here we are going to show how to lock a particle temporarily, move it, and then unlock it so that it continues to move according to the physics simulation.
 Let’s say you want to move a given particle whenever you click the mouse.</simpara>
<programlisting language="java" linenumbering="unnumbered">  if (mousePressed) {
    // First lock the particle, then set the x and y, then unlock() it
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
  }</programlisting>
<simpara>And now we’re ready to put all of these elements together in a simple example that connects two particles with a Spring.  One Particle is locked in place, and the other can be moved by dragging the mouse.  Note that this example is virtually identical to <link linkend="chapter03_example11">Example 3.11</link>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex12.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex12.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example10"><emphasis role="strong"><phrase role="example">Example 5.10: Simple Spring with toxiclibs</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;

VerletPhysics2D physics;
Particle p1;
Particle p2;

void setup() {
  size(200,200);

  // Creating a physics world
  physics=new VerletPhysics2D();
  physics.addBehavior(new GravityBehavior2D(new Vec2D(0,0.5)));
  physics.setWorldBounds(new Rect(0,0,width,height));

  // Creating 2 Particles
  p1 = new Particle(new Vec2D(100,20));
  p2 = new Particle(new Vec2D(100,180));
  // Locking Particle 1 in place
  p1.lock();

  // Creating 1 Spring
  VerletSpring2D spring=new VerletSpring2D(p1,p2,80,0.01);

  // Must add everything to the world
  physics.addParticle(p1);
  physics.addParticle(p2);
  physics.addSpring(spring);
}

void draw() {
  // Must update the physics
  physics.update();

  background(255);

  // Drawing everything
  line(p1.x,p1.y,p2.x,p2.y);
  p1.display();
  p2.display();

  if (mousePressed) {
    // Moving a Particle according to the Mouse
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
  }
}

// How cute is our simple Particle class?!
class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    super(loc);
  }

  void display() {
    fill(175);
    stroke(0);
    ellipse(x,y,16,16);
  }
}</programlisting>
</section>
<section id="chapter05_section18">
<title>5.18 Connected Systems Part I: String</title>
<simpara>The above example, two particles connected with a single spring, is the core building block for what toxiclibs’ VerletPhysics is particularly well suited for: soft body simulations.  For example, a string can be simulated by connecting a line of particles with springs.  A blanket can be simulated by connecting a grid of particles with springs.  And a cute, cuddly, squishy cartoon character can be simulated by a custom layout of particles connected with springs.</simpara>
<informalfigure id="chapter05_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_16.png" />
  </imageobject>
  <textobject><phrase>Figure 5.16</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s begin by simulating a “soft pendulum”—a bob hanging from a string, instead of a rigid arm like we had in <link linkend="chapter03_example10">Chapter 3 Example 10</link>.  Let’s use Figure <emphasis role="strong"><phrase role="REF">3.x</phrase></emphasis> above as our model. <emphasis role="strong"><phrase role="notetoself">unsure which figure this talking about</phrase></emphasis></simpara>
<simpara>First, we’ll need a list of Particle objects (let’s use the same Particle class we built in the previous example).</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;Particle&gt; particles = new ArrayList&lt;Particle&gt;();</programlisting>
<simpara>Now, let’s say we want to have 20 particles, all spaced 10 pixels apart.</simpara>
<informalfigure id="chapter05_figure17">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_17.png" />
  </imageobject>
  <textobject><phrase>Figure 5.17</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">float len = 10;
float numParticles = 20;</programlisting>
<simpara>We can loop from i equals 0 all the way up to 20, with each Particle’s y location set to i * 10 so that the first particle is at (0,10), the second at (0,20), the third at (0,30), etc.</simpara>
<programlisting language="java" linenumbering="unnumbered">for(int i=0; i &lt; numPoints; i++) {
  // Spacing them out along the x-axis
  Particle particle=new Particle(i*len,10);
  // Add particle to our list.
  physics.addParticle(particle);
  // Add particle to the physics world.
  particles.add(particle);
}</programlisting>
<simpara>Even though it’s a bit redundant, we’re going to add the Particle to both the toxiclibs physics world and to our own list.  In case we eventually have multiple strings, this will allow us to know which particles are connected to which strings.</simpara>
<simpara>Now for the fun part: It’s time to connect all the particles.  Particle 1 will be connected to particle 0, particle 2 to particle 1, 3 to 2, 4 to 3, etc.</simpara>
<informalfigure id="chapter05_ee18">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_18.png" />
  </imageobject>
  <textobject><phrase>Figure 5.18</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
In other words, Particle i needs to be connected to Particle i-1 (except for when i = 0).</simpara>
<programlisting language="java" linenumbering="unnumbered">if (i != 0) {
  // First we need a reference to the previous particle.
  Particle previous = particles.get(i-1);

  // Then we make a spring connection between particle and previous
  // particle with a rest length and strength (both floats).
  VerletSpring2D spring = new VerletSpring2D(particle,previous,len,strength);

  // We must not forget to add the spring to the physics world.
  physics.addSpring(spring);
}</programlisting>
<simpara>Now, what if we want the string to hang from a fixed point?  We can lock one of the particles—the first, the last, the middle one, etc.  Here’s how we would access the first particle (in the ArrayList) and lock it.</simpara>
<programlisting language="java" linenumbering="unnumbered">Particle head=particles.get(0);
head.lock();</programlisting>
<simpara>And if we want to draw all the particles connected with a line along with a circle for the last particle, we can use <emphasis role="strong"><phrase role="function">beginShape()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">endShape()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">vertex()</phrase></emphasis>, accessing the particle locations from our ArrayList.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex13.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex13.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example11"><emphasis role="strong"><phrase role="example">Example 5.11: Soft swinging pendulum</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">stroke(0);
noFill();
beginShape();
for (Particle p : particles) {
  // Each particle is one point in the line.
  vertex(p.x,p.y);
}
endShape();
Particle tail = particles.get(numPoints-1);
// This draws the last particle as a circle.
tail.display();</programlisting>
<simpara>The full code available with the chapter download also demonstrates how to drag the tail particle with the mouse.</simpara>
<example id="chapter05_exercise13">
<title>Exercise 5.13</title>
<simpara>Exercise: Create a hanging cloth simulation using the technique above, but connect all the particles with a grid as demonstrated in the screenshot below.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc13.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc13.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter05_section19">
<title>5.19 Connected Systems Part II: Force-Directed Graph</title>
<simpara>Have you ever encountered the following scenario?</simpara>
<simpara>“I have a whole bunch of stuff I want to draw on the screen and I want all that stuff to be spaced out evenly in a nice, neat, organized manner.  Otherwise I have trouble sleeping at night.”</simpara>
<simpara>This is not an uncommon problem in computational design. One solution is typically referred to as a “force-directed graph.”  A force-directed graph is a visualization of elements—let’s call them “nodes”—in which the positions of those nodes are not manually assigned. Rather, the nodes arrange themselves according to a set of forces.  While any forces can be used, a typical example involves spring forces.  And so toxiclibs is perfect for this scenario.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex14.png" classname="three-col" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex14.png</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex15.png" classname="three-col" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex15.png</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex16.png" classname="three-col" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex16.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>How do we implement the above?</simpara>
<simpara>First, we’ll need a Node class.  This is the easy part; it can extend VerletParticle2D.  Really, this is just what we did before, only we’re calling it Node now instead of Particle.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Node extends VerletParticle2D {
  Node(Vec2D pos) {
    super(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    ellipse(x,y,16,16);
  }
}</programlisting>
<simpara>Next we can write a class called Cluster, which will describe a list of Nodes.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Cluster {

  ArrayList&lt;Node&gt; nodes;

  // We’ll use this variable for the rest
  // length between all the nodes.
  float diameter;

  Cluster(int n, float d, Vec2D center) {
    nodes = new ArrayList&lt;Node&gt;();
    diameter = d;

    for (int i = 0; i &lt; n; i++) {
      // Here’s a funny little detail.  We’re going to have a problem
      // if all the Node objects start in exactly the same location.
      // So we add a random vector to the center location so that each
      // Node is slightly offset.
      nodes.add(new Node(center.add(Vec2D.randomVector())));

    }
  }</programlisting>
<simpara>Let’s assume we added a <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> function to draw all the Node objects in the Cluster and then created a Cluster object <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and displayed it in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>. If we ran the sketch as is, nothing would happen.  Why?  Because we forgot the whole force-directed graph part!  We need to connect every single Node to every other Node with a force.   But what exactly do we mean by that?  Let’s assume we have four Node objects: 0, 1, 2 and 3.  Here are our connections:</simpara>
<simpara><emphasis role="strong"><phrase role="mono">0 connected to 1<?asciidoc-br?>
0 connected to 2<?asciidoc-br?>
0 connected to 3<?asciidoc-br?>
1 connected to 2<?asciidoc-br?>
1 connected to 3<?asciidoc-br?>
2 connected to 3</phrase></emphasis></simpara>
<simpara>Notice two important details about our connection list.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>No Node is connected to itself.</emphasis></emphasis>  We don’t have 0 connected to 0 or 1 connected to 1.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>We don’t need to repeat connections in reverse.</emphasis></emphasis>  In other words, if we’ve already said 0 is connected to 1, we don’t need to say 1 is connected to 0 because, well, it already is!
</simpara>
</listitem>
</itemizedlist>
<simpara>So how do we write code to make these connections for N number of nodes?</simpara>
<simpara>Look at the left column. It reads:  000 11 22.  So we know we need to access each Node in the list from 0 to N-1.</simpara>
<programlisting language="java" linenumbering="unnumbered">    for (int i = 0; i &lt; nodes.size()-1; i++) {
      VerletParticle2D ni = nodes.get(i);</programlisting>
<simpara>Now, we know we need to connect Node 0 to Nodes 1,2,3.  For Node 1: 2,3.  For Node 2: 3.  So for every Node i, we must loop from i+1 until the end of the list.</simpara>
<programlisting language="java" linenumbering="unnumbered">      // Look how we start j at i + 1.
      for (int j = i+1; j &lt; nodes.size(); j++) { // [bold]
        VerletParticle2D nj = nodes.get(j);</programlisting>
<simpara>With every two Nodes we find, all we have to do then is make a VerletSpring2D.</simpara>
<programlisting language="java" linenumbering="unnumbered">        // The Spring connects Nodes “ni” and “nj”.
        physics.addSpring(new VerletSpring2D(ni,nj,diameter,0.01));
      }
    }</programlisting>
<simpara>Assuming those connections are made in the Cluster constructor, we can now create a Cluster in our main tab and see the results!</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex17.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex17.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example12"><emphasis role="strong"><phrase role="example">Example 5.12: Cluster</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">import toxi.geom.*;
import toxi.physics2d.*;

VerletPhysics2D physics;
Cluster cluster;

void setup() {
  size(300,300);
  physics=new VerletPhysics2D();
  // Make a cluster.
  cluster = new Cluster(8,100,new Vec2D(width/2,height/2));
}

void draw() {
  physics.update();
  background(255);
  // Draw the Cluster.
  cluster.display();
}</programlisting>
<example id="chapter05_exercise14">
<title>Exercise 5.14</title>
<simpara>Exercise: Use the Cluster structure as a skeleton for a cute, cuddly, squishy creature (à la “Nokia Friends”).  Add gravity and also allow the creature to be dragged with the mouse.</simpara>
</example>
<example id="chapter05_exercise15">
<title>Exercise 5.15</title>
<simpara>Exercise: Expand the force-directed graph to have more than one Cluster object.  Use a VerletMinDistanceSpring2D to connect Cluster to Cluster.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_exc15.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_exc15.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter05_section20">
<title>5.20 Attraction and Repulsion Behaviors</title>
<simpara>When we looked at adding an attraction force to Box2D, we found that the Box2D Body object included an <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.  All we needed to do was calculate the attraction force (Force = G * mass1 * mass2 / distance squared) as a vector and apply it to the Body.  toxiclibs also includes a function called <emphasis role="strong"><phrase role="function">addForce()</phrase></emphasis> that we can use to apply any calculated force to a VerletParticle.</simpara>
<simpara>However, toxiclibs also takes this idea one step further by allowing us to attach some common forces (let’s call them “Behaviors”) to VerletParticles, calculating them and applying them for us!  For example, if we attach an AttractionBehavior to a VerletParticle, then all other particles in the physics world will be attracted to that particle.</simpara>
<simpara>Let’s say we have a Particle object (which extends VerletParticle).</simpara>
<programlisting language="java" linenumbering="unnumbered">Particle p = new Particle(new Vec2D(200,200));</programlisting>
<simpara>Once we have that Particle, we can create an AttractionBehavior object associated with that Particle.</simpara>
<programlisting language="java" linenumbering="unnumbered">float distance = 20;
float strength = 0.1;
AttractionBehavior behavior = new AttractionBehavior(p, distance, strength);</programlisting>
<simpara>Notice how the behavior is created with two parameters—distance and strength.  The distance specifies the range within which the behavior will be applied.  For example, in the above scenario, only other Particle objects within twenty pixels will feel the Attraction force.  The strength, of course, specifies how strong the force is.</simpara>
<simpara>Finally, in order for the force to be activated, the behavior needs to be added to the physics world.</simpara>
<programlisting language="java" linenumbering="unnumbered">physics.addBehavior(behavior);</programlisting>
<simpara>This means everything that lives in the physics simulation will always be attracted to that Particle object, as long as it is within the distance threshold.</simpara>
<simpara>Even though toxiclibs does not handle collisions, you can create a collision-like effect by adding a repulsive behavior to each and every Particle (so that every Particle repels every other Particle).  Let’s look at how we might modify our Particle class to do this.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Particle extends VerletParticle2D {

  // We’ve added a radius to every Particle.
  float r;

  Particle (Vec2D loc) {
    super(loc);
    r = 4;
    // Every time a Particle is made, an AttractionBehavior is
    // generated and added to the physics world.
    // Note that when the strength
    // is negative, it’s a repulsive force!
    physics.addBehavior(new AttractionBehavior(this, r*4, -1));
  }

  void display () {
    fill (255);
    stroke (255);
    ellipse (x, y, r*2, r*2);
  }
}</programlisting>
<simpara>We could now recreate our Attraction example by having a single Attractor object that exerts an AttractionBehavior over the entire window.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter05/ch05_ex18.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter05/ch05_ex18.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter05_example13"><emphasis role="strong"><phrase role="example">Example 5.13: Attraction/Repulsion</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Attractor extends VerletParticle2D {

  float r;

  Attractor (Vec2D loc) {
    super (loc);
    r = 24;
    // The AttractionBehavior “distance” equals
    // the width so that it covers the entire window.
    physics.addBehavior(new AttractionBehavior(this, width, 0.1));
  }

  void display () {
    fill(0);
    ellipse (x, y, r*2, r*2);
  }
}</programlisting>
<example id="chapter05_exercise16">
<title>Exercise 5.16</title>
<simpara>Create an object that both attracts and repels.  What if it attracts any Particle that are far away but repels those Particles at a short distance?</simpara>
</example>
<example id="chapter05_exercise17">
<title>Exercise 5.17</title>
<simpara>Use AttractionBehavior in conjunction with Spring forces.</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 5 Exercise:</simpara>
<simpara>Take your system of creatures from Step 4 and use a physics engine to drive their motion and behaviors.  Some possibilities:</simpara>
<simpara>Use Box2D to allow collisions between creatures.  Consider triggering events when creatures collide.
Use Box2D to augment the design of your creatures.  Build a skeleton with distance joints or make appendages with revolute joints?
Use toxiclibs to augment the design of your creature. Use a chain of toxiclibs particles for tentacles or a mesh of springs as a skeleton.
Use toxiclibs to add attraction and repulsion behaviors to your creatures.
Use spring (or joint) connections between objects to control their interactions.  What if you create and delete these springs on the fly?  Consider making these connections visible or invisible to the viewer.</simpara>
</tip>
</section>
</chapter>
<chapter id="_chapter_6_autonomous_agents">
<title>Chapter 6.  Autonomous Agents</title>
<blockquote>
<attribution>
Valentino Braitenberg
</attribution>
<simpara>“This is an exercise in fictional science, or science fiction, if you like that better.”</simpara>
</blockquote>
<simpara>Believe it or not, there is a purpose.  Well, at least there’s a purpose for the first five chapters of this book.   We could stop right here; after all, we’ve looked at several different ways of modeling motion and simulating physics.  Angry Birds, here we come!</simpara>
<simpara>Still, let’s think for a moment.  Why are we here?   The <emphasis>nature</emphasis> of code, right?   What have we been designing so far?   Inanimate objects.  Lifeless shapes sitting on our screens that flop around when affected by forces in their environment.   What if we could breathe life into those shapes? What if those shapes could live by their own rules?  Can shapes have hopes and dreams and fears?   This is what we are here in this chapter to do—develop <emphasis>autonomous agents</emphasis>.</simpara>
<section id="chapter06_section1">
<title>6.1  Forces from Within</title>
<simpara>The term <emphasis role="strong"><emphasis>autonomous agent</emphasis></emphasis> generally refers to an entity that makes its own choices about how to act in its environment without any influence from a leader or global plan.  For us, “acting” will mean moving.   This addition is a significant conceptual leap.  Instead of a box sitting on a boundary waiting to be pushed by another falling box, we are now going to design a box that has the ability and “desire” to leap out of the way of that other falling box, if it so chooses.   While the concept of forces that come from within is a major shift in our design thinking, our code base will barely change, as these desires and actions are simply that—<emphasis>forces</emphasis>.</simpara>
<simpara>Here are three key components of autonomous agents that we’ll want to keep in mind as we build our examples.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong">An autonomous agent has a <emphasis>limited</emphasis> ability to perceive environment.</emphasis>   It makes sense that a living, breathing being should have an awareness of its environment.  What does this mean for us, however?   As we look at examples in this chapter, we will point out programming techniques for allowing objects to store references to other objects and therefore “perceive” their environment.    It’s also crucial that we consider the word <emphasis role="strong"><emphasis>limited</emphasis></emphasis> here.  Are we designing an all-knowing rectangle that flies around a Processing window, aware of everything else in that window?  Or are we creating a shape that can only examine any other object within fifteen pixels of itself?   Of course, there is no right answer to this question; it all depends.  We’ll explore some possibilities as we move forward.  For a simulation to feel more “natural,” however, limitations are a good thing.  An insect, for example, may only be aware of the sights and smells that immediately surround it.   For a real-world creature, we could study the exact science of these limitations.   Luckily for us, we can just make stuff up and try it out.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">An autonomous agent processes the information from its environment and calculates an action.</emphasis>    This will be the easy part for us, as the action is a force.  The environment might tell the agent that there’s a big scary-looking shark swimming right at it, and the action will be a powerful force in the opposite direction.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">An autonomous agent has no leader.</emphasis>  This third principle is something we care a little less about.  After all, if you are designing a system where it makes sense to have a leader barking commands at various entities, then that’s what you’ll want to implement.  Nevertheless, many of these examples will have no leader for an important reason.   As we get to the end of this chapter and examine group behaviors, we will look at designing collections of autonomous agents that exhibit the properties of complex systems— intelligent and structured group dynamics that emerge not from a leader, but from the local interactions of the elements themselves.
</simpara>
</listitem>
</itemizedlist>
<simpara>In the late 1980s, computer scientist <ulink url="http://www.red3d.com/cwr/">Craig Reynolds</ulink> developed algorithmic steering behaviors for animated characters. These behaviors allowed individual elements to navigate their digital environments in a “lifelike” manner with strategies for fleeing, wandering, arriving, pursuing, evading, etc. Used in the case of a single autonomous agent, these behaviors are fairly simple to understand and implement. In addition, by building a system of multiple characters that steer themselves according to simple, locally based rules, surprising levels of complexity emerge.  The most famous example is Reynolds’s “boids” model for “flocking/swarming” behavior.</simpara>
</section>
<section id="chapter06_section2">
<title>6.2  Vehicles and Steering</title>
<simpara>Now that we understand the core concepts behind autonomous agents, we can begin writing the code.  There are many places we could start. Artificial simulations of ant and termite colonies are fantastic demonstrations of systems of autonomous agents. (For more on this topic, I encourage you to read <emphasis>Turtles, Termites, and Traffic Jams</emphasis> by Mitchel Resnick.)  However, we want to start by examining agent behaviors that build on the work we’ve done in the first five chapters of this book: modeling motion with vectors and driving motion with forces.  And so it’s time to rename our Mover class that became our Particle class once again.  This time we are going to call it <emphasis role="strong"><phrase role="class">Vehicle</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {

  PVector location;
  PVector velocity;
  PVector acceleration;

  [inline]// What else do we need to add?</programlisting>
<simpara>In his 1999 paper “Steering Behaviors for Autonomous Characters,” Reynolds uses the word “Vehicle” to describe his autonomous agents, so we will follow suit.</simpara>
<note>
<title>Why Vehicle?</title>
<simpara>In 1986, Italian neuroscientist and cyberneticist Valentino Braitenberg described a series of hypothetical vehicles with simple internal structures in his book Vehicles: Experiments in Synthetic Psychology.  Braitenberg argues that his extraordinarily simple mechanical vehicles manifest behaviors such as fear, aggression, love, foresight, and optimism.  Reynolds took his inspiration from Braitenberg, and we’ll take ours from Reynolds.</simpara>
</note>
<simpara>Reynolds describes the motion of <emphasis>idealized</emphasis> vehicles (idealized because we are not concerned with the actual engineering of such vehicles, but simply assume that they exist and will respond to our rules)as a series of three layers—Action Selection, Steering, and Locomotion.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Action Selection.</emphasis></emphasis>   A Vehicle has a goal (or goals) and can select an action (or a combination of actions) based on that goal.  This is essentially where we left off with autonomous agents.  The vehicle takes a look at its environment and calculates an action based on a desire: “I see a zombie marching towards me. Since I don’t want my brains to be eaten, I’m going to flee from the zombie.”   The goal is to keep one’s brains and the action is to flee.   Reynolds’s paper describes many goals and associated actions such as: seek a target, avoid an obstacle, and follow a path.  In a moment, we’ll start building these examples out with Processing code.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Steering.</emphasis></emphasis>  Once an action has been selected, the vehicle has to calculate its next move.  For us, the next move will be a force; more specifically, a steering force.  Luckily, Reynolds has developed a simple steering force formula that we’ll use throughout the examples in this chapter: Steering Force = Desired Velocity minus Current Velocity.  We’ll get into the details of this formula and why it works so effectively in the next section.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Locomotion.</emphasis></emphasis>  For the most part, we’re going to ignore this third layer.   In the case of fleeing zombies, the locomotion could be described as “left foot, right foot, left foot, right foot, as fast as you can.”   In our Processing world, however, a rectangle or circle or triangle’s actual movement across a window is irrelevant given that it’s all an illusion in the first place.  Nevertheless, this isn’t to say that you should ignore locomotion.   You will find great value in thinking about the locomotive design of your vehicle and how you choose to animate it.   The examples in this chapter will remain visually bare, and a good exercise would be to elaborate on the animation style —could you add spinning wheels or oscillating paddles or shuffling legs?
</simpara>
</listitem>
</orderedlist>
<simpara>Ultimately, the most important layer for you to consider is #1—<emphasis>Action Selection</emphasis>.  What are the elements of your system and what are their goals?  In this chapter, we are going to look at a series of steering behaviors (i.e. actions): seek, flee, follow a path, follow a flow field, flock with your neighbors, etc.   It’s important to realize, however, that the point of understanding how to write the code for these behaviors is not because you should use them in all of your projects.  Rather, these are a set of building blocks, a foundation from which you can design and develop vehicles with creative goals and new and exciting behaviors.   And even though we will think literally in this chapter (follow that pixel), you should allow yourself to think more abstractly (like Braitenberg). What would it mean for your vehicle to have “love” or “fear” as its goal, its driving force?    Finally (and we’ll address this later in the chapter) you won’t get very far by developing simulations with only one action.  Yes, our first example will be “seek a target.”  But for you to be creative—to make these steering behaviors _your own_—it will all come down to mixing and matching multiple actions within the same vehicle.  So view these examples not as singular behaviors to be emulated, but as pieces of a larger puzzle that you will eventually assemble.</simpara>
</section>
<section id="chapter06_section3">
<title>6.3  The Steering Force</title>
<simpara>We can entertain ourselves by discussing the theoretical principles behind autonomous agents and steering as much as we like, but we can’t get anywhere without first understanding the concept of a steering force. Consider the following scenario.  A “Vehicle” moving with velocity desires to seek a target.</simpara>
<informalfigure id="chapter06_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_01.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Its goal and subsequent action is to seek the target in Figure 6.1.  If you think back to Chapter 2, you might begin by making the target an “attractor” and apply a gravitational force that pulls the vehicle to the target.  This would be a perfectly reasonable solution, but conceptually it’s not what we’re looking for here.   We don’t want to simply calculate a force that pushes the Vehicle towards its target; rather, we are asking the Vehicle to make an intelligent decision to steer towards the target based on its perception of its state and environment (i.e. how fast and in what direction is it currently moving).   The vehicle should look at how it desires to move (a vector pointing to the target), compare that goal with how quickly it is currently moving (its velocity), and apply a force accordingly.</simpara>
<simpara><emphasis role="strong"><emphasis>STEERING FORCE = DESIRED VELOCITY - CURRENT VELOCITY</emphasis></emphasis></simpara>
<simpara>Or as we might write in Processing:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector steer = PVector.sub(desired,velocity);</programlisting>
<simpara>In the above formula, velocity is no problem.  After all, we’ve got a variable for that.   However, we don’t have the desired velocity; this is something we have to calculate.  Let’s take a look at Figure 6.2.   If we’ve defined the vehicle’s goal as “seeking the target,” then its desired velocity is a vector that points from its current location to the target location.</simpara>
<informalfigure id="chapter06_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_02.png" />
  </imageobject>
  <textobject><phrase>Figure 6.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Assuming a PVector target, we then have:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector desired = PVector.sub(target,location);</programlisting>
<simpara>But this isn’t particularly realistic.  What if we have a very high-resolution window and the target is thousands of pixels away?  Sure, the vehicle might desire to teleport itself instantly to the target location with a massive velocity, but this won’t make for an effective animation.  What we really want to say is:</simpara>
<simpara><emphasis>The vehicle desires to move towards the target at maximum speed.</emphasis></simpara>
<simpara>In other words, the vector should point from location to target and with a magnitude equal to maximum speed (i.e. the fastest the vehicle can go).   So first, we need to make sure we add a variable in our Vehicle class to store maximum speed.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Maximum speed
  float maxspeed;</programlisting>
<simpara>Then, in our desired velocity calculation, we scale according to maximum speed.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector desired = PVector.sub(target,location);
desired.normalize();
desired.mult(maxspeed);</programlisting>
<informalfigure id="chapter06_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_03.png" />
  </imageobject>
  <textobject><phrase>Figure 6.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Putting this all together, we can write a function called <emphasis role="strong"><phrase role="function">seek()</phrase></emphasis> that receives a <emphasis role="strong"><phrase role="klass">PVector</phrase></emphasis> target and calculates a steering force towards that target.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    // Calculating the desired velocity
    // to target at max speed
    desired.mult(maxspeed);

    // Reynolds’s formula for steering force
    PVector steer = PVector.sub(desired,velocity);
    // Using our physics model and applying the force
    // to the object’s acceleration
    applyForce(steer);
  }</programlisting>
<simpara>Note how in the above function we finish by passing the steering force into <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis>.  This assumes that we are basing this example on the foundation we built in <link linkend="chapter02_section2">Chapter 2</link>.  However, you could just as easily use the steering force with Box2D’s <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function or toxiclibs’ <emphasis role="strong"><phrase role="function">addForce()</phrase></emphasis> function.</simpara>
<simpara>So why does this all work so well?  Let’s see what the steering force looks like relative to the vehicle and target locations.</simpara>
<informalfigure id="chapter06_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_04.png" />
  </imageobject>
  <textobject><phrase>Figure 6.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Again, notice how this is not at all the same force as gravitational attraction.  Remember one of our principles of autonomous agents: An autonomous agent has a <emphasis>limited</emphasis> ability to perceive its environment.  Here is that ability, subtly embedded into Reynolds’s steering formula.  If the vehicle weren’t moving at all (zero velocity), desired minus velocity would be equal to desired.  But this is not the case.  The vehicle is aware of its own velocity and its steering force compensates accordingly.   This creates a more active simulation, as the way in which the vehicle moves towards the targets depends on the way it is moving in the first place.</simpara>
<simpara>In all of this excitement, however, we’ve missed one last step.  What sort of vehicle is this?  Is it a super sleek race car with amazing handling?  Or a giant Mack truck that needs a lot of advance notice to turn?   A graceful panda, or a lumbering elephant?  Our example code, as it stands, has no feature to account for this variability in steering ability.   Steering ability can be controlled by limiting the magnitude of the steering force.  Let’s call that limit the “maximum force” (or “maxforce” for short).  And so finally, we have:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {
  PVector location;
  PVector velocity;
  PVector acceleration;
  // Maximum speed
  float maxspeed;
  // Now we also have maximum force.
  float maxforce;</programlisting>
<simpara>followed by:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);

    // Limit the magnitude of the steering force.
    steer.limit(maxforce);

    applyForce(steer);
  }</programlisting>
<simpara>Limiting the steering force brings up an important point.  We must always remember that it’s not actually our goal to get the Vehicle to the target as fast as possible.  If that were the case, we would just say “location equals target” and there the vehicle would be.  Our goal, as Reynolds puts it, is to move the vehicle in a “lifelike and improvisational manner.”  We’re trying to make it appear as if the vehicle is steering its way to the target, and so it’s up to us to play with the forces and variables of the system to simulate a given behavior.  For example, a large maximum steering force would result in a very different path than a small one.  One is not inherently better or worse than the other; it depends on your desired effect.  (And of course, these values need not be fixed and could change based on other conditions.  Perhaps a vehicle has health: the higher the health, the better it can steer.)</simpara>
<informalfigure id="chapter06_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_05.png" />
  </imageobject>
  <textobject><phrase>Figure 6.5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here is the full Vehicle class, incorporating the rest of the elements from the Chapter 2 “Mover” object.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex1.png" canvas="processingjs/chapter06/_6_01_Seek/_6_01_Seek.pde processingjs/chapter06/_6_01_Seek/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex1.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example1"><emphasis role="strong"><phrase role="example">Example 6.1: Seeking a target</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {

  PVector location;
  PVector velocity;
  PVector acceleration;
  // Additional variable for size
  float r;
  float maxforce;
  float maxspeed;

  Vehicle(float x, float y) {
    acceleration = new PVector(0,0);
    velocity = new PVector(0,0);
    location = new PVector(x,y);
    r = 3.0;
    // Arbitrary values for maxspeed and
    // force; try varying these!
    maxspeed = 4;
    maxforce = 0.1;
  }

  // Our standard “Euler integration” motion model
  void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    location.add(velocity);
    acceleration.mult(0);
  }

  // Newton’s second law; we could divide by mass if we wanted.
  void applyForce(PVector force) {
    acceleration.add(force);
  }

  // Our seek steering force algorithm
  void seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }

  void display() {
    // Vehicle is a triangle pointing in
    // the direction of velocity; since it is drawn
    // pointing up, we rotate it an additional 90 degrees.
    float theta = velocity.heading2D() + PI/2;
    fill(175);
    stroke(0);
    pushMatrix();
    translate(location.x,location.y);
    rotate(theta);
    beginShape();
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape(CLOSE);
    popMatrix();
  }</programlisting>
<example id="chapter06_exercise1">
<title>Exercise 6.1</title>
<simpara>Implement a “fleeing” steering behavior (desired vector is inverse of “seek”).</simpara>
</example>
<example id="chapter06_exercise2">
<title>Exercise 6.2</title>
<simpara>Implement seeking a moving target, often referred to as “pursuit.”  In this case, your desired vector won’t point towards the object’s current location, but rather its “future” location as extrapolated from its current velocity.   We’ll see this ability for a Vehicle to “predict the future” in later examples.</simpara>
</example>
<example id="chapter06_exercise3">
<title>Exercise 6.3</title>
<simpara>Create a sketch where a Vehicle’s maximum force and maximum speed do not remain constant, but rather vary according to environmental factors.</simpara>
</example>
</section>
<section id="chapter06_section4">
<title>6.4  Arriving Behavior</title>
<simpara>After working for a bit with the seeking behavior, you probably are asking yourself,  “What if I want my vehicle to slow down as it approaches the target?”   Before we can even begin to answer this question, we should look at the reasons behind why the seek behavior causes the vehicle to fly past the target so that it has to turn around and go back.  Let’s consider the brain of a seeking vehicle.  What is it thinking?</simpara>
<simpara>Frame 1: I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 2: I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 3: I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 4: I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 5: I want to go as fast as possible towards the target!<?asciidoc-br?>
etc.</simpara>
<simpara>The Vehicle is so gosh darn excited about getting to the target that it doesn’t bother to make any intelligent decisions about its speed relative to the target’s proximity.  Whether it’s far away or very close, it always wants to go as fast as possible.</simpara>
<informalfigure id="chapter06_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_06.png" />
  </imageobject>
  <textobject><phrase>Figure 6.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In some cases, this is the desired behavior (if a missile is flying at a target, it should always travel at maximum speed).  However, in many other cases (a car pulling into a parking spot, a bee landing on a flower), the Vehicle’s thought process needs to consider its speed relative to the distance from its target.  For example:</simpara>
<simpara>Frame 1: I’m very far away. I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 2: I’m very far away. I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 3: I’m somewhat far away. I want to go as fast as possible towards the target!<?asciidoc-br?>
Frame 4: I’m getting close. I want to go more slowly towards the target!<?asciidoc-br?>
Frame 5: I’m almost there. I want to go very slowly towards the target!<?asciidoc-br?>
Frame 6: I’m there. I want to stop!</simpara>
<informalfigure id="chapter06_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_07.png" />
  </imageobject>
  <textobject><phrase>Figure 6.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>How can we implement this “arriving” behavior in code?  Let’s return to our <emphasis role="strong"><phrase role="function">seek()</phrase></emphasis> function and find the line of code where we set the magnitude of the desired velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">   PVector desired = PVector.sub(target,location);
   desired.normalize();
   desired.mult(maxspeed);</programlisting>
<simpara>In the Example 6.1, the magnitude of the desired vector is always “maximum” speed.</simpara>
<informalfigure id="chapter06_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_08.png" />
  </imageobject>
  <textobject><phrase>Figure 6.8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>What if we instead said the desired velocity is equal to half the distance?</simpara>
<informalfigure id="chapter06_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_09.png" />
  </imageobject>
  <textobject><phrase>Figure 6.9</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">   PVector desired = PVector.sub(target,location);
   desired.div(2);</programlisting>
<simpara>While this nicely demonstrates our goal of a desired speed tied to our distance from the target, it’s not particularly reasonable.  After all, 10 pixels away is rather close and a desired speed of 5 is rather large.   Something like a desired velocity with a magnitude of 5% of the distance would work much better.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector desired = PVector.sub(target,location);
  desired.mult(0.05);</programlisting>
<simpara>Reynolds describes a more sophisticated approach.  Let’s imagine a circle around the target with a given radius.  If the Vehicle is within that circle it slows down—at the edge of the circle its desired speed is maximum speed, and at the target itself its desired speed is 0.</simpara>
<informalfigure id="chapter06_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_10.png" />
  </imageobject>
  <textobject><phrase>Figure 6.10</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In other words, if the distance from the target is less than r, the desired speed is between 0 and maximum speed mapped according to that distance.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex2.png" canvas="processingjs/chapter06/_6_02_Arrive/_6_02_Arrive.pde processingjs/chapter06/_6_02_Arrive/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex2.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example2"><emphasis role="strong"><phrase role="example">Example 6.2: Arrive steering behavior</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void arrive(PVector target) {
    PVector desired = PVector.sub(target,location);

    // The distance is the magnitude of
    // the vector pointing from
    // location to target.
    float d = desired.mag();
    desired.normalize();
    // If we are closer than 100 pixels...
    if (d &lt; 100) {
      // ...set the magnitude
      // according to how close desired.mult(m);
      float m = map(d,0,100,0,maxspeed);
    } else {
      // Otherwise, proceed at maximum speed.
      desired.mult(maxspeed);
    }

    // The usual steering = desired - velocity
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }</programlisting>
<simpara>The arrive behavior is a great demonstration of the magic of “desired minus velocity.”   Let’s examine this model again relative to how we calculated forces in earlier chapters.   In the “gravitational attraction” examples, the force always pointed directly from the object to the target (the exact direction of the desired velocity), whether the force was strong or weak.</simpara>
<simpara>The steering function, however, says: “I have the ability to perceive the environment.”  The force isn’t based just on the desired velocity, but on the desired velocity relative to the current velocity.   Knowing your current velocity is only something that things that are alive can do.  A box falling off a table doesn’t know it’s falling.  A cheetah chasing its prey, however, knows it is chasing.</simpara>
<simpara>The steering force, therefore, is essentially a manifestation of the current velocity’s <emphasis role="strong"><emphasis>error</emphasis></emphasis>:  I’m supposed to be going this fast in this direction, but I’m actually going this fast in this other direction.   My error is the difference between where I want to go and where I am currently going.  Taking that error and applying it as a steering force results in more dynamic, life-like simulations.   With gravitational attraction, you would never have a force pointing away from the target, no matter how close. But with arriving via steering, if you are moving too fast towards the target, the error would actually tell you to slow down!</simpara>
<informalfigure id="chapter06_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_11.png" />
  </imageobject>
  <textobject><phrase>Figure 6.11</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section id="chapter06_section5">
<title>6.5 Your Own Desires: Desired Velocity</title>
<simpara>The first two examples we’ve covered—seek and arrive—boil down to calculating a single vector for each behavior: the <emphasis role="strong"><emphasis>desired</emphasis></emphasis> velocity.  And in fact, every single one of Reynolds’s steering behaviors follows this same pattern.  In this chapter, we’re going to walk through several more of Reynolds’s behaviors—flow field, path-following, flocking.  First, however, I want to emphasize again that these are <emphasis>examples</emphasis>—demonstrations of common steering behaviors that are useful in procedural animation.   They are not the be-all and end-all of what <emphasis role="strong"><emphasis>you</emphasis></emphasis> can do.  As long as you can come up with a vector that describes a vehicle’s <emphasis role="strong"><emphasis>desired</emphasis></emphasis> velocity, then you have created your own steering behavior.</simpara>
<simpara>Let’s see how Reynolds defines the desired velocity for his wandering behavior.</simpara>
<simpara><emphasis>“Wandering is a type of random steering which has some long term order: the steering direction on one frame is related to the steering direction on the next frame. This produces more interesting motion than, for example, simply generating a random steering direction each frame.”</emphasis>  —<ulink url="http://www.red3d.com/cwr/steer/Wander.html">Craig Reynolds</ulink></simpara>
<informalfigure id="chapter06_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_12.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For Reynolds, the goal of wandering is not simply random motion, but rather a sense of moving in one direction for a little while, wandering off to the next for a little bit, and so on and so forth.  So how does Reynolds calculate a desired vector to achieve such an effect?</simpara>
<simpara>Figure 6.12 illustrates how the vehicle predicts its future location as a fixed distance in front of it (in the direction of its velocity), draws a circle with radius <emphasis role="strong"><phrase role="var">r</phrase></emphasis> at that location, and picks a random point along the circumference of the circle.  That random point moves randomly around the circle in each frame of animation.   And that random point is the vehicle’s target, its desired vector pointing in that direction.</simpara>
<simpara>Sounds a bit absurd, right?  Or, at the very least, rather arbitrary.   In fact, this is a very clever and thoughtful solution—it uses randomness to drive a vehicle’s steering, but constrains that randomness along the path of a circle to keep the vehicle’s movement from appearing totally random and jittery.</simpara>
<simpara>But the seemingly random and arbitrary nature of this solution should drive home the point I’m trying to make—these are made-up behaviors inspired by real-life motion.  You can just as easily concoct some elaborate scenario to compute a desired velocity yourself.  And you should.</simpara>
<example id="chapter06_exercise4">
<title>Exercise 6.4</title>
<simpara>Write the code for the wander behavior.  Use polar coordinates to calculate the vehicle’s target along a circular path.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_exc4.png" canvas="processingjs/chapter06/Ex_6_04_Wander/Ex_6_04_Wander.pde processingjs/chapter06/Ex_6_04_Wander/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_exc4.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara>Let’s say we want to create a steering behavior called “stay within walls.”  We’ll define the desired velocity as:</simpara>
<informalfigure id="chapter06_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_13.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>[highlight]*
If a Vehicle comes within a distance d of a wall, it desires to move at maximum speed in the opposite direction of the wall.*</simpara>
<simpara>If we define the walls of the space as the edges of a Processing window and the distance <emphasis role="strong"><phrase role="var">d</phrase></emphasis> as 25, the code is rather simple.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex3.png" canvas="processingjs/chapter06/_6_03_StayWithinWalls/_6_03_StayWithinWalls.pde processingjs/chapter06/_6_03_StayWithinWalls/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex3.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example3"><emphasis role="strong"><phrase role="example">Example 6.3: “Stay within walls” steering behavior</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">if (location. x &gt; 25) {
  // Make a desired vector that retains the y direction of
  // the vehicle but points the x direction directly away from
  // window’s left edge
  PVector desired = new PVector(maxspeed,velocity.y);
  PVector steer = PVector.sub(desired, velocity);
  steer.limit(maxforce);
  applyForce(steer);
}</programlisting>
<example id="chapter06_exercise5">
<title>Exercise 6.5</title>
<simpara>Come up with your own arbitrary scheme for calculating a desired velocity.</simpara>
</example>
</section>
<section id="chapter06_section6">
<title>6.6  Flow Fields</title>
<simpara>Now back to the task at hand.  Let’s examine a couple more of Reynolds’s steering behaviors.  First, flow field following.  What is a flow field?   Think of your Processing window as a grid.  In each cell of the grid lives an arrow pointing in some direction—you know, a vector.   As a Vehicle moves around the screen, it asks, “Hey, what arrow is beneath me?  That’s my desired velocity!”</simpara>
<informalfigure id="chapter06_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_14.png" />
  </imageobject>
  <textobject><phrase>Figure 6.14</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Reynolds’s flow field following example has the vehicle predicting its future location and following the vector at that spot, but for simplicity’s sake, we’ll have the Vehicle simply look to the vector at its current location.</simpara>
<simpara>Before we can write the additional code for our Vehicle class, we’ll need to build a class that describes the flow field itself, the grid of vectors.   A two-dimensional array is a convenient data structure in which to store a grid of information. (If you are not familiar with 2D arrays, I suggest reviewing this online Processing tutorial: <ulink url="http://processing.org/learning/2darray/">2D array</ulink>).   The 2D array is convenient because we reference each element with two indices, which we can think of as columns and rows.</simpara>
<programlisting language="java" linenumbering="unnumbered">class FlowField {

  // Declaring a 2D array of PVectors
  PVector[][] field;
  // How many columns and how many rows in the grid?
  int cols, rows;
  // Resolution of grid relative to window
  // width and height in pixels
  int resolution;</programlisting>
<simpara>Notice how we are defining a third variable called “resolution” above.   What is this variable?  Let’s say we have a Processing window that is 200 pixels wide by 200 pixels high.  We could make a flow field that has a PVector object for every single pixel, or 40,000 PVectors (200 * 200).  This isn’t terribly unreasonable, but in our case, it’s overkill.  We don’t need a PVector for every single pixel; we can achieve the same effect by having, say, one every ten pixels (20 * 20 = 400).   We use this resolution to define the number of columns and rows based on the size of the window divided by resolution:</simpara>
<programlisting language="java" linenumbering="unnumbered">  FlowField() {
    resolution = 10;
    // Total columns equals width divided by resolution
    cols = width/resolution;
    // Total rows equals height divided by resolution
    rows = height/resolution;
    field = new PVector[cols][rows];
  }</programlisting>
<simpara>Now that we’ve set up the flow field’s data structures, it’s time to compute the vectors in the flow field itself.  How do we do that? However we feel like it!  Perhaps we want to have every vector in the flow field pointing to the right.</simpara>
<informalfigure id="chapter06_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_15.png" />
  </imageobject>
  <textobject><phrase>Figure 6.15</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">// Using a nested loop to hit every column
// and every row of the flow field
for (int i = 0; i &lt; cols; i++) {
  for (int j = 0; j &lt; rows; j++) {
    // Arbitrary decision to make each vector point to right
    field[i][j] = new PVector(1,0);
  }
}</programlisting>
<simpara>Or a random vector.</simpara>
<informalfigure id="chapter06_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_16.png" />
  </imageobject>
  <textobject><phrase>Figure 6.16</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered"> for (int i = 0; i &lt; cols; i++) {
    for (int j = 0; j &lt; rows; j++) {

      // A random PVector
      float theta = random(TWO_PI);
      field[i][j] = new PVector(cos(theta),sin(theta));
    }
  }</programlisting>
<simpara>What if we use 2D Perlin noise (mapped to an angle)?</simpara>
<informalfigure id="chapter06_figure17">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_17.png" />
  </imageobject>
  <textobject><phrase>Figure 6.17</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">  float xoff = 0;
  for (int i = 0; i &lt; cols; i++) {
    float yoff = 0;
    for (int j = 0; j &lt; rows; j++) {
      // Noise
      float theta = map(noise(xoff,yoff),0,1,0,TWO_PI);
      field[i][j] = new PVector(cos(theta),sin(theta));
      yoff += 0.1;
    }
    xoff += 0.1;
  }</programlisting>
<simpara>Now we’re getting somewhere.   Flow fields can be used for simulating various effects, such as an irregular gust of wind or the meandering path of a river.  Calculating the direction of your vectors using Perlin noise is one way to achieve such an effect.  Of course, there’s no “correct” way to calculate the vectors of a flow field; it’s really up to you to decide what you’re looking to simulate.</simpara>
<example id="chapter06_exercise6">
<title>Exercise 6.6</title>
<simpara>Write the code to calculate a PVector at every location in the flow field that points towards the center of a window.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_exc6.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_exc6.png</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(____________,____________);
v.______________();
field[i][j] = v;</programlisting>
</example>
<simpara>Now that we have a two-dimensional array storing all of the flow field vectors, we need a way for a Vehicle to look up its desired vector from the flow field.    Let’s say we have a vehicle that lives at a PVector: its location.  We first need to divide by the resolution of the grid.  For example, if the resolution is 10 and the vehicle is at (100,50), we need to look up column 10 and row 5.</simpara>
<programlisting language="java" linenumbering="unnumbered">int column = int(location.x/resolution);
int row = int(location.y/resolution);</programlisting>
<simpara>Because a vehicle could theoretically wander off the Processing window, it’s also useful for us to employ the <emphasis role="strong"><phrase role="function">constrain()</phrase></emphasis> function to make sure we don’t look outside of the flow field array.  Here is a function we’ll call <emphasis role="strong"><phrase role="function">lookup()</phrase></emphasis> that goes in the FlowField class—it receives a PVector (presumably the location of our vehicle) and returns the corresponding flow field PVector for that location.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector lookup(PVector lookup) {
    // Using constrain()
    int column = int(constrain(lookup.x/resolution,0,cols-1));
    int row = int(constrain(lookup.y/resolution,0,rows-1));
    // Note the use of get() to ensure
    // we return a copy of the PVector.
    return field[column][row].get();
  }</programlisting>
<simpara>Before we move on to the Vehicle class, let’s take a look at the FlowField class all together.</simpara>
<programlisting language="java" linenumbering="unnumbered">class FlowField {

  // A flow field is a two-dimensional array of PVectors.
  PVector[][] field;
  int cols, rows;
  int resolution;

  FlowField(int r) {
    resolution = r;
    // Determine the number of columns and rows.
    cols = width/resolution;
    rows = height/resolution;
    field = new PVector[cols][rows];
    init();
  }

  // In this example, we use Perlin noise to seed the vectors.
  void init() {
    float xoff = 0;
    for (int i = 0; i &lt; cols; i++) {
      float yoff = 0;
      for (int j = 0; j &lt; rows; j++) {
       // Polar to Cartesian coordinate transformation to get x and y components of the vector
        float theta = map(noise(xoff,yoff),0,1,0,TWO_PI);
        field[i][j] = new PVector(cos(theta),sin(theta));
        yoff += 0.1;
      }
      xoff += 0.1;
    }
  }

  // A function to return a PVector based on a location
  PVector lookup(PVector lookup) {

    int column = int(constrain(lookup.x/resolution,0,cols-1));
    int row = int(constrain(lookup.y/resolution,0,rows-1));
    return field[column][row].get();
  }
}</programlisting>
<simpara>So let’s assume we have a FlowField object “flow”.  Using the <emphasis role="strong"><phrase role="function">lookup()</phrase></emphasis> function above, our vehicle can then retrieve a desired vector from the FlowField object and use Reynolds’s rules (steering = desired minus velocity) to calculate a steering force.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex4.png" canvas="processingjs/chapter06/_6_04_Flowfield/_6_04_Flowfield.pde processingjs/chapter06/_6_04_Flowfield/Flowfield.pde processingjs/chapter06/_6_04_Flowfield/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex4.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example4"><emphasis role="strong"><phrase role="example">Example 6.4: Flow field following</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {

  void follow(FlowField flow) {
    // What is the vector at that spot in the flow field?
    PVector desired = flow.lookup(location);
    desired.mult(maxspeed);

    // Steering is desired minus velocity
    PVector steer = PVector.sub(desired, velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }</programlisting>
<example id="chapter06_exercise7">
<title>Exercise 6.7</title>
<simpara>Adapt the flow field example so that the PVectors change over time (hint: try using the third dimension of Perlin noise!)</simpara>
</example>
<example id="chapter06_exercise8">
<title>Exercise 6.8</title>
<simpara>Can you seed a flow field from a PImage?  For example, try having the PVectors point from dark to light colors (or vice versa).</simpara>
</example>
</section>
<section id="chapter06_section7">
<title>6.7  The Dot Product</title>
<simpara>In a moment, we’re going to work through the algorithm (along with accompanying mathematics) and code for another of Craig Reynolds’s steering behaviors: path following (see: <ulink url="http://www.red3d.com/cwr/steer/PathFollow.html">Path Following</ulink>).  Before we can do this, however, we have to spend some time learning about another piece of vector math that we skipped in Chapter 1—the dot product.  We haven’t needed it yet, but it’s likely going to prove quite useful for you (beyond just this path-following example), so we’ll go over it in detail now.</simpara>
<simpara>Remember all the basic vector math we covered in Chapter 1?  Add, subtract, multiply and divide?</simpara>
<informalfigure id="chapter06_figure18">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_18.png" />
  </imageobject>
  <textobject><phrase>Figure 6.18</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice how in the above diagram, vector multiplication involves multiplying a vector by a scalar value.  This makes sense; when we want a vector to be twice as large (but facing the same direction), we multiply it by 2.  When we want it to be half the size, we multiply it by 0.5.</simpara>
<simpara>However, there are two other <emphasis>multiplication-like</emphasis> operations with vectors that are useful in certain scenarios—the dot product and the cross product. For now we’re going to focus on the dot product, which is defined as follows.  Assume vectors <emphasis role="strong"><phrase role="vector">A</phrase></emphasis> and <emphasis role="strong"><phrase role="vector">B</phrase></emphasis>:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A = (ax,ay)</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">B = (bx,by)</phrase></emphasis>
<emphasis role="strong"><phrase role="notetoself">[MATH NOTATION: VECTORS]</phrase></emphasis></simpara>
<simpara>THE DOT PRODUCT: <emphasis role="strong"><phrase role="formula">A·B = ax <literal>*</literal> bx + ay <literal>*</literal> by</phrase></emphasis></simpara>
<simpara>For example, if we have the following two vectors:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A = (-3,5)</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">B = (10,1)</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="formula">A·B = -3 <literal>*</literal> 10 + 5 <literal>*</literal> 1 = -30 + 5 = -25</phrase></emphasis></simpara>
<simpara>Notice that the result of the dot product is a scalar value (a single number) and not a vector.</simpara>
<simpara><emphasis role="strong"><phrase role="notetoself">[NEED TO DEAL WITH MATH NOTATION HERE]</phrase></emphasis></simpara>
<simpara>In Processing, this would translate to:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector a = new PVector(-3,5);
PVector b = new PVector(10,1);

// The PVector class includes a
// function to calculate the dot product.
float n = a.dot(b);</programlisting>
<simpara>And if we were to look in the guts of the PVector source, we’d find a pretty simple implementation of this function:</simpara>
<programlisting language="java" linenumbering="unnumbered">public float dot(PVector v) {
  return x*v.x + y*v.y + z*v.z;
}</programlisting>
<simpara>This is simple enough, but why do we need the dot product, and when is it going to be useful for us in code?</simpara>
<simpara>One of the more common uses of the dot product is to find the angle between two vectors.   Another way in which the dot product can be expressed is:</simpara>
<simpara><emphasis role="strong"><emphasis>THE DOT PRODUCT:</emphasis></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="formula">a·b = |a||b|cos(θ)</phrase></emphasis>
<emphasis role="strong"><phrase role="notetoself">[NEED TO DEAL WITH MATH NOTATION HERE]</phrase></emphasis></simpara>
<simpara>In other words, A dot B is equal to the magnitude of A times magnitude of B times cosine of theta (with theta defined as <emphasis role="strong">the angle between the two vectors A and B.</emphasis>)</simpara>
<simpara>The two formulas for dot product can be derived from one another with <ulink url="http://mathworld.wolfram.com/DotProduct.html">trigonometry</ulink>, but for our purposes we can be happy with operating on the assumption that:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A·B = |A| <literal>*</literal> |B| * cos(theta)</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">A·B = ax <literal>*</literal> bx + ay <literal>*</literal> by</phrase></emphasis></simpara>
<simpara>both hold true and therefore:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">ax <literal>*</literal> bx + ay <literal>*</literal> by = |A| <literal>*</literal> |B| <literal>*</literal> cos(theta)</phrase></emphasis></simpara>
<informalfigure id="chapter06_figure19">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_19.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.19</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now, let’s start with the following problem. We have the vectors A and B:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A = (10,2)</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">B = (4,-3)</phrase></emphasis></simpara>
<simpara>We now have a situation where we know everything except for theta.   We know the components of the vector (ax,ay,bx,by) and we can calculate the magnitude of each vector as we did in Chapter 1 with the Pythagorean theorem.  We can therefore solve for cos(theta):</simpara>
<simpara><emphasis role="strong"><phrase role="formula">cos(theta) = A·B / |A| <literal>*</literal> |B|</phrase></emphasis></simpara>
<simpara>Once we’ve solved for cosine of theta, we can take the inverse cosine (often expressed as arccosine) to solve for theta.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">theta = arccos (A·B / |A| <literal>*</literal> |B|)</phrase></emphasis></simpara>
<simpara>Let’s now do the math with actual numbers:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">|A| = 10.2</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">|B| = 5</phrase></emphasis></simpara>
<simpara>Therefore:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">theta = arccos ( 10 <literal>*</literal> 4 + 2 <literal>*</literal> -3 / 10.2 <literal>*</literal> 5 )</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">theta = arccos ( 34 / 51 )</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">theta = ~ 48 degrees</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="notetoself">[More math notation fixes here]</phrase></emphasis></simpara>
<simpara>The Processing version of this would be:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector a = new PVector(10,2);
PVector b = new PVector(4,-3);
float theta = acos(a.dot(b) / (a.mag() * b.mag()));</programlisting>
<simpara>And, again, if we were to dig into the guts of the Processing source code, we would see a function that implements this exact algorithm.</simpara>
<programlisting language="java" linenumbering="unnumbered">  static public float angleBetween(PVector v1, PVector v2) {
    float dot = v1.dot(v2);
    float theta = (float) Math.acos(dot / (v1.mag() * v2.mag()));
    return theta;
  }</programlisting>
<example id="chapter06_exercise9">
<title>Exercise 6.9</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_exc9.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_exc9.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Create a sketch that displays the angle between two PVector objects.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/blank.png" />
  </imageobject>
  <textobject><phrase>imgs/blank.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara>A couple things to note here:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
If two vectors (<emphasis role="strong"><phrase role="vector">A</phrase></emphasis> and <emphasis role="strong"><phrase role="vector">B</phrase></emphasis>) are orthogonal (i.e. perpendicular), the dot product (<emphasis role="strong"><phrase role="formula">A·B</phrase></emphasis>) is equal to zero.
</simpara>
</listitem>
<listitem>
<simpara>
If two vectors are unit vectors, then the dot product is simply equal to cosine of the angle between, i.e.  <emphasis role="strong"><phrase role="formula">A·B = cos(theta)</phrase></emphasis> if A and B are of length 1.
</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong"><phrase role="notetoself">[MATH NOTATION NEEDED]</phrase></emphasis></simpara>
</section>
<section id="chapter06_section8">
<title>6.8  Path Following</title>
<simpara>Now that we’ve got a basic understanding of the dot product under our belt, we can return to a discussion of Craig Reynolds’s path-following algorithm.     Let’s quickly clarify something.  We are talking about path <emphasis role="strong"><emphasis>following</emphasis></emphasis>, not path <emphasis role="strong"><emphasis>finding</emphasis></emphasis>.  Pathfinding refers to a research topic (commonly studied in artificial intelligence) that involves solving for the shortest distance between two points, often in a maze.   With path following, the path already exists and we’re asking a vehicle to follow that path.</simpara>
<simpara>Before we work out the individual pieces, let’s take a look at the overall algorithm for path following, as defined by Reynolds.</simpara>
<informalfigure id="chapter06_figure20">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_20.png" />
  </imageobject>
  <textobject><phrase>Figure 6.20</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Before we deal with the vehicle, let’s define what we mean by a path.  There are many ways we could implement a path, but for us, the simplest will be to define a path as a series of connected points:</simpara>
<informalfigure id="chapter06_figure21">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_21.png" />
  </imageobject>
  <textobject><phrase>Figure 6.21: Path</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To start, let’s think of our path in an even simpler way, as a line between two points.</simpara>
<informalfigure id="chapter06_figure22">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_22.png" />
  </imageobject>
  <textobject><phrase>Figure 6.22: Simple Path</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We’re also going to consider a path to have a radius.  If we think of the path as a road, the radius determines the road’s width.  With a smaller radius, our vehicles will have to follow the path more closely; a wider radius will allow them to stray a bit more.</simpara>
<simpara>Putting this into a class, we have:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex5_a.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex5_a.png</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">class Path {

  // A Path is only two points, start and end
  PVector start;
  PVector end;

  // A path has a radius, i.e how wide it is.
  float radius;

  Path() {
    // Picking some arbitrary values to initialize path
    radius = 20;
￼    start = new PVector(0,height/3);
    end = new PVector(width,2*height/3);
  }

  void display() {      // Display the path.
    strokeWeight(radius*2);
    stroke(0,100);
    line(start.x,start.y,end.x,end.y);
    strokeWeight(1);
    stroke(0);
    line(start.x,start.y,end.x,end.y);
  }
}</programlisting>
<simpara>Now, let’s assume we have a Vehicle (as depicted below) outside of the path’s radius, moving with a velocity.</simpara>
<informalfigure id="chapter06_figure23">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_23.png" />
  </imageobject>
  <textobject><phrase>Figure 6.23</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The first thing we want to do is predict, assuming a constant velocity, where that vehicle will be in the future.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Start by making a copy of the velocity.
PVector predict = vel.get();

// Normalize it and look 25 pixels
// ahead by scaling the vector up.
predict.normalize();
predict.mult(25);

// Add vector to location to find the
/// predicted location.
PVector predictLoc = PVector.add(loc, predict);</programlisting>
<simpara>Once we have that location, it’s now our job to find out its distance from the path of that predicted location.  If it’s very far away, well, then, we’ve strayed from the path and need to steer back towards it.  If it’s close, then we’re doing OK and are following the path nicely.</simpara>
<simpara>So, how do we find the distance between a point and a line?  This concept is key.  The distance between a point and a line is defined as the length of the “normal” between that point and line.  The normal is a vector that extends from that point and is perpendicular to the line.</simpara>
<informalfigure id="chapter06_figure24">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_24.png" />
  </imageobject>
  <textobject><phrase>Figure 6.24</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s figure out what we do know.    We know we have a vector (call it <emphasis role="strong"><phrase role="vector">A</phrase></emphasis>) that extends from the path’s starting point to the vehicle’s predicted location:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector a = PVector.sub(predictLoc,path.start);</programlisting>
<simpara>We also know that we can define a vector (call it <emphasis role="strong"><phrase role="vector">B</phrase></emphasis>) that points from the start of the path to the end.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector b = PVector.sub(path.end,path.start);</programlisting>
<simpara>Now, with basic trigonometry, we know that the distance from the path’s start to the normal point is <emphasis role="strong"><phrase role="formula">|A| * cos(theta)</phrase></emphasis>.</simpara>
<informalfigure id="chapter06_figure25">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_25.png" />
  </imageobject>
  <textobject><phrase>Figure 6.25</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If we knew theta, we could easily define that normal point as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">// The distance from START to NORMAL
float d = a.mag()*cos(theta);
b.normalize();
// Scale PVector b to that distance.
b.mult(d);
// The normal point can be found by adding
// the scaled version of bto the path’s
// starting point.
PVector normalPoint = PVector.add(path.start,b);</programlisting>
<simpara>And if the dot product has taught us anything, it’s that given two vectors, we can get theta, the angle between.</simpara>
<programlisting language="java" linenumbering="unnumbered">// What is theta?  The angle between A and B
float theta = PVector.angleBetween(a,b);
b.normalize();
b.mult(a.mag()*cos(theta));
PVector normalPoint = PVector.add(path.start,b);</programlisting>
<simpara>While the above code will work, there’s one more simplification we can make.   If you’ll notice, the desired magnitude for vector <emphasis role="strong"><phrase role="vector">B</phrase></emphasis> is:</simpara>
<programlisting language="java" linenumbering="unnumbered">a.mag()*cos(theta)</programlisting>
<simpara>or</simpara>
<simpara><emphasis role="strong"><phrase role="formula">|A|*cos(theta)</phrase></emphasis></simpara>
<simpara>And if you recall:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A·B = |A| <literal>*</literal> |B| <literal>*</literal> cos(theta)</phrase></emphasis></simpara>
<simpara>Now, what if vector <emphasis role="strong"><phrase role="vector">B</phrase></emphasis> is a unit vector, i.e. length 1?  Then:</simpara>
<simpara><emphasis role="strong"><phrase role="function">A·B = |A| <literal>*</literal> 1 <literal>*</literal> cos(theta)</phrase></emphasis></simpara>
<simpara>or</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A·B = |A| <literal>*</literal> cos(theta)</phrase></emphasis></simpara>
<simpara>And what are we doing in our code?  Normalizing b!</simpara>
<programlisting language="java" linenumbering="unnumbered">b.normalize();</programlisting>
<simpara>Because of this fact, we can simplify our code as:</simpara>
<programlisting language="java" linenumbering="unnumbered">[line-through]*float theta = PVector.angleBetween(a,b);*

b.normalize();
// We can use the dot product to scale B’s length.
b.mult(a.dot(b));

PVector normalPoint = PVector.add(path.start,b);</programlisting>
<informalfigure id="chapter06_figure26">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_26.png" classname="half-width" />
  </imageobject>
  <textobject><phrase>Figure 6.26</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This process is commonly known as “scalar projection.”  <emphasis role="strong"><emphasis>|A| cos(θ) is the scalar projection of A onto B.</emphasis></emphasis>  And if we normalize B before computing the dot product, the scalar projection of A onto B is equal to A • B.</simpara>
<simpara>Once we have the normal point along the path, we have to decide whether the vehicle should steer towards the path and how.  Reynolds’s algorithm states that the vehicle should only steer towards the path if it strays beyond the path (i.e., if the distance between the normal point and the predicted future location is greater than the path radius).</simpara>
<informalfigure id="chapter06_figure27">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_27.png" />
  </imageobject>
  <textobject><phrase>Figure 6.27</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">float distance = PVector.dist(predictLoc, normalPoint);

// If the vehicle is outside the path,
// seek the target.
if (distance &gt; path.radius) {
  // We don’t have to work out the desired velocity and
  // steering force; all that is taken care of by seek(),
  // which we already wrote in &lt;&lt;chapter06_example1, Example 6.1&gt;&gt;.
  seek(target);
}</programlisting>
<simpara>But what is the target?</simpara>
<simpara>Reynolds’s algorithm involves picking a point ahead of the normal on the path (see step #3 above).  But for simplicity, we could just say that the target is the normal itself. This will work fairly well:</simpara>
<programlisting language="java" linenumbering="unnumbered">float distance = PVector.dist(predictLoc, normalPoint);
if (distance &gt; path.radius) {
  // Seek the normal point on the path
  seek(normalPoint);
}</programlisting>
<simpara>Since we know the vector that defines the path (we’re calling it “b”), we can implement Reynolds’s “point ahead on the path” without too much trouble.</simpara>
<informalfigure id="chapter06_figure28">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_28.png" />
  </imageobject>
  <textobject><phrase>Figure 6.28</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">float distance = PVector.dist(predictLoc, normalPoint);
if (distance &gt; path.radius) {
  // Normalize and scale b (pick 25 pixels arbitrarily).
  b.normalize();
  b.mult(25);
  // By adding b to normalPoint, we now move
  // 25 pixels ahead on the path.
  PVector target = PVector.add(normalPoint,b);

  seek(target);
}</programlisting>
<simpara>Putting it all together, we have the following steering function in our Vehicle class.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex5.png" canvas="processingjs/chapter06/_6_05_PathFollowingSimple/_6_05_PathFollowingSimple.pde processingjs/chapter06/_6_05_PathFollowingSimple/Path.pde processingjs/chapter06/_6_05_PathFollowingSimple/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex5.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example5"><emphasis role="strong"><phrase role="example">Example 6.5: Simple path following</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void follow(Path p) {

        // Step 1: Predict vehicle’s future location.
    PVector predict = vel.get();
    predict.normalize();
    predict.mult(25);
    PVector predictLoc = PVector.add(loc, predict);

    // Step 2: Find normal point along path.
    PVector a = p.start;
    PVector b = p.end;
    PVector normalPoint = getNormalPoint(predictLoc, a, b);

    // Step 3: Move a little further along path and set a target.
    PVector dir = PVector.sub(b, a);
    dir.normalize();
    dir.mult(10);
    PVector target = PVector.add(normalPoint, dir);

    float distance = PVector.dist(normalPoint, predictLoc);
    // Step 4: If we are off the path,
    // seek that target in order to stay on the path.
    if (distance &gt; p.radius) {
      seek(target);
    }
  }</programlisting>
<simpara>Now, you may notice above that instead of using all that dot product/scalar projection code to find the normal point, we instead call a function: <emphasis role="strong"><phrase role="function">getNormalPoint()</phrase></emphasis>.   In cases like this, it’s useful to break out the code that performs a specific task (finding a normal point) into a function that it can be used generically in any case where it is required.  The function takes three PVectors: the first defines a point in Cartesian space and the second and third arguments define a line segment.</simpara>
<informalfigure id="chapter06_figure29">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_29.png" />
  </imageobject>
  <textobject><phrase>Figure 6.29</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">  PVector getNormalPoint(PVector p, PVector a, PVector b) {
    // PVector that points from a to p
    PVector ap = PVector.sub(p, a);
    // PVector that points from a to b
    PVector ab = PVector.sub(b, a);

    // Using the dot product for scalar projection
    ab.normalize();
    ab.mult(ap.dot(ab));
    // Finding the normal point along the line segment
    PVector normalPoint = PVector.add(a, ab);

    return normalPoint;
  }</programlisting>
<simpara>What do we have so far?  We have a Path class that defines a path as a line between two points.  We have a Vehicle class that defines a vehicle that can follow the path (using a steering behavior to seek a target along the path).  What is missing?</simpara>
<simpara>Take a deep breath.  We’re almost there.</simpara>
</section>
<section id="chapter06_section9">
<title>6.9 Path Following with Multiple Segments</title>
<informalfigure id="chapter06_figure30">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_30.png" classname="A Curvy Path" />
  </imageobject>
  <textobject><phrase>Figure 6.30</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We’ve built a great example so far, yes, but it’s pretty darn limiting.  After all, what if we want our path to be something that looks more like:</simpara>
<informalfigure id="chapter06_figure31">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_31.png" classname="Path defined as line segments" />
  </imageobject>
  <textobject><phrase>Figure 6.31</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>While it’s true that we could make this example work for a curved path, we’re much less likely to end up needing a cool compress on our forehead if we stick with line segments.  In the end, we  can always employ the same technique we discovered with Box2D—we can draw whatever fancy curved path we want and approximate it behind the scenes with simple geometric forms.</simpara>
<simpara>So, what’s the problem?  If we made path following work with one line segment, how do we make it work with a series of connected line segments?   Let’s take a look again at our vehicle driving along the screen.    Say we arrive at Step 3.</simpara>
<simpara><emphasis role="strong"><emphasis>Step 3: Find a target point on the path.</emphasis></emphasis></simpara>
<simpara>To find the target, we need to find the normal to the line segment.  But now that we have a series of line segments, we have a series of normal points (see above)!  Which one do we choose?  The solution we’ll employ is to pick the normal point that is (a) closest and (b) on the path itself.</simpara>
<informalfigure id="chapter06_figure32">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_32.png" />
  </imageobject>
  <textobject><phrase>Figure 6.32</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
If we have a point and an infinitely long line, we’ll always have a normal.  But, as in the path-following example, if we have a point and a line segment, we won’t necessarily find a normal that is on the line segment itself.  So if this happens for any of the segments, we can disqualify those normals.  Once we are left with normals that are on the path itself (only two in the above diagram), we simply pick the one that is closest to our vehicle’s location.</simpara>
<simpara>In order to write the code for this, we’ll have to expand our Path class to have an ArrayList of points (rather than just two, a start and an end.)</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex6_a.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex6_a.png</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered"> class Path {

  // A Path is now an ArrayList of points (PVector objects).
  ArrayList&lt;PVector&gt; points;
  float radius;

  Path() {
    radius = 20;
    points = new ArrayList&lt;PVector&gt;();
  }

  // This function allows us to add points to the path.
  void addPoint(float x, float y) {             .
    PVector point = new PVector(x,y);
    points.add(point);
  }

  // Display the path as a series of points.
  void display() {
    stroke(0);
    noFill();
    beginShape();
    for (PVector v : points) {
      vertex(v.x,v.y);
    }
    endShape();
  }
}</programlisting>
<simpara>Now that we have the Path defined, it’s the vehicle’s turn to deal with multiple line segments.  All we did before was find the normal for one line segment.  We can now find the normals for all the line segments in a loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = 0; i &lt; p.points.size()-1; i++) {
  PVector a = p.points.get(i);
  PVector b = p.points.get(i+1);
  // Finding the normals on each line segment
  PVector normalPoint = getNormalPoint(predictLoc, a, b);</programlisting>
<simpara>Then we should make sure the normalPoint is actually between points a and b.  Since we know our path goes from left to right in this example, we can test if the x location of normalPoint is outside the x locations of a and b.</simpara>
<programlisting language="java" linenumbering="unnumbered">   if (normalPoint.x &lt; a.x || normalPoint.x &gt; b.x) {
      // Use the end point of the segment
      // as our normal point if we can’t find one.
      normalPoint = b.get();
   }</programlisting>
<simpara>As a little trick, we’ll say that if it’s not within the line segment, let’s just pretend the end point of that line segment is the normal.  This will ensure that our vehicle always stays on the path, even if it strays out of the bounds of our line segments.</simpara>
<simpara>Finally, we’ll need to make sure we find the normal point that is closest to our vehicle.  To accomplish this, we start with a very high “world record” distance and iterate through each normal point to see if it beats the record (i.e. is less than).  Each time a normal point beats the record, the world record is updated and the winning point is stored in a variable named target.  At the end of the loop, we’ll have the closest normal point in that variable.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex6.png" canvas="processingjs/chapter06/_6_06_PathFollowing/_6_06_PathFollowing.pde processingjs/chapter06/_6_06_PathFollowing/Path.pde processingjs/chapter06/_6_06_PathFollowing/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex6.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example6"><emphasis role="strong"><phrase role="example">Example 6.6: Path following</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">PVector target = null;
// Start with a very high record
// that can easily be beaten.
float worldRecord = 1000000;

for (int i = 0; i &lt; p.points.size()-1; i++) {
  PVector a = p.points.get(i);
  PVector b = p.points.get(i+1);
  PVector normalPoint = getNormalPoint(predictLoc, a, b);
  if (normalPoint.x &lt; a.x || normalPoint.x &gt; b.x) {
    normalPoint = b.get();
  }

  float distance = PVector.dist(predictLoc, normalPoint);

  // If we beat the record then
  // this should be our target!
  if (distance &lt; worldRecord) {
    worldRecord = distance;
    target = normalPoint.get();
  }
}</programlisting>
<example id="chapter06_exercise10">
<title>Exercise 6.10</title>
<simpara>Update the path-following example so that the path can go in any direction.  (Hint: you’ll need to use the min() and max() function when determining if the normal point is inside the line segment.)</simpara>
<programlisting language="java" linenumbering="unnumbered">if (normalPoint.x &lt; ____(____,____) || normalPoint.x &gt; ____(____,____)) {
  normalPoint = b.get();
}</programlisting>
</example>
<example id="chapter06_exercise11">
<title>Exercise 6.11</title>
<simpara>Create a path that changes over time.  Can the points that define the path itself have their own steering behaviors?</simpara>
</example>
</section>
<section id="chapter06_section10">
<title>6.10  Complex Systems</title>
<simpara>Remember our purpose?  To breathe life into the things that move around our Processing windows?  By learning to write the code for an autonomous agent and building a series of examples of individual behaviors, hopefully our souls feel a little more full.  But this is no place to stop and rest on our laurels.  We’re just getting started.   After all, there is a deeper purpose at work here.  Yes, a vehicle is a simulated being making decisions about how to seek and flow and follow.  But what is a life led alone, without the love and support of others?  Our purpose here is not only to build individual behaviors for our vehicles, but to put our vehicles into systems of many vehicles and allow those vehicles to interact with each other.</simpara>
<simpara>Let’s think about a tiny, crawling ant—one single ant.  An ant is an autonomous agent; it can perceive its environment (using antennae to gather information about the direction and strength of chemical signals) and make decisions about how to move based on those signals.  But can a single ant acting alone build a nest, gather food, defend its queen?   An ant is a simple unit and can only perceive its immediate environment.  A colony of ants, however, is a sophisticated complex system, a “superorganism” in which the components work together to accomplish difficult and complicated goals.</simpara>
<simpara>We want to take what we’ve learned during the process of building autonomous agents in Processing into simulations that involve many agents operating in parallel—agents that have an ability not only to perceive their physical environment but also the actions of their fellow agents, and then act accordingly.  We want to create complex systems in Processing.</simpara>
<simpara>What is a complex system?  A complex system is typically defined as a system that is “more than the sum of its parts.”  While the individual elements of the system may be incredibly simple and easily understood, the behavior of the system as a whole can be highly complex, intelligent, and difficult to predict.  Here are three key principles of complex systems.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Simple units with short-range relationships.</emphasis></emphasis>  This is what we’ve been building all along: vehicles that have a limited perception of their environment.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Simple units operate in parallel.</emphasis></emphasis>   This is what we need to simulate in code.  For every cycle through Processing’s <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop, each unit will decide how to move (to create the appearance of them all working in parallel.)
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>System as a whole exhibits emergent phenomena.</emphasis></emphasis>   Out of the interactions between these simple units emerges complex behavior, patterns, and intelligence.  Here we’re talking about the result we are hoping for in our sketches.  Yes, we know this happens in nature (ant colonies, termites, migration patterns, earthquakes, snowflakes, etc.), but can we achieve the same result in our Processing sketches?
</simpara>
</listitem>
</itemizedlist>
<simpara>Following are two additional features of complex systems that will help frame the discussion, as well as provide guidelines for features we will want to include in our software simulations.  It&#8217;s important to acknowledge that this is a fuzzy set of characteristics and not all complex systems have all of them.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Non-linearity.</emphasis></emphasis>  This aspect of complex systems is often casually referred to as “The Butterfly Effect,” coined by mathematician and meteorologist Edward Norton Lorenz, a pioneer in the study of chaos theory.  In 1961, Lorenz was running a computer weather simulation for the second time and, perhaps to save a little time, typed in a starting value of 0.506 instead of 0.506127.   The end result was completely different from the first result of the simulation.   In other words, the theory is that a single butterfly flapping its wings on the other side of the world could cause a massive weather shift and ruin our weekend at the beach.  We call it “non-linear” because there isn’t a linear relationship between a change in initial conditions and a change in outcome.   A small change in initial conditions can have a massive effect on the outcome.  Non-linear systems are a superset of chaotic systems.  In the next chapter, we’ll see how even in a system of many zeros and ones, if we change just one bit, the result will be completely different.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Competition and cooperation.</emphasis></emphasis>  One of the things that often makes a complex system tick is the presence of both competition and cooperation between the elements.   In our upcoming flocking system, we will have three rules—alignment, cohesion, and separation.  Alignment and cohesion will ask the elements to “cooperate”—i.e. work together to stay together and move together.  Separation, however, will ask the elements to “compete” for space.  As we get to the flocking system, try taking out the cooperation or the competition and you’ll see how you are left without complexity. Competition and cooperation are found in living complex systems, but not in non-living complex systems like the weather.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Feedback</emphasis></emphasis> Complex systems often include a feedback loop where the the output of the system is fed back into the system as an input to influence its behavior in a positive or negative direction.   Let&#8217;s say you drive to work each day because the price of gas is low.  In fact, everyone drives to work.  The price of gas goes up as demand begins to exceed supply.  You, and everyone else, decide to take the train to work because it&#8217;s too expensive.  And the price of gas declines as the demand declines.  The price of gas is both the input of the system (determining whether you choose to drive or ride the train) and the output (the demand that results from your choice.)  I should note that economic models (like supply/demand, the stock market) are one example of a human complex system.  Others include fads and trends, elections, crowds, and traffic flow.
</simpara>
</listitem>
</itemizedlist>
<simpara>Complexity will serve as a theme for the remaining content in this book. In this chapter, we’ll begin by adding one more feature to our Vehicle class: an ability to look at neighboring vehicles.</simpara>
</section>
<section id="chapter06_section11">
<title>6.11  Group Behaviors (or: Let’s not run into each other)</title>
<simpara>A group is certainly not a new concept. We’ve done this before—in Chapter 4, where we developed a framework for managing collections of particles in a ParticleSystem class.   There, we stored a list of particles in an ArrayList.  We’ll do the same thing here: store a bunch of Vehicle objects in an ArrayList.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Declare an ArrayList of Vehicle objects.
ArrayList&lt;Vehicle&gt; vehicles;

void setup() {
  // Initialize and fill the ArrayList
  // with a bunch of Vehicles.
  vehicles = new ArrayList&lt;Vehicle&gt;;
  for (int i = 0; i &lt; 100; i++) {
    vehicles.add(new Vehicle(random(width),random(height)));
  }
}</programlisting>
<simpara>Now when it comes time to deal with all the vehicles in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, we simply loop through all of them and call the necessary functions.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw(){
  for (Vehicle v : vehicles) {
    v.update();
    v.display();
  }
}</programlisting>
<simpara>OK, so maybe we want to add a behavior, a force to be applied to all the vehicles.  This could be seeking the mouse.</simpara>
<programlisting language="java" linenumbering="unnumbered">    v.seek(mouseX,mouseY);</programlisting>
<simpara>But that’s an individual behavior.  We’ve already spent thirty-odd pages worrying about individual behaviors.  We’re here because we want to apply a group behavior.  Let’s begin with separation, a behavior that commands, “Avoid colliding with your neighbors!”</simpara>
<programlisting language="java" linenumbering="unnumbered">    v.separate();</programlisting>
<simpara>Is that right?  It sounds good, but it’s not.  What’s missing?  In the case of seek, we said “Seek <emphasis role="strong"><phrase role="var">mouseX</phrase></emphasis> and <emphasis role="strong"><phrase role="var">mouseY</phrase></emphasis>.”  In the case of separate, we’re saying “separate from *<emphasis>everyone else.</emphasis>*”  Who is everyone else?  It’s the list of all the other vehicles.</simpara>
<programlisting language="java" linenumbering="unnumbered">    v.separate(vehicles);</programlisting>
<simpara>This is the big leap beyond what we did before with particle systems.  Instead of having each element (particle or vehicle) operate on its own, we’re now saying, “Hey you, the vehicle! When it comes time for you to operate, you need to operate with an awareness of everyone else. So I’m going to go ahead and pass you the ArrayList of everyone else.”</simpara>
<simpara>This is how we’ve mapped out <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> to deal with a group behavior.</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;Vehicle&gt; vehicles;

void setup() {
  size(320,240);
  vehicles = new ArrayList&lt;Vehicle&gt;();
  for (int i = 0; i &lt; 100; i++) {
    vehicles.add(new Vehicle(random(width),random(height)));
  }
}

void draw() {
  background(255);

  for (Vehicle v : vehicles) {
    // This is really the only new thing we’re doing in this section.  We’re asking
    // a Vehicle object to examine all the other vehicles in the process of calculating a
    // separation force.
    v.separate(vehicles); // [bold]
    v.update();
    v.display();
  }
}</programlisting>
<informalfigure id="chapter06_figure33">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_33.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.33</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Of course, this is just the beginning.  The real work happens inside the <emphasis role="strong"><phrase role="function">separate()</phrase></emphasis> function itself.  Let’s figure out how we want to define separation. Reynolds states: “Steer to avoid crowding.” In other words, if a given vehicle is too close to you, steer away from that vehicle.  Sound familiar?  Remember the seek behavior where a vehicle steers towards a target?  Reverse that force and we have the flee behavior.</simpara>
<informalfigure id="chapter06_figure34">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_34.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.34</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>But what if more than one vehicle is too close?  In this case, we’ll define separation as the average of all the vectors pointing away from any close vehicles.</simpara>
<simpara>Let’s begin to write the code.  As we just worked out, we’re writing a function called <emphasis role="strong"><phrase role="function">separate()</phrase></emphasis> that receives an ArrayList of Vehicle objects as an argument.</simpara>
<programlisting language="java" linenumbering="unnumbered">void separate (ArrayList&lt;Vehicle&gt; vehicles) {

}</programlisting>
<simpara>Inside this function, we’re going to loop through all of the vehicles and see if any are too close.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // This variable specifies how close is too close.
  float desiredseparation = 20;

  for (Vehicle other : vehicles) {

    // What is the distance between me and another Vehicle?
    float d = PVector.dist(location, other.location);

    if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
      // Any code here will be executed if the Vehicle is within 20 pixels.

    }
  }</programlisting>
<simpara>Notice how in the above code, we are not only checking if the distance is less than a desired separation (i.e. too close!), but also if the distance is greater than zero.  This is a little trick that makes sure we don’t ask a vehicle to separate from itself.   Remember, all the vehicles are in the ArrayList, so if you aren’t careful you’ll be comparing each vehicle to itself!</simpara>
<simpara>Once we know that two vehicles are too close, we need to make a vector that points away from the offending vehicle.</simpara>
<programlisting language="java" linenumbering="unnumbered">    if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
      // A PVector pointing away from the other’s location.
      PVector diff = PVector.sub(location, other.location);
      diff.normalize();
    }</programlisting>
<simpara>This is not enough.  We have that vector now, but we need to make sure we calculate the average of all vectors pointing away from close vehicles.   How do we compute average?  We add up all the vectors and divide by the total.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Start with an empty PVector.
  PVector sum = new PVector();  // [bold]
  int count = 0;  // [bold]
  // We have to keep track of how many Vehicles are too close.
  for (Vehicle other : vehicles) {
    float d = PVector.dist(location, other.location);
    if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
      PVector diff = PVector.sub(location, other.location); // [bold]
      diff.normalize();
      // Add all the vectors together and increment the count.
      sum.add(diff); // [bold]
      count++;
    }
  }

  // We have to make sure we found at least one close
  // vehicle.  We don’t want to bother doing anything
  // if nothing is too close (not to mention we can’t
  // divide by zero!)
  if (count &gt; 0) { // [bold]
    sum.div(count); // [bold]
  } // [bold]</programlisting>
<simpara>Once we have the average vector (stored in the PVector object “sum”), that PVector can be scaled to maximum speed and become our desired velocity—we <emphasis role="strong"><emphasis>desire</emphasis></emphasis> to move in that direction at maximum speed!   And once we have the desired velocity, it’s the same old Reynolds story: steering equals desired minus velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">  if (count &gt; 0) {
    sum.div(count);

    // Scale average to maxspeed
    // (this becomes desired).
    sum.normalize();
    sum.mult(maxspeed);

    // Reynolds’s steering formula
    PVector steer = PVector.sub(sum,vel);
    steer.limit(maxforce);

    // Apply the force to the Vehicle’s
    // acceleration.
    applyForce(steer);
  }</programlisting>
<simpara>Let’s see the function in its entirety.  There are two additional improvements, noted in the code comments.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex7.png" canvas="processingjs/chapter06/_6_07_Separation/_6_07_Separation.pde processingjs/chapter06/_6_07_Separation/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex7.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example7"><emphasis role="strong"><phrase role="example">Example 6.7: Group behavior: Separation</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void separate (ArrayList&lt;Vehicle&gt; vehicles) {
    // Note how the desired separation is based
    // on the Vehicle’s size.
    float desiredseparation = r*2; // [bold]
    PVector sum = new PVector();
    int count = 0;
    for (Vehicle other : vehicles) {
      float d = PVector.dist(location, other.location);
      if ((d &gt; 0) &amp;&amp; (d &lt; desiredseparation)) {
        PVector diff = PVector.sub(location, other.location);
        diff.normalize();
        // What is the magnitude of the PVector
        // pointing away from the other vehicle?
        // The closer it is, the more we should flee.
        // The farther, the less. So we divide
        // by the distance to weight it appropriately.
        diff.div(d);
        sum.add(diff);
        count++;

￼      }
    }
    if (count &gt; 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(maxspeed);
      PVector steer = PVector.sub(sum, vel);
      steer.limit(maxforce);
      applyForce(steer);
    }

  }</programlisting>
<example id="chapter06_exercise12">
<title>Exercise 6.12</title>
<simpara>Rewrite <emphasis role="strong"><phrase role="function">separate()</phrase></emphasis> to work in the opposite fashion (“cohesion”).  If a vehicle is beyond a certain distance, steer towards that vehicle.  This will keep the group together.  (Note that in a moment, we’re going to look at what happens when we have both cohesion and separation in the same simulation.)</simpara>
</example>
<example id="chapter06_exercise13">
<title>Exercise 6.13</title>
<simpara>Add the separation force to path following to create a simulation of Reynolds’s “Crowd Path Following.”</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_exc13.png" canvas="processingjs/chapter06/Ex_6_13_CrowdPathFollowing/Ex_6_13_CrowdPathFollowing.pde processingjs/chapter06/Ex_6_13_CrowdPathFollowing/Path.pde processingjs/chapter06/Ex_6_13_CrowdPathFollowing/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_exc13.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter06_section12">
<title>6.12  Combinations</title>
<simpara>The previous two exercises (<link linkend="chapter06_exercise12">6.12</link>, chapter06_exercise13, 6.13&gt;&gt;) hint at what is perhaps the most important aspect of this chapter.  After all, what is a Processing sketch with one steering force compared to one with many?  How could we even begin to simulate emergence in our sketches with only one rule?   The most exciting and intriguing behaviors will come from mixing and matching multiple steering forces, and we’ll need a mechanism for doing so.</simpara>
<simpara>You may be thinking, “Duh, this is nothing new.  We do this all the time.”  You would be right.  In fact, we did this as early as Chapter 2.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector wind = new PVector(0.001,0);
  PVector gravity = new PVector(0,0.1);
  mover.applyForce(wind);
  mover.applyForce(gravity);</programlisting>
<simpara>Here we have a Mover object that responds to two forces.  This all works nicely because of the way we designed the Mover object to accumulate the force vectors into its acceleration vector.  In this chapter, however, our forces stem from internal desires of the Mover objects (now called “Vehicles” themselves).   And those desires can be weighted.    Let’s consider a sketch where all vehicles have two desires:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Seek the mouse location.</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Separate from any vehicles that are too close.</emphasis></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>We might begin by adding a function to the Vehicle class that manages all of the behaviors.  Let’s call it <emphasis role="strong"><phrase role="function">applyBehaviors()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">void applyBehaviors(ArrayList&lt;Vehicle&gt; vehicles) {
  separate(vehicles);
  seek(new PVector(mouseX,mouseY));
}</programlisting>
<simpara>Here we see how a single function takes care of calling the other functions that apply the forces—<emphasis role="strong"><phrase role="function">separate()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">seek()</phrase></emphasis>.    We could start mucking around with those functions and see if we can adjust the strength of the forces they are calculating.  But it would be easier for us to ask those functions to return the forces so that we can adjust their strength before applying them to the Vehicle’s acceleration.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void applyBehaviors(ArrayList&lt;Vehicle&gt; vehicles) {
    PVector separate = separate(vehicles);
    PVector seek = seek(new PVector(mouseX,mouseY));
    // We have to apply the force here since seek() and separate() no longer do so.
    applyForce(separate);
    applyForce(seek);
  }</programlisting>
<simpara>Let’s look at how the seek function changed.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Seek now returns a PVector.
  PVector seek(PVector target) {
    PVector desired = PVector.sub(target,loc);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,vel);
    steer.limit(maxforce);

    // Instead of applying the force we return the PVector.
    applyForce(steer); // [line-through]
    return steer;
  }</programlisting>
<simpara>This is a subtle change, but incredibly important for us: it allows us to alter the strength of these forces in one place.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex8.png" canvas="processingjs/chapter06/_6_08_SeparationAndSeek/_6_08_SeparationAndSeek.pde processingjs/chapter06/_6_08_SeparationAndSeek/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex8.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example8"><emphasis role="strong"><phrase role="example">Example 6.8: Combining steering behaviors: Seek and separate</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void applyBehaviors(ArrayList&lt;Vehicle&gt; vehicles) {
  PVector separate = separate(vehicles);
  PVector seek = seek(new PVector(mouseX,mouseY));

  // These values can be whatever you want them to be!
  // They can be variables that are customized for
  // each vehicle, or they can change over time.
  separate.mult(1.5); // [bold]
  seek.mult(0.5); // [bold]

  applyForce(separate);
  applyForce(seek);
}</programlisting>
<example id="chapter06_exercise14">
<title>Exercise 6.14</title>
<simpara>Redo example 6.8 so that the behavior weights are not constants.  What happens if they change over time (according to a sine wave or Perlin noise)?  Or if some vehicles are more concerned with seeking and others more concerned with separating?  Can you introduce other steering behaviors as well?</simpara>
</example>
</section>
<section id="chapter06_section13">
<title>6.13  Flocking</title>
<simpara>Flocking is an group animal behavior that is characteristic of many living creatures, such as birds, fish, and insects.   In 1986, Craig Reynolds created a computer simulation of flocking behavior and documented the algorithm in his paper, “Flocks, Herds, and Schools: A Distributed Behavioral Model.”    Recreating this simulation in Processing will bring together all the concepts in this chapter.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis>We will use the steering force formula (steer = desired - velocity) to implement the rules of flocking.</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>These steering forces will be group behaviors and require each vehicle to look at all the other vehicles.</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>We will combine and weight multiple forces.</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>The result will be a complex system—intelligent group behavior will emerge from the simple rules of flocking without the presence of a centralized system or leader.</emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>The good news is, we’ve already done items 1 through 3 in this chapter, so this section will be about just putting it all together and seeing the result.</simpara>
<simpara>Before we begin, I should mention that we’re going to change the name of our Vehicle class (yet again).  Reynolds uses the term “boid” (a made-up word that refers to a bird-like object) to describe the elements of a flocking system and we will do the same.</simpara>
<simpara>Let’s take an overview of the three rules of flocking.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Separation</emphasis></emphasis> (also known as “avoidance”): Steer to avoid colliding with your neighbors.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Alignment</emphasis></emphasis> (also known as “copy”): Steer in the same direction as your neighbors.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Cohesion</emphasis></emphasis> (also known as “center”): Steer towards the center of your neighbors (stay with the group).
</simpara>
</listitem>
</orderedlist>
<informalfigure id="chapter06_figure35">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_35.png" />
  </imageobject>
  <textobject><phrase>Figure 6.35</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Just as we did with our separate and seek example, we’ll want our Boid objects to have a single function that manages all the above behaviors.  We’ll call this function <emphasis role="strong"><phrase role="function">flock()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void flock(ArrayList&lt;Boid&gt; boids) {
    // The three flocking rules
    PVector sep = separate(boids);
    PVector ali = align(boids);
    PVector coh = cohesion(boids);

    // Arbitrary weights for these forces
    // (Try different ones!)
    sep.mult(1.5);
    ali.mult(1.0);
    coh.mult(1.0);

    // Applying all the forces
    applyForce(sep);
    applyForce(ali);
    applyForce(coh);
  }</programlisting>
<simpara>Now, it’s just a matter of implementing the three rules.   We did separation before; it’s identical to our previous example.  Let’s take a look at alignment, or steering in the same direction as your neighbors.  As with all of our steering behaviors, we’ve got to boil down this concept into a desire: the boid’s desired velocity is the average velocity of its neighbors.</simpara>
<simpara>So our algorithm is to calculate the average velocity of all the other boids and set that to desired.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector align (ArrayList&lt;Boid&gt; boids) {
    // Add up all the velocities
    // and divide by the total
    // to calculate the average velocity.
    PVector sum = new PVector(0,0);
    for (Boid other : boids) {
      sum.add(other.velocity);
    }
    sum.div(boids.size());

    // We desire to go in that
    // direction at maximum speed.
    sum.normalize();
    sum.mult(maxspeed);

    // Reynolds’s steering
    // force formula
    PVector steer = PVector.sub(sum,velocity);
    steer.limit(maxforce);
    return steer;
  }</programlisting>
<simpara>The above is pretty good, but it’s missing one rather crucial detail.  One of the key principles behind complex systems like flocking is that the elements (in this case, boids) have short-range relationships.   Thinking about ants again, it’s pretty easy to imagine an ant being able to sense its immediate environment, but less so an ant having an awareness of what another ant is doing hundreds of feet away.  The fact that the ants can perform such complex collective behavior from only these neighboring relationships is what makes them so exciting in the first place.</simpara>
<simpara>In our alignment function, we’re taking the average velocity of all the boids, whereas we should really only be looking at the boids within a certain distance.  That distance threshold is up to you, of course.  You could design boids that can see only twenty pixels away or boids that can see a hundred pixels away.</simpara>
<informalfigure id="chapter06_figure36">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_36.png" />
  </imageobject>
  <textobject><phrase>Figure 6.36</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Much like we did with separation (only calculating a force for others within a certain distance), we’ll want to do the same with alignment (and cohesion).</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector align (ArrayList&lt;Boid&gt; boids) {
    // This is an arbitrary value and could
    // vary from boid to boid.
    float neighbordist = 50;
    PVector sum = new PVector(0,0);
    int count = 0;
    for (Boid other : boids) {
      float d = PVector.dist(location,other.location);
      if ((d &gt; 0) &amp;&amp; (d &lt; neighbordist)) {
        sum.add(other.velocity);
        // For an average, we need to keep track of
        // how many boids are within the distance.
        count++;
      }
    }
    if (count &gt; 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(maxspeed);
      PVector steer = PVector.sub(sum,velocity);
      steer.limit(maxforce);
      return steer;
    // If we don’t find any close boids,
    // the steering force is zero.
    } else {
      return new PVector(0,0);
    }
  }</programlisting>
<informalfigure id="chapter06_figure37">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_37.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.37</phrase></textobject>
</mediaobject>
</informalfigure>
<example id="chapter06_exercise15">
<title>Exercise 6.15</title>
<informalfigure id="chapter06_figure37">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_37.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.37</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Can you write the above code so that boids can only see other boids that are actually within their “peripheral” vision (as if they had eyes)?  This is depicted in Figure 6.37.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/blank.png" />
  </imageobject>
  <textobject><phrase>imgs/blank.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara>Finally, we are ready for cohesion.  Here our code is virtually identical to alignment—only instead of calculating the average velocity of the boid’s neighbors, we want to calculate the average location of the boid’s neighbors (and use that as a target to seek).</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector cohesion (ArrayList&lt;Boid&gt; boids) {
    float neighbordist = 50;
    PVector sum = new PVector(0,0);
    int count = 0;
    for (Boid other : boids) {
      float d = PVector.dist(location,other.location);
      if ((d &gt; 0) &amp;&amp; (d &lt; neighbordist)) {
        // Adding up all the others’ locations
        sum.add(other.location);
        count++;
      }
    }
    if (count &gt; 0) {
      sum.div(count);
      // Here we make use of the seek() function we
      // wrote in Example [notetoself]*6.x*.  The target
      // we seek is the average location of
      // our neighbors.
      return seek(sum); // [bold]
    } else {
      return new PVector(0,0);
    }
  }</programlisting>
<simpara>It’s also worth taking the time to write a class called Flock, which will be virtually identical to the ParticleSystem class we wrote in Chapter 4 with only one tiny change:  When we call <emphasis role="strong"><phrase role="function">run()</phrase></emphasis> on each Boid object (as we did to each Particle object), we’ll pass in a reference to the entire ArrayList of boids.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Flock {
  ArrayList&lt;Boid&gt; boids;

  Flock() {
    boids = new ArrayList&lt;Boid&gt;();
  }

  void run() {
    for (Boid b : boids) {
      // Each Boid object must know about
      // all the other Boids.
      b.run(boids); // [bold]
    }
  }

  void addBoid(Boid b) {
    boids.add(b);
  }
}</programlisting>
<simpara>And our main program will look like:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_ex9.png" canvas="processingjs/chapter06/_6_09_Flocking/_6_09_Flocking.pde processingjs/chapter06/_6_09_Flocking/Flock.pde processingjs/chapter06/_6_09_Flocking/Boid.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter06/ch06_ex9.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter06_example9"><emphasis role="strong"><phrase role="example">Example 6.9: Flocking</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// A Flock object manages the
// entire group.
Flock flock;
void setup() {
  size(300,200);
  flock = new Flock();
  for (int i = 0; i &lt; 100; i++) {
    Boid b = new Boid(width/2,height/2);
    // The Flock starts out with 100 Boids
    flock.addBoid(b);
  }
}

void draw() {
  background(255);
  flock.run();
}</programlisting>
<example id="chapter06_exercise16">
<title>Exercise 6.16</title>
<literallayout class="monospaced">Combine flocking with some other steering behaviors.</literallayout>
</example>
<example id="chapter06_exercise17">
<title>Exercise 6.17</title>
<informalfigure id="chapter06_figure38">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_38.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 6.38</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In The Computational Beauty of Nature (Gary Flake, MIT Press, 2000), Gary Flake describes a fourth rule for flocking: “View: move laterally away from any boid that blocks the view.”  Implement this rule as depicted in Figure 6.38.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/blank.png" />
  </imageobject>
  <textobject><phrase>imgs/blank.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example id="chapter06_exercise18">
<title>Exercise 6.18</title>
<simpara>Create a flocking simulation where all of the parameters (separation weight, cohesion weight, alignment weight, maximum force, maximum speed) change over time.  They could be controlled by Perlin noise or by user interaction (for example, you could use a library such as controlp5 to tie the values to slider positions.)</simpara>
</example>
<example id="chapter06_exercise19">
<title>Exercise 6.19</title>
<simpara>Visualize the flock in an entirely different way.</simpara>
</example>
</section>
<section id="chapter06_section14">
<title>6.14  Algorithmic Efficiency (or: Why does my $@(*%! run so slowly?)</title>
<simpara>I would like to hide the dark truth behind we’ve just done, because I would like you to be happy and live a fulfilling and meaningful life.  But I also would like to be able to sleep at night without worrying about you so much.  So it is with a heavy heart that I must bring up this topic.  Group behaviors are wonderful.  But they can be slow, and the more elements in the group, the slower they can be.  Usually, when we talk about Processing sketches running slowly, it’s because drawing to the screen can be slow—the more you draw, the slower your sketch runs.  This is actually a case, however, where the slowness derives from the algorithm itself.  Let’s discuss.</simpara>
<simpara>Computer scientists classify algorithms with something called “Big O notation”, which describes the efficiency of an algorithm: how many computational cycles does it require to complete?  Let’s consider a simple analog search problem.  You have a basket full of one hundred chocolate treats, only one of which is pure dark chocolate. That’s the one you want to eat.  To find it, you pick the chocolates out of the basket one by one.  Sure, you might be lucky and find it on the first try, but in the worst-case scenario you have to check all one hundred before you find the dark chocolate.   To find one thing in one hundred, you have to check one hundred things (or to find one thing in N things, you have to check N times.)  Your Big O Notation is N.  This incidentally is the Big O Notation that describes our simple particle system.  If we have N particles, we have to run and display those particles N times.</simpara>
<simpara>Now, let’s think about a group behavior (such as flocking).   For every Boid object, we have to check every other Boid object (for its velocity and location).  Let’s say we have one hundred boids.  For Boid #1, we need to check one hundred boids; for Boid #1, we need to check one hundred boids, and so on and so forth.   For one hundred boids, we need to perform one hundred times one hundred checks, or ten thousand.   No problem: computers are fast and can do things ten thousand times pretty easily.  Let’s try one thousand.</simpara>
<simpara>1,000 x 1,000 = 1,000,000 cycles.</simpara>
<simpara>OK, this is rather slow, but still somewhat manageable.   Let’s try 10,000 elements:</simpara>
<simpara>10,000 x 10,000 elements = 100,000,000 cycles.</simpara>
<simpara>Now, we’re really getting slow. Really, really, really slow.</simpara>
<simpara>Notice something odd?  As the number of elements increases by a factor of 10, the number of required cycles increases by a factor of 100.  Or as the number of elements increases by a factor of N, the cycles increase by a factor of N times N.  This is known as Big O Notation N-Squared.</simpara>
<simpara>I know what you are thinking.  You are thinking: “No problem; with flocking, we only need to consider the boids that are close to other boids.  So even if we have 1,000 boids, we can just look at, say, the five closest boids and then we only have 5,000 cycles.”   You pause for a moment, and then start thinking: “So for each boid I just need to check all the boids and find the five closest ones and I’m good!”  See the catch-22?  Even if we only want to look at the close ones, the only way to know what the close ones are would be to check all of them.</simpara>
<simpara>Or is there another way?</simpara>
<simpara>Let’s take a number that we might actually want to use, but would still run too slowly: 2,000 (4,000,000 cycles required).</simpara>
<simpara>What if we could divide the screen into a grid?  We would take all 2,000 boids and assign each boid to a cell within that grid.   We would then be able to look at each boid and compare it to its neighbors within that cell at any given moment. Imagine a 10 x 10 grid. In a system of 2,000 elements, on average, approximately 20 elements would be found in each cell (20 x 10 x 10 = 2,000).  Each cell would then require 20 x 20 = 400 cycles. With 100 cells, we’d have 100 x 400 = 40,000 cycles, a massive savings over 4,000,000.</simpara>
<informalfigure id="chapter06_figure39">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter06/ch06_39.png" />
  </imageobject>
  <textobject><phrase>Figure 6.39</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This technique is known as “bin-lattice spatial subdivision” and is outlined in more detail in (surprise, surprise) Reynolds’s 2000 paper: “Interaction with Groups of Autonomous Characters” (see: <ulink url="http://www.red3d.com/cwr/papers/2000/pip.pdf">Reynolds 2000 Paper</ulink>).   How do we implement such an algorithm in Processing?  One way is to keep multiple ArrayLists.  One ArrayList would keep track of all the boids, just like in our flocking example.</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;Boid&gt; boids;</programlisting>
<simpara>In addition to that ArrayList, we store an additional reference to each Boid object in a two-dimensional ArrayList.  For each cell in the grid, there is an ArrayList that tracks the objects in that cell.</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;Boid&gt;[][] grid;</programlisting>
<simpara>In the main <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop, each Boid object then registers itself in the appropriate cell according to its location.</simpara>
<programlisting language="java" linenumbering="unnumbered">int column = int(boid.x) / resolution;
int row    = int(boid.y) /resolution;
grid[column][row].add(boid);</programlisting>
<simpara>Then when it comes time to have the boids check for neighbors, they can look at only those in their particular cell (in truth, we also need to check neighboring cells to deal with border cases).</simpara>
<simpara id="chapter06_example10"><emphasis role="strong"><phrase role="example">Example 6.10: Bin-lattice spatial subdivision</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="notetoself">oops have to make this example!</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">int column = int(boid.x) / resolution;
int row    = int(boid.y) /resolution;
boid.flock(boids);
// Instead of looking at all
// the boids, just this cell
boid.flock(grid[column][row]);</programlisting>
<simpara>We’re only covering the basics here; for the full code, check the book’s web site.</simpara>
<simpara>Now, there are certainly flaws with this system.  What if all the boids congregate in the corner and live in the same cell? Then don’t we have to check all 2,000 against all 2,000?</simpara>
<simpara>The good news is that this need for optimization is a common one and there are a wide variety of similar techniques out there.   For us, it’s likely that a basic approach will be good enough (in most cases, you won’t need one at all).  For another, more sophisticated approach, check out <ulink url="http://toxiclibs.org/2010/02/new-package-simutils/">toxiclibs Octree examples</ulink>.</simpara>
</section>
<section id="chapter06_section15">
<title>6.15  A Few Last Notes: Optimization Tricks</title>
<simpara>This is something of a momentous occasion.  The end of Chapter 6 marks the end of our story of motion (in the context of this book, that is).  We started with the concept of a vector, moved onto forces, designed systems of many elements, examined physics libraries, built entities with hopes and dreams and fears, and simulated emergence.  The story doesn’t end here, but it does take a bit of a turn.  The next two chapters won’t focus on moving bodies, but rather on systems of rules.   Before we get there, I have a few quick items I’d like to mention that are important when working with the examples in Chapters 1-6.  They also relate to optimizing your code, which fits in with the previous section.</simpara>
<section id="_1_magnitude_squared_or_sometimes_distance_squared">
<title>1) Magnitude squared (or sometimes distance squared)</title>
<simpara>What is magnitude squared and when should you use it?  Let’s revisit how the magnitude of a vector is calculated.</simpara>
<programlisting language="java" linenumbering="unnumbered">float mag() {
  return sqrt(x*x + y*y);
}</programlisting>
<simpara>Magnitude requires the square root operation.  And it should.  After all, if you want the magnitude of a vector then you’ve got to look up the Pythagorean theorem and compute it (we did this in Chapter 1.)  However, if you could somehow skip using the square root, your code would run faster.   Let’s consider a situation where you just want to know the relative magnitude of a vector.  For example, is the magnitude greater than ten?  (Assume a PVector v.)</simpara>
<programlisting language="java" linenumbering="unnumbered">if (v.mag() &gt; 10) {
  [inline]// Do Something!
}</programlisting>
<simpara>Well, this is equivalent to saying:</simpara>
<programlisting language="java" linenumbering="unnumbered">if (v.magSq() &gt; 100) {
  [inline]// Do Something!
}</programlisting>
<simpara>And how is magSquared calculated?</simpara>
<programlisting language="java" linenumbering="unnumbered">float magSq() {
  return x*x + y*y;
}</programlisting>
<simpara>Same as magnitude, but without the square root.  In the case of a single PVector object, this will never make a significant difference on a Processing sketch.  However, if you are computing the magnitude of thousands of PVector objects each time through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, using <emphasis role="strong"><phrase role="function">magSq()</phrase></emphasis> instead of <emphasis role="strong"><phrase role="function">mag()</phrase></emphasis> could help your code run a wee bit faster.  (Note magSq() is only available in Processing 2.0a1 or later.)</simpara>
</section>
<section id="_2_sine_and_cosine_lookup_tables">
<title>2) Sine and cosine lookup tables</title>
<simpara>There’s a pattern here.  What kinds of functions are slow to compute? Square root. Sine. Cosine.  Tangent.  Again, if you just need a sine or cosine value here or there in your code, you are never going to run into a problem.  But what if you had something like this?</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  for (int i = 0; i &lt; 10000; i++) {
     println(sin(PI));
  }
}</programlisting>
<simpara>Sure, this is a totally ridiculous code snippet that you would never write.  But it illustrates a certain point.  If you are calculating the sine of pi ten thousand times, why not just calculate it once, save that value, and refer to it whenever necessary?  This is the principle behind sine and cosine lookup tables.   Instead of calling the sine and cosine functions in your code whenever you need them, you can build an array that stores the results of sine and cosine at angles between 0 to TWO_PI and just look up the values when you need them. For example, here are two arrays that store the sine and cosine values for every angle, 0 to 359 degrees.</simpara>
<programlisting language="java" linenumbering="unnumbered">float sinvalues[] = new float[360];
float cosvalues[] = new float[360];
for (int i = 0; i &lt; 360; i++) {
  sinvalues[i] = sin(radians(i));
  cosvalues[i] = cos(radians(i));
}</programlisting>
<simpara>Now, what if you need the value of sine of pi?</simpara>
<programlisting language="java" linenumbering="unnumbered">int angle = int(degrees(PI));
float answer = sinvalues[angle];</programlisting>
<simpara>A more sophisticated example of this technique is available on the <ulink url="http://wiki.processing.org/w/Sin/Cos_look-up_table">Processing wiki</ulink>.</simpara>
</section>
<section id="_3_making_gajillions_of_unnecessary_pvector_objects">
<title>3) Making gajillions of unnecessary PVector objects</title>
<simpara>I have to admit, I am perhaps the biggest culprit of this last note.  In fact, in the interest of writing clear and understandable examples, I often choose to make extra PVector objects when I absolutely do not need to.  For the most part, this is not a problem at all.   But sometimes, it can be.  Let’s take a look at an example.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  for (Vehicle v : vehicles) {
   PVector mouse = new PVector(mouseX,mouseY);
   v.seek(mouse);
  }
}</programlisting>
<simpara>Let’s say our ArrayList of vehicles has one thousand vehicles in it.  We just made one thousand new PVector objects every single time through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.  Now, on any ol’ laptop or desktop computer you’ve purchased in recent times, your sketch will likely not register a complaint, run slowly, or have any problems.  After all, you’ve got tons of RAM, and Java will be able to handle making a thousand or so temporary objects and dispose of them without much of a problem.</simpara>
<simpara>If your numbers grow larger (and they easily could) or perhaps more likely, if you are working with Processing on Android, you will almost certainly run into a problem.  In cases like this you want to look for ways to reduce the number of PVector objects you make.  An obvious fix for the above code is:</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  PVector mouse = new PVector(mouseX,mouseY);
  for (Vehicle v : vehicles) {
   v.seek(mouse);
  }
}</programlisting>
<simpara>Now you’ve made just one PVector instead of one thousand.  Even better, you could turn the PVector into a global variable and just assign the x and y value:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector mouse = new PVector();

void draw() {
  mouse.x = mouseX;
  mouse.y = mouseY;
  for (Vehicle v : vehicles) {
   v.seek(mouse);
  }
}</programlisting>
<simpara>Now you never make a new PVector; you use just one over the length of your sketch!</simpara>
<simpara>In my examples, you’ll find lots of opportunities to reduce the number of temporary objects.  Let’s look at one more.  Here is a snippet from our <emphasis role="strong"><phrase role="function">seek()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);

    // Create a new PVector to store the steering force.
    PVector steer = PVector.sub(desired,velocity); // [bold]
    steer.limit(maxforce);
    return steer;</programlisting>
<simpara>See how we’ve made two PVector objects?  First, we figure out the desired vector, then we calculate the steering force.  Notice how we could rewrite this to create only one PVector.</simpara>
<programlisting language="java" linenumbering="unnumbered">    PVector desired = PVector.sub(target, location);
    desired.normalize();
    desired.mult(maxspeed);

    // Calculate the steering force in the desired PVector.
    desired.sub(velocity); // [bold]
    desired.limit(maxforce);
    return desired;</programlisting>
<simpara>We don’t actually need a second PVector called steer.  We could just use the desired PVector object and turn it into the steering force by subtracting velocity.  I didn’t do this in my example because it is more confusing to read.  But in some cases, it may be greatly more efficient.</simpara>
<example id="chapter06_exercise20">
<title>Exercise 6.20</title>
<simpara>Eliminate as many temporary PVector objects from the flocking example as possible.  Also use <emphasis role="strong"><phrase role="function">magSquared()</phrase></emphasis> where possible.</simpara>
</example>
<example id="chapter06_exercise21">
<title>Exercise 6.21</title>
<simpara>Use steering behaviors with Box2D or toxiclibs.</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 6 Exercise:</simpara>
<simpara>Use the concept of steering forces to drive the behavior of your creatures in your ecosystem.  Some possibilities:</simpara>
<itemizedlist>
<listitem>
<simpara>
Create “schools” or “flocks” of creatures.
</simpara>
</listitem>
<listitem>
<simpara>
Use a seeking behavior for creatures to search for food (for chasing moving prey, consider “pursuit”).
</simpara>
</listitem>
<listitem>
<simpara>
Use a flow field for the ecosystem environment.  For example, how does your system behave if the creatures live in a flowing river?
</simpara>
</listitem>
<listitem>
<simpara>
Build a creature with countless steering behaviors (as many as you can reasonably add).  Think about ways to vary the weights of these behaviors so that you can dial those behaviors up and down, mixing and matching on the fly.    How are creatures’ initial weights set?  What rules drive how the weights change over time?
</simpara>
</listitem>
<listitem>
<simpara>
Complex systems can be nested.  Can you design a single creature out of a flock of boids?  And can you then make a flock of those creatures?
</simpara>
</listitem>
<listitem>
<simpara>
Complex systems can have memory (and be adaptive).  Can the history of your ecosystem affect the behavior in its current state? (This could be the driving force behind how the creatures adjust their steering force weights.)
</simpara>
</listitem>
</itemizedlist>
</tip>
</section>
</section>
</chapter>
<chapter id="_chapter_7_cellular_automata">
<title>Chapter 7.  Cellular Automata</title>
<blockquote>
<attribution>
Martin Gardner
<citetitle>Scientific American (October 1970)</citetitle>
</attribution>
<simpara>“To play life you must have a fairly large checkerboard and a plentiful supply of flat counters of two colors.  It is possible to work with pencil and graph paper but it is much easier, particularly for beginners, to use counters and a board.”</simpara>
</blockquote>
<simpara>In this chapter, we’re going to take a break from talking about vectors and motion.  In fact, the rest of the book will mostly focus on systems and algorithms (albeit ones that we can, should, and will apply to moving bodies).  In the previous chapter, we encountered our first Processing example of a complex system: flocking.  We briefly stated the core principles behind complex systems: more than the sum of its parts, a complex system is a system of elements, operating in parallel, with short-range relationships that as a whole exhibit emergent behavior.   This entire chapter is going to be dedicated to building another complex system simulation in Processing.    Oddly, we are going to take some steps backward and simplify the elements of our system.  No longer are the individual elements going to be members of a physics world; instead we will build a system out of the simplest digital element possible, a single bit.  This bit is going to be called a cell and its value (zero or one) will be called its state.  Working with such simple elements will help us understand more of the details behind how complex systems work, and we’ll also be able to elaborate on some programming techniques that we can apply to code-based projects.</simpara>
<section id="chapter07_section1">
<title>7.1 What Is a Cellular Automaton?</title>
<simpara>First, let’s get one thing straight.   The term <emphasis role="strong"><emphasis>cellular automata</emphasis></emphasis> is plural.   Our code examples will simulate just one—a <emphasis role="strong"><emphasis>cellular automaton</emphasis></emphasis>, singular.   To simplify our lives, we’ll also refer to cellular automata as “CA.”</simpara>
<simpara>In Chapters 1 through 6, our objects (Mover, Particle, Vehicle, Boid) generally existed in only one “state”. They might have moved around with advanced behaviors and physics, but ultimately they have remained the same type of object over the course of their digital lifetime.  We’ve alluded to the possibility that these entities can change over time (for example, the weights of steering “desires” can vary), but we haven’t fully put this into practice.   In this context, cellular automata make a great first step in building a system of many objects that have varying states over time.</simpara>
<simpara>A cellular automaton is a model of a system of “cell” objects with the following characteristics.</simpara>
<itemizedlist>
<listitem>
<simpara>
The cells live on a <emphasis role="strong"><emphasis>grid</emphasis></emphasis>. (We’ll see examples in both one and two dimensions in this chapter, though a cellular automaton can exist in any finite number of dimensions.)
</simpara>
</listitem>
<listitem>
<simpara>
Each cell has a <emphasis role="strong"><emphasis>state</emphasis></emphasis>.  The number of state possibilities is typically finite. The simplest example has the two possibilities of one and zero (otherwise referred to as “on” and “off” or “alive” and “dead.”)
</simpara>
</listitem>
<listitem>
<simpara>
Each cell has a <emphasis role="strong"><emphasis>neighborhood</emphasis></emphasis>.  This can be defined in any number of ways, but it is typically a list of adjacent cells.
</simpara>
</listitem>
</itemizedlist>
<informalfigure id="chapter07_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_01.png" />
  </imageobject>
  <textobject><phrase>Figure 7.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The development of cellular automata systems is typically attributed to Stanisław Ulam and John von Neumann, who were both researchers at the Los Alamos National Laboratory in New Mexico in the 1940s.  Ulam was studying the growth of crystals and von Neumann was imagining a world of self-replicating robots.  That’s right, robots that build copies of themselves.  Once we see some examples of CA visualized, it’ll be clear how one might imagine modeling crystal growth; the robots idea is perhaps less obvious.   Consider the design of a robot as a pattern on a grid of cells (think of filling in some squares on a piece of graph paper).  Now consider a set of simple rules that would allow that pattern to create copies of itself on that grid.  This is essentially the process of a CA that exhibits behavior similar to biological reproduction and evolution.  (Incidentally, von Neumann’s cells had twenty-nine possible states.)  Von Neumann’s work in self-replication and CA is conceptually similar to what is probably the most famous cellular automaton: the “Game of Life,” which we will discuss in detail in section 7.3.</simpara>
<simpara><emphasis role="strong"><phrase role="notetoself">[FIGURE?  Can I find some nice diagram / illustration of Ulam or von Neumann’s work?]</phrase></emphasis></simpara>
<simpara>Perhaps the most significant scientific (and lengthy) work studying cellular automata arrived in 2002: Stephen Wolfram’s 1,280-page <emphasis>A New Kind of Science</emphasis>.  Wolfram’s book, available in its entirety for free online (<ulink url="http://www.wolframscience.com/nksonline/toc.html">A New Kind of Science</ulink>), discusses how CA are not simply neat tricks, but are relevant to the study of biology, chemistry, physics, and all branches of science.  This chapter will barely scratch the surface of the theories Wolfram outlines (we will focus on the code implementation) so if the examples provided spark your curiosity, you’ll find plenty more to read about in his book.</simpara>
</section>
<section id="chapter07_section2">
<title>7.2  Elementary Cellular Automata</title>
<simpara>The examples in this chapter will begin with a simulation of Wolfram’s work.   To understand Wolfram’s elementary CA, we should ask ourselves the question: “What is the simplest cellular automaton we can imagine?”  What’s exciting about this question and its answer is that even with the simplest CA imaginable, we will see the properties of complex systems at work.</simpara>
<simpara>Let’s build Wolfram’s elementary CA from scratch.  Concepts first, then code.   What are the three key elements of a CA?</simpara>
<simpara>1) <emphasis role="strong"><emphasis>Grid</emphasis></emphasis>  The simplest grid would be one-dimensional: a line of cells.</simpara>
<informalfigure id="chapter07_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_02.png" />
  </imageobject>
  <textobject><phrase>Figure 7.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>2) <emphasis role="strong"><emphasis>States</emphasis></emphasis>  The simplest set of states (beyond having only one state) would be two states: 0 or 1.</simpara>
<informalfigure id="chapter07_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_03.png" />
  </imageobject>
  <textobject><phrase>Figure 7.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>3) <emphasis role="strong"><emphasis>Neighborhood</emphasis></emphasis>  The simplest neighborhood in one dimension for any given cell would be the cell itself and its two adjacent neighbors: one to the left and one to the right.</simpara>
<informalfigure id="chapter07_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_04.png" />
  </imageobject>
  <textobject><phrase>Figure 7.4: A Neighborhood is 3 cells.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>So we begin with a line of cells, each with an initial state (let’s say it is random), and each with two neighbors.   We’ll have to figure out what we want to do with the cells on the edges (since those have only one neighbor each), but this is something we can sort out later.</simpara>
<informalfigure id="chapter07_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_05.png" />
  </imageobject>
  <textobject><phrase>Figure 7.5: The edge cell only has a neighborhood of 2.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We haven’t yet discussed, however, what is perhaps the most important detail of how cellular automata work—<emphasis role="strong"><emphasis>time</emphasis></emphasis>.   We’re not really talking about real-world time here, but about the CA living over a period of <emphasis role="strong"><emphasis>time</emphasis></emphasis>, which could also be called a <emphasis role="strong"><emphasis>generation</emphasis></emphasis> and, in our case, will likely refer to the <emphasis role="strong"><emphasis>frame count</emphasis></emphasis> of an animation.  The figures above shows us the CA at time equals zero or generation 0.  The questions we have to ask ourselves are: <emphasis>How do we compute the states for all cells at generation 1?  And generation 2?</emphasis>  And so on and so forth.</simpara>
<informalfigure id="chapter07_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_06.png" />
  </imageobject>
  <textobject><phrase>Figure 7.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s say we have an individual cell in the CA, and let’s call it CELL.   The formula for calculating CELL’s state at any given time (“t”) is as follows:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">CELL state at time t = f(CELL neighborhood at time t - 1)</phrase></emphasis></simpara>
<simpara>In other words, a cell’s new state is a function of all the states in the cell’s neighborhood at the previous moment in time (or during the previous generation).  We calculate a new state value by looking at all the previous neighbor states.</simpara>
<informalfigure id="chapter07_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_07.png" />
  </imageobject>
  <textobject><phrase>Figure 7.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now, in the world of cellular automata, there are many ways we could compute a cell’s state from a group of cells.  Consider blurring an image.  (Guess what? Image processing works with CA-like rules.)  A pixel’s new state (i.e. its color) is the average of all of its neighbors’ colors.  We could also say that a cell’s new state is the sum of all of its neighbors’ states.   With Wolfram’s elementary CA, however, we can actually do something a bit simpler and seemingly absurd: We can look at all the possible configurations of a cell and its neighbor and define the state outcome for every possible configuration.  It seems ridiculous—wouldn’t there be way too many possibilities for this to be practical?   Let’s give it a try.</simpara>
<simpara>We have three cells, each with a state of 0 or 1.  How many possible ways can we configure the states?  If you love binary, you’ll notice that three cells define a 3-bit number, and how high can you count with three bits?  Up to eight.  Let’s have a look.</simpara>
<informalfigure id="chapter07_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_08.png" />
  </imageobject>
  <textobject><phrase>Figure 7.8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Once we have defined all the possible neighborhoods, we need to define an outcome (new state value: 0 or 1) for each neighborhood configuration.</simpara>
<informalfigure id="chapter07_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_09.png" />
  </imageobject>
  <textobject><phrase>Figure 7.9</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The standard Wolfram model is to start Generation 0 with all cells having a state of 0 except for the middle cell, which should have a state of 1.</simpara>
<informalfigure id="chapter07_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_10.png" />
  </imageobject>
  <textobject><phrase>Figure 7.10</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Referring to the ruleset above, let’s see how a given cell (let’s pick the center one) would change from Generation 0 to Generation 1.</simpara>
<informalfigure id="chapter07_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_11.png" />
  </imageobject>
  <textobject><phrase>Figure 7.11</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Try applying the same logic to all of the cells above and fill in the empty cells.</simpara>
<simpara>Now, let’s go past just one generation and color the cells —0 means white, 1 means black—and stack the generations, with each new generation appearing below the previous one.</simpara>
<informalfigure id="chapter07_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_12.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.12: Rule 90</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The low-resolution shape we’re seeing above is the “Sierpiński triangle.” Named after the Polish mathematician Wacław Sierpiński, it’s a fractal pattern that we’ll examine in the next chapter.  That’s right: this incredibly simple system of zeros and ones, with little neighborhoods of three cells, can generate a shape as sophisticated and detailed as the Sierpiński triangle.   Let’s look at it again, only with each cell a single pixel wide so that the resolution is much higher.</simpara>
<informalfigure id="chapter07_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_13.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.13: Rule 90</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This particular result didn’t happen by accident.  I picked this set of rules because of the pattern it generates.  Take a look at Figure 7.8 one more time.  Notice how there are eight possible neighborhood configurations; we therefore define a “ruleset” as a list of eight bits.</simpara>
<simpara>So this particular rule can be illustrated as follows:</simpara>
<informalfigure id="chapter07_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_14.png" />
  </imageobject>
  <textobject><phrase>Figure 7.14: Rule 90</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Eight zeros and ones means an 8-bit number.  How many combinations of eight zeros and ones are there?  Two hundred and fifty six.  This is just like how we define the components of an RGB color.  We get 8 bits for red, green, and blue, meaning we make colors with values from 0 to 255 (256 possibilities).</simpara>
<simpara>In terms of a Wolfram elementary CA, we have now discovered that there are 256 possible rulesets.   The above ruleset is commonly referred to as “Rule 90” because if you convert the binary sequence—01011010—to a decimal number, you’ll get the integer 90.  Let’s try looking at the results of another ruleset.</simpara>
<informalfigure id="chapter07_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_15.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.15: Rule 222</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter07_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_16.jpeg" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 7.16: A Textile Cone Snail (Conus textile), Cod Hole, Great Barrier Reef, Australia, 7 August 2005, Photographer: Richard Ling richard@research.canon.com.au</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>As we can now see, the simple act of creating a CA and defining a ruleset does not guarantee visually interesting results. Out of all 256 rulesets, only a handful produce compelling outcomes.  However, the fact that even one of these rulesets for a one-dimensional CA with only two possible states can produce the patterns we see every day in nature (see Figure 7.16) is quite incredible and demonstrates how valuable these systems can be in simulation and pattern generation.</simpara>
<simpara>Before we go too far down the road of how Wolfram classifies the results of varying rulesets, let’s look at how we actually build a Processing sketch that generates the Wolfram CA and visualizes it onscreen.</simpara>
</section>
<section id="chapter07_section3">
<title>7.3 How to Program an Elementary CA</title>
<simpara>You may be thinking: “OK, I’ve got this cell thing.  And the cell thing has some properties, like a state, what generation it’s on, who its neighbors are, where it lives pixel-wise on the screen.   And maybe it has some functions: it can display itself, it can generate its new state, etc.”  This line of thinking is an excellent one and would likely lead you to write some code like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Cell {

}</programlisting>
<simpara>This line of thinking, however, is not the road we will first travel.  Later in this chapter, we will discuss why an object-oriented approach could prove valuable in developing a CA simulation, but to begin,we can work with a more elementary data structure.  After all, what is an elementary CA but a list of zeros and ones?   Certainly, we could describe the following CA generation using  an array:</simpara>
<informalfigure id="chapter07_figure17">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_17.png" />
  </imageobject>
  <textobject><phrase>Figure 7.17</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">int[] cells = {1,0,1,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,0,0};</programlisting>
<simpara>To draw that array, we simply check if we’ve got a zero or a one and create a fill accordingly.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Loop through every cell.
for (int i = 0; i &lt; cells.length; i++) {
  if (cells[i] == 0) fill(255);
  // Create a fill based on its state (0 or 1).
  else fill(0);
  stroke(0);
  rect(i*50,0,50,50);
}</programlisting>
<simpara>Now that we have the array to describe the cell states of a given generation (which we’ll ultimately consider the “current” generation), we need a mechanism by which to compute the next generation.   Let’s think about the pseudocode of what we are doing at the moment.</simpara>
<simpara><emphasis role="strong"><emphasis>For every cell in the array:</emphasis></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Take a look at the neighborhood states: left, middle, right.</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Look up the new value for the cell state according to some ruleset.</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Set the cell’s state to that new value.</emphasis></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>This may lead you to write some code like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">// For every cell in the array...
for (int i = 0; i &lt; cells.length; i++) {

  // ...take a look at the neighborhood.
  int left   = cell[i-1];
  int middle = cell[i];
  int right  = cell[i+1];

  // Look up the new value according to the rules.
  int newstate = rules(left,middle,right);

  // Set the cell’s state to the new value.
  cell[i] = newstate;
}</programlisting>
<simpara>We’re fairly close to getting this right, but we’ve made one minor blunder and one major blunder in the above code.  Let’s talk about what we’ve done well so far.</simpara>
<simpara>Notice how easy it is to look at a cell’s neighbors.  Because an array is an ordered list of data, we can use the fact that the indices are numbered to know which cells are next to which cells.  We know that cell number fifteen, for example, has cell fourteen to its left and sixteen to its right.  More generally, we can say that for any cell <emphasis role="strong"><phrase role="var">i</phrase></emphasis>, its neighbors are <emphasis role="strong"><phrase role="var">i-1</phrase></emphasis> and <emphasis role="strong"><phrase role="var">i+1</phrase></emphasis>.</simpara>
<simpara>We’re also farming out the calculation of a new state value to some function called <emphasis role="strong"><phrase role="function">rules()</phrase></emphasis>.  Obviously, we’re going to have to write this function ourselves, but the point we’re making here is modularity.  We have a basic framework for the CA in this function, and if we later want to change how the rules operate, we don’t have to touch that framework; we can simply rewrite the <emphasis role="strong"><phrase role="function">rules()</phrase></emphasis> function to compute the new states differently.</simpara>
<simpara>So what have we done wrong?  Let’s begin talking through how the code will execute.  First, we look at cell index i equals 0.  Now let’s look at 0’s neighbors.  Left is index -1.  Middle is index 0.  And right is index 1.  However, our array by definition does not have an element with the index -1.  It starts with 0.  This is a problem we’ve alluded to before: the edge cases.</simpara>
<simpara>How do we deal with the cells on the edge who don’t have a neighbor to both their left and right?  Here are three possible solutions to this problem:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Edges remain constant.</emphasis></emphasis>  This is perhaps the simplest solution.  We never bother to evaluate the edges and always leave their state value constant (0 or 1).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Edges wrap around.</emphasis></emphasis>  Think of the CA as a strip of paper and turn that strip of paper into a ring.  The cell on the left edge is a neighbor of the cell on the right and vice versa.  This can create the appearance of an infinite grid and is probably the most used solution.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Edges have different neighborhoods and rules.</emphasis></emphasis>  If we wanted to, we could treat the edge cells differently and create rules for cells that have a neighborhood of two instead of three.  You may want to do this in some circumstances, but in our case, it’s going to be a lot of extra lines of code for little benefit.
</simpara>
</listitem>
</orderedlist>
<simpara>To make the code easiest to read and understand right now, we’ll go with option #1 and just skip the edge cases, leaving their values constant.  This can be accomplished by starting the loop one cell later and ending one cell earlier:</simpara>
<programlisting language="java" linenumbering="unnumbered">// A loop that ignores the first and last cell
for (int i = 1; i &lt; cells.length-1; i++) { // [bold]
  int left   = cell[i-1];
  int middle = cell[i];
  int right  = cell[i+1];
  int newstate = rules(left,middle,right);
  cell[i] = newstate;
}</programlisting>
<simpara>There’s one more problem we have to fix before we’re done.  It’s subtle and you won’t get a compilation error; the CA just won’t perform correctly.  However, identifying this problem is absolutely fundamental to the techniques behind programming CA simulations.  It all lies in this line of code:</simpara>
<programlisting language="java" linenumbering="unnumbered">  cell[i] = newstate;</programlisting>
<simpara>This seems like a perfectly innocent line.  After all, we’ve computed the new state value and we’re simply giving the cell its new state.   But in the next iteration, you’ll discover a massive bug.  Let’s say we’ve just computed the new state for cell #5.  What do we do next?  We calculate the new state value for Cell #6.</simpara>
<simpara><emphasis>Cell #6, generation 0 = some state, 0 or 1</emphasis><?asciidoc-br?>
<emphasis>Cell #6, generation 1 = a function of states for <emphasis role="strong">Cell #5</emphasis>, Cell #6, and Cell #7 at *generation 0*</emphasis></simpara>
<simpara>Notice how we need the value of Cell #5 at generation 0 in order to calculate Cell #6’s new state at Generation 1?  A cell’s new state is a function of the previous neighbor states.   Do we know Cell #5’s value at Generation 0?   Remember, Processing just executes this line of code for <emphasis>i = 5</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  cell[i] = newstate;</programlisting>
<simpara>Once this happens, we no longer have access to Cell #5’s state at Generation 0, and cell index 5 is storing the value for Generation 1.  We cannot overwrite the values in the array while we are processing the array, because we need those values to calculate the new values.   A solution to this problem is to have two arrays, one to store the current generation states and one for the next generation states.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Another array to store the states
// for the next generation.
int[] newcells = new int[cells.length]; // [bold]

for (int i = 1; i &lt; cells.length-1; i++) {
  // Look at the states from the current array.
  int left   = cell[i-1];
  int middle = cell[i];
  int right  = cell[i+1];
  int newstate = rules(left,middle,right);
  // Saving the new state in the new array
  newcells[i] = newstate; // [bold]
}</programlisting>
<simpara>Once the entire array of values is processed, we can then discard the old array and set it equal to the new array of states.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The new generation becomes the current generation.
cells = newcells; // [bold]</programlisting>
<simpara>We’re almost done.  The above code is complete except for the fact that we haven’t yet written the <emphasis role="strong"><phrase role="function">rules()</phrase></emphasis> function that computes the new state value based on the neighborhood (left, middle, and right).   We know that function needs to return an integer (0 or 1) as well as receive three arguments (for the three neighbors).</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Function receives 3 ints and returns 1
  int rules (int a, int b, int c) {</programlisting>
<simpara>Now, there are many ways we could write this function, but I’d like to start with a long-winded one that will hopefully provide a clear illustration of what we are doing.</simpara>
<simpara>Let’s first establish how we are storing the ruleset.  The ruleset, if you remember from the previous section, is a series of eight bits (0 or 1) that defines that outcome for every possible neighborhood configuration.</simpara>
<informalfigure id="chapter07_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_14.png" />
  </imageobject>
  <textobject><phrase>Figure 7.14 (repeated)</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We can store this ruleset in Processing as an array.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] ruleset = {0,1,0,1,1,0,1,0};</programlisting>
<simpara>And then say:</simpara>
<programlisting language="java" linenumbering="unnumbered">if (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[0];</programlisting>
<simpara>If left, middle, and right all have the state 1, then that matches the configuration 111 and the new state should be equal to the first element in the ruleset.   We can now duplicate this strategy for all eight possibilities.</simpara>
<programlisting language="java" linenumbering="unnumbered">  int rules (int a, int b, int c) {
    if      (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[0];
    else if (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 0) return ruleset[1];
    else if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 1) return ruleset[2];
    else if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 0) return ruleset[3];
    else if (a == 0 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[4];
    else if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 1) return ruleset[6];
    else if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) return ruleset[7];
    // For this function to be valid, we have to make sure something is returned
    // in cases where the states do not match one of the eight possibilities.
    // We know this is impossible given the rest of our code, but Processing does not.
    return 0;
  }</programlisting>
<simpara>I like having the example written as above because it describes line by line exactly what is happening for each neighborhood configuration.  However, it’s not a great solution.  After all, what if we design a CA that has 4 possible states (0-3) and suddenly we have 64 possible neighborhood configurations?  With 10 possible states, we have 1,000 configurations.  Certainly we don’t want to type in 1,000 lines of code!</simpara>
<simpara>Another solution, though perhaps a bit more difficult to follow, is to convert the neighborhood configuration (a 3-bit number) into a regular integer and use that value as the index into the ruleset array.  This can be done in Java like so.</simpara>
<programlisting language="java" linenumbering="unnumbered">  int rules (int a, int b, int c) {
    // A quick way to join three bits into a String
    String s = "" + a + b + c;

    // The second argument ‘2’ indicates that we intend to
    // parse a binary number (base 2).
    int index = Integer.parseInt(s,2);

    return ruleset[index];
  }</programlisting>
<simpara>There’s one tiny problem with this solution, however.  Let’s say we are implementing rule 222:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Rule 222
int[] ruleset = {1,1,0,1,1,1,1,0};</programlisting>
<simpara>And we have the neighborhood “111”.    The resulting state is equal to ruleset index 0, as we see in the first way we wrote the function.</simpara>
<programlisting language="java" linenumbering="unnumbered">    if (a == 1 &amp;&amp; b == 1 &amp;&amp; c == 1) return ruleset[0];</programlisting>
<simpara>If we convert “111” to a decimal number, we get 7.  But we don’t want ruleset[7]; we want ruleset[0].  For this to work, we need to write the ruleset with the bits in reverse order, i.e.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Rule 222 in “reverse” order
int[] ruleset = {0,1,1,1,1,0,1,1};</programlisting>
<simpara>So far in this section, we’ve written everything we need to compute the generations for a Wolfram elementary CA.    Let’s take a moment to organize the above code into a class, which will ultimately help in the design of our overall sketch.</simpara>
<programlisting language="java" linenumbering="unnumbered">class CA {
  // We need an array for the cells and
  // one for the rules.
  int[] cells;
  int[] ruleset;

  CA() {
    cells = new int[width];
    // Arbitrarily starting with rule 90
    ruleset = {0,1,0,1,1,0,1,0};

    for (int i = 0; i &lt; cells.length; i++) {
      cells[i] = 0;
    }
    // All cells start with state 0, except the center
    // cell has state 1.
    cells[cells.length/2] = 1;
  }

  void generate() {
    // Compute the next generation.
    int[] nextgen = new int[cells.length];
    for (int i = 1; i &lt; cells.length-1; i++) {
      int left   = cells[i-1];
      int me     = cells[i];
      int right  = cells[i+1];
      nextgen[i] = rules(left, me, right);
    }
    cells = nextgen;
  }

  // Look up a new state from the ruleset.
  int rules (int a, int b, int c) {
    String s = "" + a + b + c;
    int index = Integer.parseInt(s,2);
    return ruleset[index];
  }
}</programlisting>
</section>
<section id="chapter07_section4">
<title>7.4 Drawing an Elementary CA</title>
<simpara>￼
What’s missing?  Presumably, it’s our intention to display cells and their states in visual form.  As we saw earlier, the standard technique for doing this is to stack the generations one on top of each other and draw a rectangle that is black (for state 1) or white (for state 0).</simpara>
<informalfigure id="chapter07_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_12.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.12 (repeated)</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Before we implement this particular visualization, I’d like to point out two things.</simpara>
<simpara>One, this visual interpretation of the data is completely literal.  It’s useful for demonstrating the algorithms and results of Wolfram’s elementary CA, but it shouldn’t necessarily drive your own personal work.  It’s rather unlikely that you are building a project that needs precisely this algorithm with this visual style.  So while learning to draw the CA in this way will help you understand and implement CA systems, this skill should exist only as a foundation.</simpara>
<simpara>Second, the fact that we are visualizing a one-dimensional CA with a two-dimensional image can be confusing.  It’s very important to remember that this is not a 2D CA.  We are simply choosing to show a history of all the generations stacked vertically.  This technique creates a two-dimensional image out of a many instances of one-dimensional data.  But the system itself is one-dimensional.  Later, we are going to look at an actual 2D CA (the Game of Life) and discuss how we might choose to display such a system.</simpara>
<simpara>The good news is that drawing the CA is not particularly difficult.  Let’s begin by looking at how we would render a single generation.  Assume we have a Processing window 600 pixels wide and we want each cell to be a 10x10 square.  We therefore have a CA with 60 cells.  Of course, we can calculate this value dynamically.</simpara>
<programlisting language="java" linenumbering="unnumbered">int w = 10;
// How many cells fit across given a certain width
int[] cells = new int[width/w];</programlisting>
<simpara>Assuming we’ve gone through the process of generating the cell states (which we did in the previous section), we can now loop through the entire array of cells, drawing a black cell when the state is one and a white one when the state is zero.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = 0; i &lt; cells.length; i++) {
  // Black or white fill?
  if (cells[i] == 1) fill(0);
  else               fill(255);
  // Notice how the x location is the cell index times the cell width.
  // In the above scenario, this would give us cells located at x equals 0, 10, 20, 30, all the way up to 600.
  rect(i*w, 0, w, w);
}</programlisting>
<simpara>In truth, we could optimize the above by having a white background and only drawing when there is a black cell (saving us the work of drawing many white squares), but in most cases this solution is good enough (and necessary for other more sophisticated designs with varying colors, etc).  Also, if we wanted each cell to be represented as a single pixel, we would not want to use Processing’s <emphasis role="strong"><phrase role="function">rect()</phrase></emphasis> function, but rather access the pixel array directly.</simpara>
<simpara>In the above code, you’ll notice the y location for each rectangle is zero.  If we want the generations to be drawn next to each other, with each row of cells marking a new generation, we’ll also need to compute a y location based on how many iterations of the CA we’ve executed.  We could accomplish this by adding a “generation” variable (an integer) to our CA class and incrementing it each time through <emphasis role="strong"><phrase role="function">generate()</phrase></emphasis>.  With these additions, we can now look at the CA class with all the features for both computing and drawing the CA.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_ex01.png" canvas="processingjs/chapter07/Ex_7_01_WolframCA_randomizedrules/Ex_7_01_WolframCA_randomizedrules.pde processingjs/chapter07/Ex_7_01_WolframCA_randomizedrules/CA.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter07/ch07_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter07_example1"><emphasis role="strong"><phrase role="example">Example 7.1: Wolfram elementary cellular automata</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class CA {
  int[] cells;
  int[] ruleset;
  int w = 10;
  // The CA should keep track of how
  // many generations.
  int generation = 0;
  CA() {
    cells = new int[width/w];
    ruleset = {0,1,0,1,1,0,1,0};
    cells[cells.length/2] = 1;
  }

  void generate() {
    int[] nextgen = new int[cells.length];
    for (int i = 1; i &lt; cells.length-1; i++) {
      int left   = cells[i-1];
      int me     = cells[i];
      int right  = cells[i+1];
      nextgen[i] = rules(left, me, right);
    }
    cells = nextgen;
    // Increment the generation counter.
    generation++;
  }

  int rules(int a, int b, int c) {
    String s = "" + a + b + c;
    int index = Integer.parseInt(s,2);
    return ruleset[index];
  }

  for (int i = 0; i &lt; cells.length; i++) {
    if (cells[i] == 1) fill(0);
    else               fill(255);
    // Set the y location according to the generation.
    rect(i*w, generation*w, w, w);
  }
}</programlisting>
<example id="chapter07_exercise1">
<title>Exercise 7.1</title>
<simpara>Exercise: Expand Example 7.1 to have the following feature: when the CA reaches the bottom of the Processing window, the CA starts over with a new, random ruleset.</simpara>
</example>
<example id="chapter07_exercise2">
<title>Exercise 7.2</title>
<simpara>Exercise: Examine what patterns occur if you initialize the first generation with each cell having a random state.</simpara>
</example>
<example id="chapter07_exercise3">
<title>Exercise 7.3</title>
<simpara>Exercise: Visualize the CA in a non-traditional way.  Break all the rules you can; don’t feel tied to using squares on a perfect grid with black and white colors.</simpara>
</example>
<example id="chapter07_exercise4">
<title>Exercise 7.4</title>
<simpara>Exercise: Create a visualization of the CA that scrolls upwards as the generations increase so that you can view the generations to “infinity.”  Hint: instead of keeping track of only one generation at a time, you’ll need to store a history of generations, always adding a new one and deleting the oldest one in each frame.</simpara>
</example>
</section>
<section id="chapter07_section5">
<title>7.5 Wolfram Classification</title>
<simpara>Before we move on to looking at CA in two dimensions, it’s worth taking a brief look at Wolfram’s classification for cellular automata.  As we noted earlier, the vast majority of elementary CA rulesets produce uninspiring results, while some result in wondrously complex patterns like those found in nature.  Wolfram has divided up the range of outcomes into four classes:</simpara>
<informalfigure id="chapter07_figure18">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_18.png" canvas="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_222/Ex_7_04_WolframCA_scrolling_222.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_222/CA.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.18: Rule 222</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><emphasis>Class 1: Uniformity.</emphasis></emphasis>  Class 1 CAs end up, after some number of generations, with every cell constant.   This is not terribly exciting to watch.  Rule 222 (see image to the left) is a Class 1 CA; if you run it for enough generations, every cell will eventually become and remain black.</simpara>
<informalfigure id="chapter07_figure19">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_19.png" canvas="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_190/Ex_7_04_WolframCA_scrolling_190.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_190/CA.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.19: Rule 190</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><emphasis>Class 2: Repetition.</emphasis></emphasis>  Like class 1 CAs, class 2 CAs remain stable, but the cell states are not constant.  Rather, they oscillate in some regular pattern back and forth from 0 to 1 to 0 to 1 and so on.   In rule 190 to the left, each cell follows the sequence 11101110111011101110.</simpara>
<informalfigure id="chapter07_figure20">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_20.png" canvas="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_30/Ex_7_04_WolframCA_scrolling_30.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_30/CA.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.20: Rule 30</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><emphasis>Class 3: Random.</emphasis></emphasis>  Class 3 CAs appear random and have no easily discernible pattern.   In fact, rule 30 (see left) is used as a random number generator in Wolfram’s Mathematica software.  Again, this is a moment where we can feel amazed that such a simple system with simple rules can descend into a chaotic and random pattern.</simpara>
<informalfigure id="chapter07_figure21">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_21.png" canvas="processingjs/chapter07/Ex_7_04_WolframCA_scrolling_110/Ex_7_04_WolframCA_scrolling_110.pde processingjs/chapter07/Ex_7_04_WolframCA_scrolling_110/CA.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 7.21: Rule 110</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><emphasis>Class 4: Complexity.</emphasis></emphasis>  Class 4 CAs can be thought of as a mix between Class 2 and Class 3.  One can find repetitive, oscillating patterns inside the CA, but where and when these patterns appear is unpredictable and seemingly random.  Class 4 CA exhibit the properties of complex systems that we described earlier in this chapter and in Chapter 6.  If a Class 3 CA wowed you, then Class 4 should really blow your mind.</simpara>
<example id="chapter07_exercise5">
<title>Exercise 7.5</title>
<simpara>Exercise: Create a Processing sketch that saves an image for every possible ruleset.  Can you classify them?</simpara>
</example>
</section>
<section id="chapter07_section6">
<title>7.6 The Game of Life</title>
<simpara>The next step we are going to take is to move from a one-dimensional CA to a two-dimensional one.  This will introduce some additional complexity; each cell will have a bigger neighborhood, but that will open up the door to a range of possible applications.  After all, most of what we do in computer graphics lives in two dimensions and this chapter will demonstrate how to apply CA thinking to what we draw in our Processing sketches.</simpara>
<simpara>In 1970 Martin Gardner wrote an article in <emphasis>Scientific American</emphasis> that documented mathematician John Conway’s new “Game of Life,” describing it as “recreational” mathematics and suggesting that the reader get out a chessboard and some checkers and “play.”    While the Game of Life has become something of a computational cliché (make note of the myriad projects that display the Game of Life on LEDs, screens, projection surfaces, etc.), it is still important for us to build it from scratch.  For one, it provides a good opportunity to practice our skills with two-dimensional arrays, object orientation, etc.   But perhaps more importantly, its core principles are tied directly to our core goals—simulating the natural world with code.    Though we may want to avoid simply duplicating it without a great deal of thought or care, the algorithm and its technical implementation will provide us with the inspiration and foundation to build simulations that exhibit the characteristics and behaviors of biological systems of reproduction.</simpara>
<simpara>Unlike von Neumann, who created an extraordinarily complex system of states and rules, Conway wanted to achieve a similar “lifelike” result with the simplest set of rules possible.    Martin Gardner outlined Conway’s goals as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
There should be no initial pattern for which there is a simple proof that the population can grow without limit.
</simpara>
</listitem>
<listitem>
<simpara>
There should be initial patterns that apparently do grow without limit.
</simpara>
</listitem>
<listitem>
<simpara>
There should be simple initial patterns that grow and change for a considerable period of time before coming to an end in three possible ways: fading away completely (from overcrowding or becoming too sparse), settling into a stable configuration that remains unchanged thereafter, or entering an oscillating phase in which they repeat an endless cycle of two or more periods.<?asciidoc-br?>
—Martin Gardner, <ulink url="http://www.ibiblio.org/lifepatterns/october1970.html">Scientific American 223 (October 1970)</ulink>: 120-123.
</simpara>
</listitem>
</orderedlist>
<simpara>The above might sound a bit cryptic, but it essentially describes a Wolfram Class 4 CA.  The CA should be patterned but unpredictable over time, eventually settling into a uniform or oscillating state.  In other words, though Conway didn’t use this terminology, it should have all those properties of a <emphasis>complex system</emphasis> that we keep mentioning.</simpara>
<simpara>Let’s look at how the Game of Life works.  It won’t take up too much time or space, since we’ve covered the basics of CA already.</simpara>
<informalfigure id="chapter07_figure22">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_22.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 7.22</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>First, instead of a line of cells, we now have a two-dimensional matrix of cells.   As with the elementary CA, the possible states are 0 or 1.  Only in this case, since we’re talking about “life”, 0 means dead and 1 means alive.</simpara>
<simpara>The cell’s neighborhood has also expanded.  If a neighbor is an adjacent cell, a neighborhood is now nine cells instead of three.</simpara>
<simpara>With three cells, we had a 3-bit number or eight possible configurations.  With nine cells, we have 9 bits, or 512 possible neighborhoods.  In most cases, it would be impractical to define an outcome for every single possibility.  The Game of Life gets around this problem by defining a set of rules according to general characteristics of the neighborhood.  In other words, is the neighborhood overpopulated with life?  Surrounded by death?  Or just right?  Here are the rules of life.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Death.</emphasis></emphasis>  If a cell is alive (state = 1) it will die (state becomes 0) under the following circumstances.
</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Overpopulation:</emphasis></emphasis> If the cell has four or more alive neighbors, it dies.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Loneliness:</emphasis></emphasis> If the cell has one or fewer alive neighbors, it dies.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Birth.</emphasis></emphasis>  If a cell is dead (state = 0) it will come to life (state becomes 1) if it has exactly three alive neighbors (no more, no less).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Stasis.</emphasis></emphasis> In all other cases, the cell state does not change.  To be thorough, let’s describe those scenarios.
</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Staying Alive:</emphasis></emphasis> If a cell is alive and has exactly 2 or 3 live neighbors, it stays alive.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Staying Dead:</emphasis></emphasis> If a cell is dead and has anything other than 3 live neighbors, it stays dead.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>Let’s look at a few examples.</simpara>
<informalfigure id="chapter07_figure23">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_23.png" />
  </imageobject>
  <textobject><phrase>Figure 7.23</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>With the elementary CA, we were able to look at all the generations next to each other, stacked as rows in a 2D grid.  With the Game of Life, however, the CA itself is in two dimensions.  We could try creating an elaborate 3D visualization of the results and stack all the generations in a cube-structure (and in fact, you might want to try this as an exercise).  Nevertheless, the typical way the game of life is displayed is to treat each generation as a single frame in an animation.  So instead of viewing all the generations at once, we see them one at a time, and the result resembles rapidly growing bacteria in a petri dish.</simpara>
<simpara>One of the exciting aspects about the Game of Life is that there are initial patterns that yield intriguing results.  For example, some remain static and never change.</simpara>
<informalfigure id="chapter07_figure24">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_24.png" />
  </imageobject>
  <textobject><phrase>Figure 7.24</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>There are patterns that oscillate back and forth between two states.</simpara>
<informalfigure id="chapter07_figure25">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_25.png" />
  </imageobject>
  <textobject><phrase>Figure 7.25</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
And there are also patterns that from generation to generation move about the grid.  (It’s important to note that the cells themselves aren&#8217;t actually moving, although we see the appearance of motion in the result as the cells turn on and off.)</simpara>
<informalfigure id="chapter07_figure26">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_26.png" />
  </imageobject>
  <textobject><phrase>Figure 7.26</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If you are interested in these patterns, there are several good “out of the box” Game of Life demonstrations online that allow you to configure the CA’s initial state and watch it run at varying speeds.  Two examples you might want to examine are:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://llk.media.mit.edu/projects/emergence/">Exploring Emergence</ulink> by Mitchel Resnick and Brian Silverman, Lifelong Kindergarten Group, MIT Media Laboratory
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://stevenklise.github.com/ConwaysGameOfLife">Conway&#8217;s Game of Life</ulink> by Steven Klise,  (uses Processing.js!)
</simpara>
</listitem>
</itemizedlist>
<simpara>For the example we’ll build from scratch in the next section, it will be easier to simply randomly set the states for each cell.</simpara>
</section>
<section id="chapter07_section7">
<title>7.7  Programming the Game of Life</title>
<simpara>Now we just need to extend our code from the Wolfram CA to two dimensions.   We used a one-dimensional array to store the list of cell states before, and for the Game of Life, we can use a <ulink url="http://www.processing.org/learning/2darray/">two-dimensional array</ulink>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][] board = new int[columns][rows];</programlisting>
<simpara>We’ll begin by initializing each cell of the board with a random state: 0 or 1.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int x = 0; x &lt; columns; x++) {
  for (int y = 0; y &lt; rows; y++) {
    // Initialize each cell with a 0 or 1.
    current[x][y] = int(random(2));
  }
}</programlisting>
<simpara>And to compute the next generation, just as before, we need a fresh 2D array to write to as we analyze each cell’s neighborhood and calculate a new state.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][] next = new int[columns][rows];

for (int x = 0; x &lt; columns; x++) {
  for (int y = 0; y &lt; rows; y++) {

    // We need a new state for each cell.
    next[x][y] = _______________?;

  }
}</programlisting>
<informalfigure id="chapter07_figure27">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_27.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 7.27</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>OK, before we can sort out how to actually calculate the new state, we need to know how we can reference each cell’s neighbor.  In the case of the 1D CA, this was simple: if a cell index was <emphasis role="strong"><phrase role="var">i</phrase></emphasis>, its neighbors were i-1 and i+1.  Here each cell doesn’t have a single index, but rather a column and row index: x,y.  As shown in Figure 7.27, we can see that its neighbors are: <emphasis>(x-1,y-1) (x,y-1), (x+1,y-2), (x-1,y), (x+1,y), (x-1,y+1), (x,y+1), and (x+1,y+1)</emphasis>.</simpara>
<simpara>All of the Game of Life rules operate by knowing how many neighbors are alive.  So if we create a neighbor counter variable and increment it each time we find a neighbor with a state of 1, we’ll have the total of live neighbors.</simpara>
<programlisting language="java" linenumbering="unnumbered">int neighbors = 0;

// Top row of neighbors
if (board[x-1][y-1] == 1) neighbors++;
if (board[x  ][y-1] == 1) neighbors++;
if (board[x+1][y-1] == 1) neighbors++;

// Middle row of neighbors
// (note we don’t count self)
if (board[x-1][y]   == 1) neighbors++;
if (board[x+1][y]   == 1) neighbors++;

// Bottom row of neighbors
if (board[x-1][y+1] == 1) neighbors++;
if (board[x  ][y+1] == 1) neighbors++;
if (board[x+1][y+1] == 1) neighbors++;</programlisting>
<simpara>And again, just as with the Wolfram CA, we find ourselves in a situation where the above is a useful and clear way to write the code for teaching purposes, allowing us to see every step (each time we find a neighbor with a state of one, we increase a counter).  Nevertheless, it’s a bit silly to say, “If the cell state equals one, add one to a counter” when we could just say, “Add the cell state to a counter.”   After all, if the state is only a 0 or 1, the sum of all the neighbors’ states will yield the total number of live cells.   Since the neighbors are arranged in a mini 3x3 grid, we can add them all up with another loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = -1; i &lt;= 1; i++) {
  for (int j = -1; j &lt;= 1; j++) {
    // Add up all the neighbors’ states.
    neighbors += board[x+i][y+j];
   }
}</programlisting>
<simpara>Of course, we’ve made a mistake in the code above.   In the Game of Life, the cell itself does not count as one of the neighbors.  We could use a conditional to skip adding the state when both <emphasis role="strong"><phrase role="var">i</phrase></emphasis> and <emphasis role="strong"><phrase role="var">j</phrase></emphasis> equal 0, but another option would be to just subtract the cell state once we’ve finished the loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Whoops! Subtract the cell’s state,
// which we don’t want in the total.
neighbors -= board[x][y];</programlisting>
<simpara>Finally, once we know the total number of live neighbors, we can decide what the cell’s new state should be according to the rules: birth, death, and stasis.</simpara>
<programlisting language="java" linenumbering="unnumbered">// If it is alive and has less than 2 live neighbors, it dies from loneliness.
if      ((board[x][y] == 1) &amp;&amp; (neighbors &lt;  2)) {
  next[x][y] = 0;
}

// If it is alive and has more than 3 live neighbors, it dies from overpopulation.
else if ((board[x][y] == 1) &amp;&amp; (neighbors &gt;  3)) {
  next[x][y] = 0;
}

// If it is dead and has exactly 3 live neighbors, it is born!
else if ((board[x][y] == 0) &amp;&amp; (neighbors == 3)) {
  next[x][y] = 1;
}

// In all other cases, its state remains the same.
else {
  next[x][y] = board[x][y];
}</programlisting>
<simpara>Putting this all together, we have:</simpara>
<programlisting language="java" linenumbering="unnumbered">// The next board
int[][] next = new int[columns][rows];

// Looping but skipping the edge cells
for (int x = 1; x &lt; columns-1; x++) {
  for (int y = 1; y &lt; rows-1; y++) {

    // Add up all the neighbor states to
    // calculate the number of live neighbors.
    int neighbors = 0;
    for (int i = -1; i &lt;= 1; i++) {
      for (int j = -1; j &lt;= 1; j++) {
        neighbors += board[x+i][y+j];
      }
    }

    // Correct by subtracting the cell state itself.
    neighbors -= board[x][y];

    // The rules of life!
    if      ((board[x][y] == 1) &amp;&amp; (neighbors &lt;  2)) next[x][y] = 0;
    else if ((board[x][y] == 1) &amp;&amp; (neighbors &gt;  3)) next[x][y] = 0;
    else if ((board[x][y] == 0) &amp;&amp; (neighbors == 3)) next[x][y] = 1;
    else next[x][y] = board[x][y];
  }
}

// The 2D array “next” is now the current board
board = next;</programlisting>
<simpara>Finally, once the next generation is calculated, we can employ the same method we used to draw the Wolfram CA—a square for each spot, white for off, black for on.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_ex02.png" canvas="processingjs/chapter07/_7_02_GameOfLifeSimple/_7_02_GameOfLifeSimple.pde processingjs/chapter07/_7_02_GameOfLifeSimple/GOL.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter07/ch07_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter07_example2"><emphasis role="strong"><phrase role="example">Example 7.2: Game of Life</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">for ( int i = 0; i &lt; columns;i++) {
  for ( int j = 0; j &lt; rows;j++) {

    // Black when state = 1
    // White when state = 0
    if ((board[i][j] == 1)) fill(0);
    else fill(255);
    stroke(0);

    rect(i*w, j*w, w, w);
  }
}</programlisting>
<example id="chapter07_exercise6">
<title>Exercise 7.6</title>
<simpara>Exercise: Create a Game of Life simulation that allows you to manually configure the grid by drawing or with specific known patterns.</simpara>
</example>
<example id="chapter07_exercise7">
<title>Exercise 7.7</title>
<simpara>Exercise: Implement “wrap-around” for the Game of Life so that cells on the edges have neighbors on the opposite side of the grid.</simpara>
</example>
<example id="chapter07_exercise8">
<title>Exercise 7.8</title>
<simpara>Exercise: While the above solution is convenient, it is not particularly memory-efficient.  It creates a new 2D array for every frame of animation!  This matters very little for a Processing desktop application, but if you were implementing the Game of Life on a microcontroller or mobile device, you’ll want to be more careful.    One solution is to have only two arrays and constantly swap them, writing the next set of states into whichever one isn’t the current array.  Implement this particular solution.</simpara>
</example>
</section>
<section id="chapter07_section8">
<title>7.8 Object-Oriented Cells</title>
<simpara>Over the course of the previous six chapters, we’ve slowly built examples of systems of <emphasis>objects</emphasis> with properties moving about the screen.  And in this chapter, although we’ve been talking about a “cell” as if it were an object, we actually haven’t been using any object orientation in our code (other than a class to describe the CA system as a whole).   This has worked because a cell is such an enormously simple object (a single bit).  However, in a moment, we are going to discuss some ideas for further developing CA systems, many of which involve keeping track of multiple properties for each cell.  For example, what if a cell needed to remember its last ten states?  Or what if we wanted to apply some of our motion and physics thinking to a CA and have the cells move about the window, dynamically changing their neighbors from frame to frame?</simpara>
<simpara>To accomplish any of these ideas (and more), it would be helpful to see how we might treat a cell as an object with multiple properties, rather than as a single 0 or 1.  To show this, let’s just recreate the Game of Life simulation. Only instead of:</simpara>
<programlisting language="java" linenumbering="unnumbered">  int[][] board;</programlisting>
<simpara>Let’s have:</simpara>
<programlisting language="java" linenumbering="unnumbered">  Cell[][] board;</programlisting>
<simpara>where Cell is a class we will write.   What are the properties of a Cell object?   In our Game of Life example, each cell has a location and size, as well as a state.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Cell {

  // Location and size
  float x, y;
  float w;

  // What is the cell’s state?
  int state;</programlisting>
<simpara>In the non-OOP version, we used a separate 2D array to keep track of the states for the current and next generation.   By making a cell an object, however, each cell could keep track of both states.   In this case, we’ll think of the cell as remembering its previous state (for when new states need to be computed).</simpara>
<programlisting language="java" linenumbering="unnumbered">  // What was its previous state?
  int previous;</programlisting>
<simpara>This allows us to visualize more information about what the state is doing.  For example, we could choose to color a cell differently if its state has changed.  For example:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_ex02.png" canvas="processingjs/chapter07/_7_03_GameOfLifeOOP/_7_03_GameOfLifeOOP.pde processingjs/chapter07/_7_03_GameOfLifeOOP/GOL.pde processingjs/chapter07/_7_03_GameOfLifeOOP/Cell.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter07/ch07_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter07_example3"><emphasis role="strong"><phrase role="example">Example 7.3: Game of Life OOP</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void display() {
  // If the cell is born, color it blue!
  if (previous == 0 &amp;&amp; state == 1) fill(0,0,255);
  else if (state == 1) fill(0);

  // If the cell dies, color it red!
  else if (previous == 1 &amp;&amp; state == 0) fill(255,0,0);
  else fill(255);

  rect(x, y, w, w);
}</programlisting>
<simpara>Not much else about the code (at least for our purposes here) has to change.  The neighbors can still be counted the same way; the difference is that we now need to refer to the object’s state variables as we loop through the 2D array.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int x = 1; x &lt; columns-1; x++) {
  for (int y = 1; y &lt; rows-1; y++) {

    int neighbors = 0;
    for (int i = -1; i &lt;= 1; i++) {
      for (int j = -1; j &lt;= 1; j++) {
        // Use the previous state when tracking neighbors.
        neighbors += board[x+i][y+j].previous; // [bold]
      }
    }
    neighbors -= board[x][y].previous;

    // We are calling a function newState()
    // to assign a new state to each cell.
    if      ((board[x][y].state == 1) &amp;&amp; (neighbors &lt;  2)) board[x][y].newState(0);
    else if ((board[x][y].state == 1) &amp;&amp; (neighbors &gt;  3)) board[x][y].newState(0);
    else if ((board[x][y].state == 0) &amp;&amp; (neighbors == 3)) board[x][y].newState(1);
    // else do nothing!
  }
}</programlisting>
</section>
<section id="chapter07_section9">
<title>7.9 Variations of Traditional CA</title>
<simpara>Now that we have covered the basic concepts, algorithms, and programming strategies behind the most famous 1D and 2D cellular automata, it’s time to think about how you might take this foundation of code and build on it, developing creative applications of CAs in your own work.  In this section, we’ll talk through some ideas for expanding the features of the CA examples.  Example answers to each of these exercises can be found on the book web site.</simpara>
<simpara><emphasis role="strong"><emphasis>1) Non-rectangular Grids</emphasis></emphasis>  There’s no particular reason why you should limit yourself to having your cells on a rectangular grid.  What happens if you design a CA with another type of shape?</simpara>
<example id="chapter07_exercise9">
<title>Exercise 7.9</title>
<simpara>Create a CA using a grid of hexagons (as below), each with six neighbors.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter07/ch07_exc09.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter07/ch07_exc09.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<simpara><emphasis role="strong"><emphasis>2) Probabilistic</emphasis></emphasis>  The rules of a CA don’t necessarily have to define an exact outcome.</simpara>
<example id="chapter07_exercise10">
<title>Exercise 7.10</title>
<simpara>Rewrite the Game of Life rules as follows:</simpara>
<simpara>Overpopulation: If the cell has four or more alive neighbors, it has a 80% chance of dying.
Loneliness: If the cell has one or fewer alive neighbors, it has a 60% chance of dying.
Etc.</simpara>
</example>
<simpara><emphasis role="strong"><emphasis>3) Continuous</emphasis></emphasis>  We’ve looked at examples where the cell’s state can only be a 1 or a 0.  But what if the cell’s state was a floating point number between 0 and 1?</simpara>
<example id="chapter07_exercise11">
<title>Exercise 7.11</title>
<simpara>Exercise: Adapt Wolfram elementary CA to have the state be a float.  You could define rules such as, “If the state is greater than 0.5” or “&#8230;less than 0.2”, etc.</simpara>
</example>
<simpara><emphasis role="strong"><emphasis>4) Image Processing</emphasis></emphasis>  We briefly touched on this earlier, but many image-processing algorithms operate on CA-like rules.  Blurring an image is creating a new pixel out of the average of a neighborhood of pixels.   Simulations of ink dispersing on paper or water rippling over an image can be achieved with CA rules.</simpara>
<example id="chapter07_exercise12">
<title>Exercise 7.12</title>
<simpara>Create a CA where a pixel is a cell and a color is its state.</simpara>
</example>
<simpara><emphasis role="strong"><emphasis>5) Historical</emphasis></emphasis>  In the Game of Life object-oriented example, we used two variables to keep track of its state: current and previous.  What if you use an array to keep track of a cell’s state history?   This relates to the idea of a “Complex Adaptive System,” one that has the ability to adapt and change its rules over time by learning from its history.  We’ll see an example of this in Chapter 10: Neural Networks.</simpara>
<example id="chapter07_exercise13">
<title>Exercise 7.13</title>
<simpara>Visualize the Game of Life by coloring each cell according to how long it’s been alive or dead.  Can you also use the cell’s history to inform the rules?</simpara>
</example>
<simpara><emphasis role="strong"><emphasis>6) Moving cells</emphasis></emphasis>  In these basic examples, cells have a fixed position on a grid, but you could build a CA with cells that have no fixed position and instead move about the screen.</simpara>
<example id="chapter07_exercise14">
<title>Exercise 7.14</title>
<simpara>Use CA rules in a flocking system.  What if each boid had a state (that perhaps informs its steering behaviors) and its neighborhood changed from frame to frame as it moved closer to or further from other boids?A lot of exercise text &#8230;.</simpara>
</example>
<simpara><emphasis role="strong"><emphasis>7) Nesting</emphasis></emphasis>  Another feature of complex systems is that they can be nested.   Our world tends to work this way: a city is a complex system of people, a person is a complex system of organs, an organ is a complex system of cells, and so on and so forth.</simpara>
<example id="chapter07_exercise15">
<title>Exercise 7.15</title>
<simpara>Design a CA in which each cell itself is a smaller CA or a system of boids.</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 7 Exercise:</simpara>
<simpara>Incorporate cellular automata into your ecosystem.  Some possibilities:</simpara>
<itemizedlist>
<listitem>
<simpara>
Give each creature a state.  How can that state drive their behavior?  Taking inspiration from CA, how can that state change over time according to its neighbors’ states?
</simpara>
</listitem>
<listitem>
<simpara>
Consider the ecosystem’s world to be a CA.  The creatures move from tile to tile.  Each tile has a state—is it land? water?  food?
</simpara>
</listitem>
<listitem>
<simpara>
Use a CA to generate a pattern for the design of a creature in your ecosystem.
</simpara>
</listitem>
</itemizedlist>
</tip>
</section>
</chapter>
<chapter id="_chapter_8_fractals">
<title>Chapter 8.  Fractals</title>
<blockquote>
<attribution>
Jonathan Coulton
<citetitle>lyrics from “Mandelbrot Set”</citetitle>
</attribution>
<simpara>“Pathological monsters! cried the terrified mathematician<?asciidoc-br?>
Every one of them a splinter in my eye<?asciidoc-br?>
I hate the Peano Space and the Koch Curve<?asciidoc-br?>
I fear the Cantor Ternary Set<?asciidoc-br?>
The Sierpinski Gasket makes me wanna cry<?asciidoc-br?>
And a million miles away a butterfly flapped its wings<?asciidoc-br?>
On a cold November day a man named Benoit Mandelbrot was born”</simpara>
</blockquote>
<simpara>Once upon a time, I took a course in high school called “Geometry.”  Perhaps you did too.   You learned about shapes in one dimension, two dimensions, and maybe even three.  What is the circumference of a circle?  The area of a rectangle?   The distance between a point and a line?   Come to think of it, we’ve been studying geometry all along in this book, using vectors to describe the motion of bodies in Cartesian space.  This sort of geometry is generally referred to as Euclidean Geometry, after the Greek mathematician Euclid.</simpara>
<informalfigure id="chapter08_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_01.png" />
  </imageobject>
  <textobject><phrase>Figure 8.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For us nature coders, we have to ask the question: Can we describe our world with Euclidean geometry?    The LCD screen I’m staring at right now sure looks like a rectangle.  And the plum I ate this morning is circular.  But what if I were to look further, and consider the trees that line the street, the leaves that hang off those trees, the lightning from last night’s thunderstorm, the cauliflower I ate for dinner, the blood vessels in my body, and the mountains and coastlines that cover land beyond New York City?   Most of the stuff you find in nature cannot be described by the idealized geometrical forms of Euclidean geometry.  So if we want to start building computational designs with patterns beyond the simple shapes <emphasis role="strong"><phrase role="function">ellipse()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">rect()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">line()</phrase></emphasis>, it’s time for us to learn about the concepts behind and techniques for simulating the geometry of nature: fractals.</simpara>
<section id="chapter08_section1">
<title>8.1  What Is a Fractal?</title>
<informalfigure id="chapter08_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_02.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 8.2 One of the most well-known and recognizable fractal patterns is named for Benoit Mandelbrot himself.   Generating the Mandelbrot set involves testing the properties of complex numbers after they are passed through an iterative function.  Do they tend to infinity?  Do they stay bounded?  While a fascinating mathematical discussion, this “escape-time” algorithm is a less practical method for generating fractals than the recursive techniques we’ll examine in this chapter.  However, an example for generating the Mandelbrot set is included in the code examples.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The term <emphasis>fractal</emphasis> (from the Latin <emphasis>fractus</emphasis>, meaning “broken”) was coined by the mathematician Benoit Mandelbrot in 1975.  In his seminal work “The Fractal Geometry of Nature,” he defines a fractal as “a rough or fragmented geometric shape that can be split into parts, each of which is (at least approximately) a reduced-size copy of the whole.”  Let’s illustrate this definition with two simple examples.  First, let’s think about a tree branching structure (for which we’ll write the code later):</simpara>
<informalfigure id="chapter08_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_03.png" />
  </imageobject>
  <textobject><phrase>Figure 8.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice how the tree in Figure 8.3 has a single root with two branches connected at its end.  Each one of those branches has two branches at its end and those branches have two branches and so on and so forth.  What if we were to pluck one branch from the tree and examine it on its own?</simpara>
<informalfigure id="chapter08_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_04.png" />
  </imageobject>
  <textobject><phrase>Figure 8.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Looking closely at a given section of the tree, we find that the shape of this branch resembles the tree itself.   This is known as “self-similarity”; as Mandelbrot stated, each part is a “reduced-size copy of the whole.”</simpara>
<simpara>The above tree is perfectly symmetrical and the parts are, in fact, exact replicas of the whole.  However, fractals do not have to be perfectly self-similar.  Let’s take a look at a graph of the stock market (adapted from actual Apple stock data).</simpara>
<informalfigure id="chapter08_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_05.png" />
  </imageobject>
  <textobject><phrase>Figure 8.5: Graph A</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">[Need illustration]</phrase></emphasis></simpara>
<simpara>And one more.</simpara>
<informalfigure id="chapter08_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_06.png" />
  </imageobject>
  <textobject><phrase>Figure 8.6: Graph B</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">[Need illustration]</phrase></emphasis></simpara>
<simpara>In these graphs, the x-axis is time and the y-axis is the stock’s value.   It’s not an accident that I omitted the labels, however.   Graphs of stock market data are examples of fractals because they look the same at any scale.  Are these graphs of the stock over one year?  One day?  One hour?  There’s no way for you to know without a label.  (Incidentally, graph A shows six months’ worth of data and graph B zooms into a tiny part of graph A, showing six hours.)</simpara>
<informalfigure id="chapter08_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_07.png" />
  </imageobject>
  <textobject><phrase>Figure 8.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is an example of a stochastic fractal, meaning that it is built out of probabilities and randomness.  Unlike the deterministic tree-branching structure, it is statistically self-similar.  As we go through the examples in this chapter, we will look at both deterministic and stochastic techniques for generating fractal patterns.</simpara>
<simpara>While self-similarity is a key trait of fractals, it’s important to realize that self-similarity alone does not make a fractal.  After all, a line is self-similar.  A line looks the same at any scale, and can be thought of as comprising lots of little lines.  But it’s not a fractal.  Fractals are  characterized by having a fine structure at small scales (keep zooming into the stock market graph and you’ll continue to find fluctuations) and cannot be described with Euclidean geometry.  If you can say “It’s a line!” then it’s not a fractal.</simpara>
<simpara>Another fundamental component of fractal geometry is recursion.  Fractals all have a recursive definition.  Recursion is where we’ll begin as we develop techniques and code examples for building fractal patterns in Processing.</simpara>
</section>
<section id="chapter08_section2">
<title>8.2 Recursion</title>
<simpara>Let’s begin our discussion of recursion by examining the first appearance of fractals in modern mathematics.  In 1883, German mathematician George Cantor developed simple rules to generate an infinite set:</simpara>
<informalfigure id="chapter08_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_08.png" />
  </imageobject>
  <textobject><phrase>Figure 8.8: The Cantor Set</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>There is a feedback loop at work here.  Take a single line and break it into two.  Then return to those two lines and apply the same rule, breaking each line into two, and now we’re left with four.  Then return to those four lines and apply the rule.  Now you’ve got eight.   This process is known as recursion: the repeated application of a rule to successive results.   Cantor was interested in what happens when you apply these rules an infinite number of times.   We, however, are working in a finite pixel space and can mostly ignore the questions and paradoxes that arise from infinite recursion.  We will instead construct our code in such a way that we do not apply the rules forever (which would cause our program to freeze).</simpara>
<simpara>Before we implement the Cantor set, let’s take a look at what it means to have recursion in code.
Here’s something we’re used to doing all the time—calling a function inside another function.</simpara>
<programlisting language="java" linenumbering="unnumbered">void someFunction() {
  // Calling the function background()
  // in the definition of someFunction()
  background(0);
}</programlisting>
<simpara>What would happen if we called the function we are defining within the function itself?   Can <emphasis role="strong"><phrase role="function">someFunction()</phrase></emphasis> call <emphasis role="strong"><phrase role="function">someFunction()</phrase></emphasis>?</simpara>
<programlisting language="java" linenumbering="unnumbered">void someFunction() {
  someFunction();
}</programlisting>
<simpara>In fact, this is not only allowed, but it’s quite common (and essential to how we will implement the Cantor set).   Functions that call themselves are <emphasis>recursive</emphasis> and good for solving certain problems.  For example, certain mathematical calculations are implemented recursively; the most common example is <emphasis>factorial</emphasis>.</simpara>
<simpara>The factorial of any number n, usually written as n!, is defined as:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">n! = n * n – 1 * . . . . * 3 * 2 * 1</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">0! = 1</phrase></emphasis></simpara>
<simpara>We could write a function to calculate factorial using a <emphasis role="strong"><emphasis>for</emphasis></emphasis> loop in <emphasis>Processing</emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">int factorial(int n) {
  int f = 1;
  // Using a regular loop to compute factorial
  for (int i = 0; i &lt; n; i++) {
    f = f * (i+1);
  }
  return f;
}</programlisting>
<simpara>If you look closely at how factorial works, however, you’ll notice something interesting. Let’s examine 4! and 3!</simpara>
<simpara><emphasis role="strong"><phrase role="formula">4! = 4 * 3 * 2 * 1</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">3! = 3 * 2 * 1</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>therefore. . .</emphasis></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="formula">4! = 4 * 3!</phrase></emphasis></simpara>
<simpara>We can describe this in more general terms.  For any positive integer n:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">n! = n * (n-1)!</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">1! = 1</phrase></emphasis></simpara>
<simpara>Written in English:</simpara>
<simpara>The <emphasis role="strong"><emphasis>factorial</emphasis></emphasis> of <emphasis role="strong"><phrase role="var">n</phrase></emphasis> is defined as <emphasis role="strong"><phrase role="var">n</phrase></emphasis> times the <emphasis role="strong"><emphasis>factorial</emphasis></emphasis> of <emphasis role="strong"><phrase role="var">n-1</phrase></emphasis>.</simpara>
<simpara>The definition of <emphasis role="strong"><emphasis>factorial</emphasis></emphasis> includes <emphasis role="strong"><emphasis>factorial</emphasis></emphasis>?!  It’s kind of like saying that “tired is defined as “the feeling you get when you are tired.”   This concept of self-reference in functions is an example of recursion.   And we can use it to write a factorial function that calls itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">int factorial(int n) {
  if (n == 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}</programlisting>
<simpara>Crazy, I know.  But it works.   Here are the steps that happen when <emphasis role="strong"><phrase role="function">factorial(4)</phrase></emphasis> is called.</simpara>
<informalfigure id="chapter08_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_09.png" />
  </imageobject>
  <textobject><phrase>Figure 8.9</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">[Need a real figure, improve? Use a stack??]</phrase></emphasis></simpara>
<simpara>The same principle, as we will see in many examples throughout this chapter, can be applied to graphics with interesting results. Take a look at the following recursive function.￼</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex01.png" canvas="processingjs/chapter08/_8_01_Recursion/_8_01_Recursion.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example1"><emphasis role="strong"><phrase role="example">Example 8.1: Recursive Circles I</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void drawCircle(int x, int y, float radius) {
  ellipse(x, y, radius, radius);
  if(radius &gt; 2) {
    radius *= 0.75f;
    // The drawCircle() function is
    // calling itself recursively.
    drawCircle(x, y, radius);
  }
}</programlisting>
<simpara>What does <emphasis role="strong"><phrase role="function">drawCircle()</phrase></emphasis> do? It draws an ellipse based on a set of parameters received as arguments, and then it calls itself with the same parameters (adjusting them slightly). The result is a series of circles each drawn inside the previous circle.</simpara>
<simpara>Notice that the above function only recursively calls itself if the radius is greater than 2.  This is a crucial point.  As with iteration, <emphasis role="strong"><emphasis>all recursive functions must have an exit condition!</emphasis></emphasis>    You likely are already aware that all <emphasis role="strong"><emphasis>for</emphasis></emphasis> and <emphasis role="strong"><emphasis>while</emphasis></emphasis> loops must include a boolean test that eventually evaluates to false, thus exiting the loop. Without one, the program would crash, caught inside of an infinite loop. The same can be said about recursion.  If a recursive function calls itself forever and ever, you’ll be most likely be treated to a nice frozen screen.</simpara>
<simpara>The above circles example is rather trivial; it could easily be achieved through simple iteration. However, in more complex scenarios where a function calls itself more than once, recursion becomes wonderfully elegant.</simpara>
<simpara>Let’s revise <emphasis role="strong"><phrase role="function">drawCircle()</phrase></emphasis> to be a bit more complex.    For every circle displayed, draw a circle half its size to the left and right of that circle.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex02.png" canvas="processingjs/chapter08/_8_02_Recursion/_8_02_Recursion.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example2"><emphasis role="strong"><phrase role="example">Example 8.2: Recursion twice</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(400,400);
  smooth();
}

void draw() {
  background(255);
  drawCircle(width/2,height/2,200);
}

void drawCircle(float x, float y, float radius) {
  stroke(0);
  noFill();
  ellipse(x, y, radius, radius);
  if(radius &gt; 2) {
    // drawCircle() calls itself twice, creating
    // a branching effect.  For every circle,
    // a smaller circle is drawn to the left and right.
    drawCircle(x + radius/2, y, radius/2);
    drawCircle(x - radius/2, y, radius/2);
  }
}</programlisting>
<simpara>With a teeny bit more code, we could add a circle above and below.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex03.png" canvas="processingjs/chapter08/_8_03_Recursion/_8_03_Recursion.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example3"><emphasis role="strong"><phrase role="example">Example 8.3: Recursion four times</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void drawCircle(float x, float y, float radius) {
  ellipse(x, y, radius, radius);
  if(radius &gt; 8) {
    drawCircle(x + radius/2, y, radius/2);
    drawCircle(x - radius/2, y, radius/2);
    drawCircle(x, y + radius/2, radius/2);
    drawCircle(x, y - radius/2, radius/2);
  }
}</programlisting>
<simpara>Just try recreating this sketch with iteration instead of recursion—I dare you!</simpara>
</section>
<section id="chapter08_section3">
<title>8.3  The Cantor Set with a Recursive Function</title>
<simpara>Now we’re ready to visualize the Cantor set in Processing using a recursive function.  Where do we begin?  Well, we know that the Cantor set begins with a line.  So let’s start there and write a function that draws a line.</simpara>
<programlisting language="java" linenumbering="unnumbered">void cantor(float x, float y, float len) {
  line(x,y,x+len,y);
}</programlisting>
<simpara>The above <emphasis role="strong"><phrase role="function">cantor()</phrase></emphasis> function draws a line that starts at pixel coordinate (x,y) with a length of len.  (The line is drawn horizontally, but this is an arbitrary decision.)  So if we called that function, saying:</simpara>
<programlisting language="java" linenumbering="unnumbered">cantor(10, 20, width-20);</programlisting>
<simpara>we’d get the following:</simpara>
<informalfigure id="chapter08_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_10.png" />
  </imageobject>
  <textobject><phrase>Figure 8.10</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter08_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_11.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 8.11</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now, the Cantor rule tells us to erase the middle third of that line, which leaves us with two lines, one from the beginning of the line to the one-third mark, and one from the two-thirds mark to the end of the line.</simpara>
<simpara>We can now add two more lines of code to draw the second pair of lines, moving the y location down a bunch of pixels so that we can see the result below the original line.</simpara>
<programlisting language="java" linenumbering="unnumbered">void cantor(float x, float y, float len) {
  line(x,y,x+len,y);

  y += 20;
  // From start to 1/3rd
  line(x,y,x+len/3,y); // [bold]
  // From 2/3rd to end
  line(x+len*2/3,y,x+len,y); // [bold]
}</programlisting>
<informalfigure id="chapter08_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_12.png" />
  </imageobject>
  <textobject><phrase>Figure 8.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>While this is a fine start, such a manual approach of calling <emphasis role="strong"><phrase role="function">line()</phrase></emphasis> for each line is not what we want.   It will get unwieldy very quickly, as we’d need four, then eight, then sixteen calls to <emphasis role="strong"><phrase role="function">line()</phrase></emphasis>.  Yes, a <emphasis role="strong"><emphasis>for</emphasis></emphasis> loop is our usual way around such a problem, but give that a try and you’ll see that working out the math for each iteration quickly proves inordinately complicated.   Here is where recursion comes and rescues us.</simpara>
<simpara>Take a look at where we draw that first line from start to the one-third mark.</simpara>
<programlisting language="java" linenumbering="unnumbered">   line(x,y,x+len/3,y);</programlisting>
<simpara>Instead of calling the <emphasis role="strong"><phrase role="function">line()</phrase></emphasis> function directly, we can simply call the <emphasis role="strong"><phrase role="function">cantor()</phrase></emphasis> function itself.  After all, what does the <emphasis role="strong"><phrase role="function">cantor()</phrase></emphasis> function do?  It draws a line at an (x,y) location with a given length!  And so:</simpara>
<programlisting language="java" linenumbering="unnumbered">   line(x,y,x+len/3,y);         becomes -------&gt;  cantor(x,y,len/3);</programlisting>
<simpara>And for the second line:</simpara>
<programlisting language="java" linenumbering="unnumbered">   line(x+len*2/3,y,x+len,y);   becomes -------&gt;  cantor(x+len*2/3,y,len/3);</programlisting>
<simpara>Leaving us with:</simpara>
<programlisting language="java" linenumbering="unnumbered">void cantor(float x, float y, float len) {
  line(x,y,x+len,y);

  y += 20;

  cantor(x,y,len/3);
  cantor(x+len*2/3,y,len/3);
}</programlisting>
<simpara>And since the <emphasis role="strong"><phrase role="function">cantor()</phrase></emphasis> function is called recursively, the same rule will be applied to the next lines and to the next and to the next as <emphasis role="strong"><phrase role="function">cantor()</phrase></emphasis> calls itself again and again!  Now, don’t go and run this code yet.  We’re missing that crucial element: an exit condition.   We’ll want to make sure we stop at some point—for example, if the length of the line ever is less than one pixel.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex04.png" canvas="processingjs/chapter08/_8_04_CantorSet/_8_04_CantorSet.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example4"><emphasis role="strong"><phrase role="example">Example 8.4: Cantor Set</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void cantor(float x, float y, float len) {
  // Stop at 1 pixel!
  if (len &gt;= 1) {
    line(x,y,x+len,y);
    y += 20;
    cantor(x,y,len/3);
    cantor(x+len*2/3,y,len/3);
  }
}</programlisting>
<example>
<title>Exercise 8.1</title>
<simpara>Exercise:  Using drawCircle() and the Cantor Set as models, generate your own pattern with recursion.  Here is a screenshot of one that uses lines.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_exc01.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_exc01.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter08_section4">
<title>8.4  The Koch Curve and the ArrayList Technique</title>
<simpara>Writing a function that recursively calls itself is one technique for generating a fractal pattern on screen.  However, what if you wanted the lines in the above Cantor set to exist as individual objects that could be moved independently?   The recursive function is simple and elegant, but it does not allow you to do much besides simply generating the pattern itself.  However, there is another way we can apply recursion in combination with an <emphasis>ArrayList</emphasis> that will allow us to not only generate a fractal pattern, but keep track of all its individual parts as objects.</simpara>
<simpara>To demonstrate this technique, let’s look at another famous fractal pattern, discovered in 1904 by Swedish mathematician Helge von Koch.   Here are the rules.  (Note it starts the same way as the Cantor set, with a single line.)</simpara>
<informalfigure id="chapter08_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_13.png" />
  </imageobject>
  <textobject><phrase>Figure 8.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The result looks like:</simpara>
<informalfigure id="chapter08_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_14.png" />
  </imageobject>
  <textobject><phrase>Figure 8.14</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<title>The “Monster” Curve</title>
<simpara>The Koch curve and other fractal patterns are often called“mathematical monsters.”   This is due to an odd paradox that emerges when you apply the recursive definition an infinite number of times.  If the length of the original starting line is 1, the first iteration of the Koch curve will yield a line of length four thirdsrds (each segment is one third the length of the starting line).  Do it again and you get a length of sixteen ninths.  As you iterate towards infinity, the length of the Koch curve approaches infinity.  Yet it fits in the tiny finite space provided right here on this paper (or screen)!</simpara>
<simpara>Since we are working in the Processing land of finite pixels, this theoretical paradox won’t be a factor for us.  We’ll have to limit the number of times we recursively apply the Koch rules so that our program won’t run out of memory or crash.</simpara>
</note>
<simpara>We could proceed in the same manner as we did with the Cantor set, and write a recursive function that iteratively applies the Koch rules over and over.   Nevertheless, we are going to tackle this problem in a different manner by treating each segment of the Koch curve as an individual object.  This will open up some design possibilities.  For example, if each segment is an object, we could allow each segment to move independently from its original location and participate in a physics simulation.  In addition, we could use a random color, line thickness, etc. to display each segment differently.</simpara>
<simpara>In order to accomplish our goal of treating each segment as an individual object, we must first decide what this object should be in the first place.  What data should it store?  What functions should it have?</simpara>
<simpara>The Koch curve is a series of connected lines, and so we will think of each segment as a “KochLine.”  The KochLine will have a start point (“a”) and an end point (“b”).  These points will be PVector objects, and the KochLine can be drawn with Processing’s <emphasis role="strong"><phrase role="function">line()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">class KochLine {

  // A line between two points: start and end
  PVector start;
  PVector end;

  KochLine(PVector a, PVector b) {
    start = a.get();
    end = b.get();
  }

  void display() {
    stroke(0);
    // Draw the line from PVector start to end.
    line(start.x, start.y, end.x, end.y);
  }
}</programlisting>
<simpara>Now that we have our KochLine class, we can get started on the main program.  We’ll need a data structure to keep track of what will eventually become many KochLine objects, and an ArrayList (see Chapter 4 for a review of ArrayLists) will do just fine.</simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;KochLine&gt; lines;</programlisting>
<simpara>In <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>, we’ll want to create the ArrayList and add the first line segment to it, a line that stretches from zero to the width of the sketch.</simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(600, 300);
  // Create the ArrayList
  lines = new ArrayList&lt;KochLine&gt;();

  // Left side of window
  PVector start = new PVector(0, 200);
  // Right side of window
  PVector end   = new PVector(width, 200);

  // The first KochLine object
  lines.add(new KochLine(start, end));
}</programlisting>
<simpara>Then in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, all KochLine objects (just one right now) can be displayed in a loop.
￼</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);
  for (KochLine l : lines) {
    l.display();
  }
}</programlisting>
<simpara>This is our foundation.  Let’s review what we have so far:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>KochLine class:</emphasis></emphasis> A class to keep track of a line from point A to B.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>ArrayList:</emphasis></emphasis> A list of all KochLine objects.
</simpara>
</listitem>
</itemizedlist>
<simpara>With the above elements, how and where do we apply Koch rules and principles of recursion?</simpara>
<simpara>Remember the Game of Life cellular automata?  In that simulation, we always kept track of two generations: current and next.  When we were finished computing the next generation, next became current and we moved on to computing the new next generation.
 We are going to apply a similar technique here.  We have an ArrayList that keeps track of the current set of KochLine objects (at the start of the program, there is only one).  We will need a second ArrayList (let’s call it “next”) where we will place all the new KochLine objects that are generated from applying the Koch rules.   For every KochLine in the current ArrayList, four new KochLine objects are added to the next ArrayList.  When we’re done, the next ArrayList becomes the current one.</simpara>
<informalfigure id="chapter08_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_15.png" />
  </imageobject>
  <textobject><phrase>Figure 8.15</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here’s how the code will look:</simpara>
<programlisting language="java" linenumbering="unnumbered">void generate() {
  // Create the next ArrayList...
  ArrayList next = new ArrayList&lt;KochLine&gt;();

  // ...for every current line.
  for (KochLine l : lines) {

    // Add four new lines (we need to figure out how
    // to compute the locations of these lines!)
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
  }
  // The new ArrayList is now the
  // one we care about!
  lines = next;
}</programlisting>
<simpara>By calling <emphasis role="strong"><phrase role="function">generate()</phrase></emphasis> over and over again (for example, each time the mouse is pressed) we recursively apply the Koch curve rules to the existing set of KochLine objects.
 Of course, the above omits the real “work” here, which is figuring out those rules.  How do we break one line segment into four as described by the rules?   While this can be accomplished with some simple arithmetic and trigonometry, since our KochLine object uses PVector, this is a nice opportunity for us to practice our vector math.  Let’s establish how many points we need to compute for each KochLine object.</simpara>
<informalfigure id="chapter08_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_16.png" />
  </imageobject>
  <textobject><phrase>Figure 8.16</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
As you can see from the above figure, we need five points  (A, B, C, D, and E) to generate the new KochLine objects and make the new line segments (AB, BC, CD, and DE).</simpara>
<programlisting language="java" linenumbering="unnumbered">    next.add(new KochLine(a,b));
    next.add(new KochLine(b,c));
    next.add(new KochLine(c,d));
    next.add(new KochLine(d,e));</programlisting>
<simpara>Where do we get these points?  Since we have a KochLine object, why not ask the KochLine object to compute all these points for us?</simpara>
<programlisting language="java" linenumbering="unnumbered">void generate() {
  ArrayList next = new ArrayList&lt;KochLine&gt;();
  for (KochLine l : lines) {

    // The KochLine object has five functions,
    // each of which return a PVector according
    // to the Koch rules
    PVector a = l.kochA();
    PVector b = l.kochB();
    PVector c = l.kochC();
    PVector d = l.kochD();
    PVector e = l.kochE();

    next.add(new KochLine(a, b));
    next.add(new KochLine(b, c));
    next.add(new KochLine(c, d));
    next.add(new KochLine(d, e));
  }

  lines = next;
}</programlisting>
<simpara>Now we just need to write five new functions in the KochLine class, each one returning a PVector according to <link linkend="chapter08_figure16">Figure 8.16</link> above.  Let’s knock off <emphasis role="strong"><phrase role="function">kochA()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">kochE()</phrase></emphasis> first, which are simply the start and end points of the original KochLine.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector kochA() {
    // Note the use of get(), which returns a copy of the PVector. As was noted in
    [notetoself]*not sure of chapter or reference this is referring to:*
    // Chapter X, pg X [REF] we want to avoid making copies whenever
    // possible, but here we will need a new PVector in case we want the segments to move
    // independently of each other.
    return start.get();
  }

  PVector kochE() {
    return end.get();
  }</programlisting>
<simpara>Now let’s move on to points B and D.  B is one-third of the way along the line segment and D is two-thirds.  Here we can make a PVector that points from start to end and shrink it to one-third the length for B and two-thirds the length for D to find these points.</simpara>
<informalfigure id="chapter08_figure17">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_17.png" />
  </imageobject>
  <textobject><phrase>Figure 8.17</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">  PVector kochB() {
    // PVector from start to end
    PVector v = PVector.sub(end, start);
    // One-third the length
    v.div(3);
    // Add that PVector to the beginning of the line
    // to find the new point.
    v.add(start);
    return v;
  }

  PVector kochD() {
    PVector v = PVector.sub(end, start);
    // Same thing here, only we need to move two-thirds
    // along the line instead of one third.
    v.mult(2/3.0);
    v.add(start);
    return v;
  }</programlisting>
<simpara>The last point, C, is the most difficult one to find.  However, if you recall that the angles of an equilateral triangle are all sixty degrees, this makes it a little bit easier.  If we know how to find point B with a PVector one-third the length of the line, what if we were to rotate that same PVector sixty degrees and move along that vector from point B?  We’d be at point C!</simpara>
<informalfigure id="chapter08_figure18">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_18.png" />
  </imageobject>
  <textobject><phrase>Figure 8.18</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">  PVector kochC() {
    // Start at the beginning.
    PVector a = start.get();

    PVector v = PVector.sub(end, start);
    // Move 1/3rd of the way to point B.
    v.div(3);
    a.add(v);

    // Rotate “above” the line 60 degrees.
    v.rotate(-radians(60));
    // Move along that vector to point C.
    a.add(v);

    return a;
  }</programlisting>
<simpara>Putting it all together, if we call <emphasis role="strong"><phrase role="function">generate()</phrase></emphasis> five times in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>, we’ll see the following result.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex05.png" canvas="processingjs/chapter08/_8_05_Koch/_8_05_Koch.pde processingjs/chapter08/_8_05_Koch/KochFractal.pde processingjs/chapter08/_8_05_Koch/Kochline.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example5"><emphasis role="strong"><phrase role="example">Example 8.5: Koch curve</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">ArrayList&lt;KochLine&gt; lines;

void setup() {
  size(600, 300);
  background(255);
  lines = new ArrayList&lt;KochLine&gt;();
  PVector start = new PVector(0, 200);
  PVector end   = new PVector(width, 200);
  lines.add(new KochLine(start, end));

  // Arbitrarily apply the Koch rules five times.
  for (int i = 0; i &lt; 5; i++) {
    generate();
  }
}</programlisting>
<example>
<title>Exercise 8.2</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_exc02.png" />
  </imageobject>
  <textobject><phrase>class="half-width-right"</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Draw the Koch snowflake (or some other variation of the Koch curve).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/blank.png" />
  </imageobject>
  <textobject><phrase>imgs/blank.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Exercise 8.3</title>
<simpara>Exercise: Try animating the Koch curve.  For example, can you draw it from left to right?  Can you vary the visual design of the line segments?  Can you move the line segments using techniques from earlier chapters?  What if each line segment was made into a spring (toxiclibs) or joint (box2d)?</simpara>
</example>
<example>
<title>Exercise 8.4</title>
<simpara>Exercise: Rewrite the Cantor set example using objects and an ArrayList.</simpara>
</example>
<example>
<title>Exercise 8.5</title>
<simpara>Exercise: Draw the Sierpinski triangle (as seen in Wolfram elementary CA) using recursion.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_exc05.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_exc05.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter08_section5">
<title>8.5  Trees</title>
<simpara>The fractals we have examined in this chapter so far are deterministic, meaning they have no randomness and will always produce the identical outcome each time they are run.   They are excellent demonstrations of classic fractals and the programming techniques behind drawing them, but are too precise to feel <emphasis>natural</emphasis>.  In this next part of the chapter, I want to examine some techniques behind generating a stochastic (or non-deterministic) fractal.   The example we’ll use is a branching tree.  Let’s first walk through the steps to create a deterministic version.  Here are our production rules:</simpara>
<informalfigure id="chapter08_figure19">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_19.png" />
  </imageobject>
  <textobject><phrase>Figure 8.19</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Again, we have a nice fractal with a recursive definition: A branch is a line with two branches connected to it.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex06.png" canvas="processingjs/chapter08/_8_06_Tree_static/_8_06_Tree_static.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The part that is a bit more difficult than our previous fractals lies in the use of the word <emphasis role="strong"><emphasis>rotate</emphasis></emphasis> in the fractal’s rules.   Each new branch must rotate relative to the previous branch, which is rotated relative to all its previous branches.  Luckily for us, Processing has a mechanism to keep track of rotations for us—<emphasis role="strong"><emphasis>the transformation matrix</emphasis></emphasis>.  If you aren’t familiar with the functions <emphasis role="strong"><phrase role="function">pushMatrix()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">popMatrix()</phrase></emphasis>, I suggest you read the online Processing tutorial 2D Transformations (<ulink url="http://processing.org/learning/transform2d/">Transform 2D</ulink>), which will cover the concepts you’ll need for this particular example.</simpara>
<simpara>Let’s begin by drawing a single branch, the trunk of the tree.    Since we are going to involve the <emphasis role="strong"><phrase role="function">rotate()</phrase></emphasis> function, we’ll need to make sure we are continuously translating along the branches while we draw the tree.  And since the root starts at the bottom of the window (see above), the first step requires translating to that spot:</simpara>
<programlisting language="java" linenumbering="unnumbered">￼translate(width/2,height);</programlisting>
<informalfigure id="chapter08_figure20">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_20.png" classname="half-width-right-border" />
  </imageobject>
  <textobject><phrase>Figure 8.20</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>followed by drawing a line upwards (Figure 8.20):</simpara>
<programlisting language="java" linenumbering="unnumbered">line(0,0,0,-100);</programlisting>
<simpara>Once we’ve finished the root, we just need to translate to the end and rotate in order to draw the next branch.  (Eventually, we’re going to need to package up what we’re doing right now into a recursive function, but let’s sort out the steps first.)</simpara>
<informalfigure id="chapter08_figure21">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_21.png" />
  </imageobject>
  <textobject><phrase>Figure 8.21</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Remember, when we rotate in Processing, we are always rotating around the point of origin, so here the point of origin must always be translated to the end of our current branch.</simpara>
<programlisting language="java" linenumbering="unnumbered">translate(0,-100);
rotate(PI/6);
line(0,0,0,-100);</programlisting>
<simpara>Now that we have a branch going to the right, we need one going to the left.  We can use <emphasis role="strong"><phrase role="function">pushMatrix()</phrase></emphasis> to save the transformation state before we rotate, letting us call <emphasis role="strong"><phrase role="function">popMatrix()</phrase></emphasis> to restore that state and draw the branch to the left.  Let’s look at all the code together.</simpara>
<informalfigure id="chapter08_figure22">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_22.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure 8.22</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter08_figure23">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_23.png" classname="two-col" />
  </imageobject>
  <textobject><phrase>Figure 8.23</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">translate(width/2,height);
// The root
line(0,0,0,-100);
translate(0,-100);

pushMatrix();
rotate(PI/6);
// Branch to the right
line(0,0,0,-100);
popMatrix();

rotate(-PI/6);
// Branch to the left
line(0,0,0,-100);</programlisting>
<simpara>If you think of each call to the function <emphasis role="strong"><phrase role="function">line()</phrase></emphasis> as a “branch,” you can see from the above that we have implemented our definition of branching as a line that has two lines connected to its end.  We could keep adding more and more calls to <emphasis role="strong"><phrase role="function">line()</phrase></emphasis> for more and more branches, but just as with the Cantor set and Koch curve, our code would become incredibly complicated and unwieldy.   Instead, we can use the above logic as our foundation for writing a recursive function, replacing the direct calls to line() with our own function called <emphasis role="strong"><phrase role="function">branch()</phrase></emphasis>.  Let’s take a look.</simpara>
<simpara id="chapter08_example6"><emphasis role="strong"><phrase role="example">Example 8.6: Recursive Tree</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void branch() {
  // Draw the branch itself
  line(0, 0, 0, -100);
  // Translate to the end
  translate(0, -100);

  pushMatrix();
  // Rotate to the right and branch again
  rotate(PI/6);
  branch();
  popMatrix();

  pushMatrix();
  // Rotate to the left and branch again
  rotate(-PI/6);
  branch();
  popMatrix();
}</programlisting>
<simpara>Notice how in the above code we use <emphasis role="strong"><phrase role="function">pushMatrix()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">popMatrix()</phrase></emphasis> around each subsequent call to <emphasis role="strong"><phrase role="function">branch()</phrase></emphasis>.   This is one of those elegant code solutions that feels almost like magic.  Each call to <emphasis role="strong"><phrase role="function">branch()</phrase></emphasis> takes a moment to remember the location of that particular branch.    If you turn yourself into Processing for a moment and try to follow the recursive function with pencil and paper, you’ll notice that it draws all of the branches to the right first.   When it gets to the end, <emphasis role="strong"><phrase role="function">popMatrix()</phrase></emphasis> will pop us back along all of the branches we’ve drawn and start sending branches out to the left.</simpara>
<example>
<title>Exercise 8.6</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_exc06.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_exc06.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Emulate the Processing code in Example 8.6 [REF] and number the branches in the above diagram in the order that Processing would actually draw each one.</simpara>
</example>
<simpara>You may have noticed that the recursive function we just wrote would not actually draw the above tree.  After all, it has no exit condition and would get stuck in infinite recursive calls to itself.   You’ll also probably notice that the branches of the tree get shorter at each level.   Let’s look at how we can shrink the length of the lines as the tree is drawn, and stop branching once the lines have become too short.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Each branch now receives
// its length as an argument.
void branch(float len) {

  line(0, 0, 0, -len);
  translate(0, -len);

  // Each branch’s length
  // shrinks by two-thirds.
  len *= 0.66;

  if (len &gt; 2) {
    pushMatrix();
    rotate(theta);
    // Subsequent calls to branch()
    // include the length argument.
    branch(len);
    popMatrix();

    pushMatrix();
    rotate(-theta);
    branch(len);
    popMatrix();
  }
}</programlisting>
<simpara>We’ve also included a variable for theta that allows us, when writing the rest of the code in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, to vary the branching angle according to, say, the mouseX location.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex06a.png" classname="three-col" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex06a.png</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex06b.png" classname="three-col" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex06b.png</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex06c.png" classname="three-col" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex06c.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example7"><emphasis role="strong"><phrase role="example">Example 8.7: Recursive tree</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">float theta;

void setup() {
  size(300, 200);
}

void draw() {
  background(255);
  // Pick an angle according to
  // the mouse location.
  theta = map(mouseX,0,width,0,PI/2);

  // The first branch starts at the
  // bottom of the window.
  translate(width/2, height);
  stroke(0);
  branch(60);
}</programlisting>
<example>
<title>Exercise 8.7</title>
<simpara>Exercise: Vary the <emphasis role="strong"><phrase role="function">strokeWeight()</phrase></emphasis> for each branch.  Make the root thick and each subsequent branch thinner.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_exc07.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_exc07.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example>
<title>Exercise 8.8</title>
<simpara>Exercise: The tree structure can also be generated using the ArrayList technique demonstrated with the Koch curve.  Recreate the tree using a Branch object and an ArrayList to keep track of the branches.  Hint: you’ll want to keep track of the branch directions and lengths using vector math instead of Processing transformations.</simpara>
</example>
<example>
<title>Exercise 8.9</title>
<simpara>Exercise: Once you have the tree built with an ArrayList of Branch objects, animate the tree’s growth.  Can you draw leaves at the end of the branches?</simpara>
</example>
<simpara>The recursive tree fractal is a nice example of a scenario in which adding a little bit of randomness can make the tree look more natural.  Take a look outside and you’ll notice that branch lengths and angles vary from branch to branch, not to mention the fact that branches don’t all have exactly the same number of smaller branches.   First, let’s see what happens when we simply vary the angle and length.  This is a pretty easy one, given that we can just ask Processing for a random number each time we draw the tree.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex07a.png" canvas="processingjs/chapter08/_8_07_TreeStochastic_angleonly/_8_07_TreeStochastic_angleonly.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex07a.png</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">void branch(float len) {
  // Start by picking a random
  // angle for each branch.
  float theta = random(0,PI/3);

￼ line(0, 0, 0, -len);
  translate(0, -len);
  len *= 0.66;
  if (len &gt; 2) {
    pushMatrix();
    rotate(theta);
    branch(len);
    popMatrix();
    pushMatrix();
    rotate(-theta);
    branch(len);
    popMatrix();
  }
}</programlisting>
<simpara>In the above function, we always call <emphasis role="strong"><phrase role="function">branch()</phrase></emphasis> twice.  But why not pick a random number of branches and call <emphasis role="strong"><phrase role="function">branch()</phrase></emphasis> that number of times?￼</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex07b.png" canvas="processingjs/chapter08/_8_07_TreeStochastic/_8_07_TreeStochastic.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex07b.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example8"><emphasis role="strong"><phrase role="example">Example 8.8: Stochastic tree</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void branch(float len) {

  line(0, 0, 0, -len);
  translate(0, -len);

  if (len &gt; 2) {

    // Call branch() a random
    // number of times.
    int n = int(random(1,4));
    for (int i = 0; i &lt; n; i++) {

      // Each branch gets its own random angle.
      float theta = random(-PI/2, PI/2);
      pushMatrix();
      rotate(theta);
      branch(h);
      popMatrix();
    }
  }</programlisting>
<example>
<title>Exercise 8.10</title>
<simpara>Set the angles of the branches of the tree according to Perlin noise values.  Adjust the noise values over time to animate the tree.  See if you can get it to appear as if it is blowing in the wind.</simpara>
</example>
<example>
<title>Exercise 8.11</title>
<simpara>Use toxiclibs to simulate tree physics.  Each branch of the tree should be two particles connected with a spring.  How can you get the tree to stand up and not fall down?</simpara>
</example>
</section>
<section id="chapter08_section6">
<title>8.6  L-Systems</title>
<simpara>In 1968, Hungarian botanist Aristid Lindenmayer developed a grammar-based system to model the growth patterns of plants.    L-Systems (short for Lindenmayer systems) can be used to generate all of the recursive fractal patterns we’ve seen so far in this chapter.   We don’t need L-Systems to do the kind of work we’re doing here; however, they are incredibly useful because they provide a mechanism for keeping track of fractal structures that require complex and multi-faceted production rules.</simpara>
<simpara>In order to create an example that implements L-Systems in Processing, we are going to have to be comfortable with working with (a) recursion, (b) transformation matrices, and (c) Strings.    So far we’ve worked with recursion and transformations, but Strings are new here.  We will assume the basics, but if that is not comfortable for you, I would suggest taking a look at the Processing tutorial “Strings and Drawing text” available here: <ulink url="http://www.processing.org/learning/text/">Strings and Drawing Text</ulink></simpara>
<simpara>An L-System involves three main components:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Alphabet.</emphasis></emphasis>  An L-System’s alphabet is comprised of the valid characters that can be included.  For example, we could say the alphabet is “ABC”, meaning that any valid “sentence” (a string of characters) in an L-System can only include these three characters.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Axiom.</emphasis></emphasis>  The axiom is a sentence (made up with characters from the alphabet) that describes  the initial state of the system.  For example, with the alphabet “ABC”, some example axioms are “AAA” or “B” or “ACBAB”.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Rules.</emphasis></emphasis>  The rules of an L-System are applied to the axiom and then applied recursively, generating new sentences over and over again.  An L-System rule includes two sentences,a “predecessor” and a “successor.”  For example, with the Rule “A —&gt; AB”, whenever an “A” is found in a string, it is replaced with “AB.”
</simpara>
</listitem>
</itemizedlist>
<simpara>Let’s begin with a very simple L-System.  (This is, in fact, Lindenmayer’s original L-System for modeling the growth of algae.)</simpara>
<informalfigure id="chapter08_figure24">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_24.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 8.24</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><emphasis>Alphabet:</emphasis></emphasis>   A B<?asciidoc-br?>
<emphasis role="strong"><emphasis>Axiom:</emphasis></emphasis>      A<?asciidoc-br?>
<emphasis role="strong"><emphasis>Rules:</emphasis></emphasis>      (A —&gt; AB)  (B —&gt; A)</simpara>
<simpara>As with our recursive fractal shapes, we can consider each successive application of the L-System rules to be a generation.  Generation 0 is, by definition, the axiom.</simpara>
<simpara>and so on and so forth. . .</simpara>
<simpara>Let’s look at how we might create these generations with code.  We’ll start by using a String object to store the axiom.</simpara>
<programlisting language="java" linenumbering="unnumbered">String current = "A";</programlisting>
<simpara>And once again, just as we did with the Game of Life and the Koch curve ArrayList examples, we will need an entirely separate String to keep track of the “next” generation.</simpara>
<programlisting language="java" linenumbering="unnumbered">String next = "";</programlisting>
<simpara>Now it’s time to apply the rules to the <emphasis role="strong"><emphasis>current</emphasis></emphasis> generation and place the results in the <emphasis role="strong"><emphasis>next</emphasis></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = 0; i &lt; current.length(); i++) {
  char c = current.charAt(i);
  // Production rule A --&gt; AB
  if (c == 'A') {
    next += "AB";
  // Production rule B --&gt; A
  } else if (c == 'B') {
    next += "A";
  }
}</programlisting>
<simpara>And when we’re done, current can become next.</simpara>
<programlisting language="java" linenumbering="unnumbered">current = next;</programlisting>
<simpara>To be sure this is working, let’s package it into a function and and call it every time the mouse is pressed.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex08.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex08.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example9"><emphasis role="strong"><phrase role="example">Example 8.9: Simple L-System sentence generation</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// Start with an axiom.
String current = "A";
// Let’s keep track of how many generations.
int count = 0;

void setup() {
  println("Generation " + count + ": " + current);
}

void draw() {
}

void mousePressed() {
  String next = "";
  // Traverse the current String and make the new one.
  for (int i = 0; i &lt; current.length(); i++) {
    char c = current.charAt(i);
    if (c == 'A') {
      next += "AB";
    }  else if (c == 'B') {
      next += "A";
    }
  }
  current = next;
  count++;
  println("Generation " + count + ": " + current);
}</programlisting>
<simpara>Since the rules are applied recursively to each generation, the length of the String grows exponentially.   By generation #11, the sentence is 233 characters long; by generation #22, it is over 46,000 characters long.   The Java String class, while convenient to use, is a grossly inefficient data structure for concatenating large Strings.   A String object is “immutable,” which means once the object is created it can never be changed.  Whenever you add on to the end of a String object, Java has to make a brand new String object (even if you are using the same variable name.)</simpara>
<programlisting language="java" linenumbering="unnumbered">String s = “blah”;
s += “add some more stuff”;</programlisting>
<simpara>In most cases, this is fine, but why duplicate a 46,000 character String if you don’t have to?   For better efficiency in our L-System examples, we’ll use the StringBuffer, which is optimized for this type of task and can easily be converted into a String after concatenation is complete.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // A StringBuffer for the “next” sentence
  StringBuffer next = new StringBuffer();
  for (int i = 0; i &lt; current.length(); i++) {
    char c = current.charAt(i);
    if (c == 'A') {
      // append() instead of +=
      next.append("AB");
    } else if (c == 'B') {
      next.append("A");
    }
  }
  // StringBuffer can easily be converted
  // back to a String.
  current = next.toString();</programlisting>
<simpara>You may find yourself wondering right about now: what exactly is the point of all this?  After all, isn’t this a chapter about <emphasis>drawing</emphasis> fractal patterns?   Yes, the recursive nature of the L-System sentence structure seems relevant to the discussion, but how exactly does this model plant growth in a visual way?</simpara>
<simpara>What we’ve left unsaid until now is that embedded into these L-System sentences are instructions for drawing.   Let’s see how this works with another example.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">Alphabet:     A</phrase></emphasis> <?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Axiom:        A</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Rules:        (A —&gt; ABA)  (B —&gt; BBB)</phrase></emphasis></simpara>
<simpara>To read a sentence, we’ll translate it in the following way:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">A:    Draw a line forward.</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">B:    Move forward without drawing.</phrase></emphasis></simpara>
<simpara>Let’s look at the sentence of each generation and its visual output.￼</simpara>
<simpara><emphasis role="strong"><phrase role="formula">Generation 0: A</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Generation 1: ABA</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Generation 2: ABABBBABA</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Generation 3: ABABBBABABBBBBBBBBABABBBABA</phrase></emphasis></simpara>
<simpara>Look familiar?  This is the Cantor Set generated with an L-System.</simpara>
<informalfigure id="chapter08_figure25">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_25.png" />
  </imageobject>
  <textobject><phrase>Figure 8.25</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The following alphabet is often used with L-Systems: “FG+-[]”, meaning:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">F:    Draw a line and move forward</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">G:    Move forward (without drawing a line)</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">+:    Turn right</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">-:    Turn left</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">[:    Save current location</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">]:    Restore previous location</phrase></emphasis></simpara>
<simpara>This type of drawing framework is often referred to as “Turtle graphics” (from the old days of LOGO programming).   Imagine a turtle sitting on your computer screen to which you could issue a small set of commands: turn left, turn right, draw a line, etc.  Processing isn’t set up to operate this way by default, but by using <emphasis role="strong"><phrase role="function">translate()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">rotate()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">line()</phrase></emphasis>, we can emulate a Turtle graphics engine fairly easily.</simpara>
<simpara>Here’s how we would translate the above L-System alphabet into Processing code.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">F:    line(0,0,0,len); translate(0,len);</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">G:    translate(0,len);</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">+:    rotate(angle);</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">-:    rotate(-angle);</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">[:    pushMatrix();</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">]:    popMatrix();</phrase></emphasis></simpara>
<simpara>Assuming we have a sentence generated from the L-System, we can walk through the sentence character by character and call the appropriate function as outlined above.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = 0; i &lt; sentence.length(); i++) {

  // Looking at each character one at a time
  char c = sentence.charAt(i);

  // Performing the correct task for each character.
  // This could also be written with a “case” statement,
  // which might be nicer to look at, but leaving it as an
  // if/else if structure helps readers not familiar with case statements.
  if (c == 'F') {
    line(0,0,len,0);
    translate(len,0);
  } else if (c == 'F') {
   translate(len,0);
  } else if (c == '+') {
    rotate(theta);
  } else if (c == '-') {
    rotate(-theta);
  } else if (c == '[') {
    pushMatrix();
  } else if (c == ']') {
    popMatrix();
  }
}</programlisting>
<simpara>The next example will draw a more elaborate structure with the following L-System.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">Alphabet:     FG+-[]</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Axiom:        F</phrase></emphasis><?asciidoc-br?>
<emphasis role="strong"><phrase role="formula">Rules:        F -&#8594; FF+[+F-F-F]-[-F+F+F]</phrase></emphasis></simpara>
<simpara>The example available for download on the book’s web site takes all of the L-System code provided in this section and organizes it into three classes:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="mono">Rule</phrase></emphasis>:  A class that stores the predecessor and successor Strings for an L-System rule.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="mono">L-System</phrase></emphasis>: A class to iterate a new L-System generation (as demonstrated with the StringBuffer technique).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="mono">Turtle</phrase></emphasis>: A class to manage reading the L-System sentence and following its instructions to draw on the screen.
</simpara>
</listitem>
</itemizedlist>
<simpara>We won’t write out these classes here since they simply duplicate the code we’ve already worked out in this chapter. However, let’s see how they are put together in the main tab.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter08/ch08_ex09.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter08/ch08_ex09.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter08_example10"><emphasis role="strong"><phrase role="example">Example 8.10: LSystem</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">LSystem lsys;
Turtle turtle;

void setup() {
  size(600,600);

  // A ruleset is an array of Rule objects.
  Rule[] ruleset = new Rule[1];
  ruleset[0] = new Rule('F',"FF+[+F-F-F]-[-F+F+F]");

  // The L-System is created with an axiom and a ruleset.
  lsys = new LSystem("F",ruleset);

  // The Turtle graphics renderer is given a sentence,
  // a starting length, and an angle for rotations.
  turtle = new Turtle(lsys.getSentence(),width/4,radians(25));
}

void draw() {
  background(255);
  // Start at the bottom of the window and draw.
  translate(width/2,height);
  turtle.render();
}

void mousePressed() {
  // Generate a new sentence when the mouse is pressed.
  lsys.generate();
  turtle.setToDo(lsys.getSentence());

  // The length shrinks each generation.
  turtle.changeLen(0.5);
}</programlisting>
<example>
<title>Exercise 8.12</title>
<simpara>Exercise: Use an L-System as a set of instructions for creating objects stored in an ArrayList.  Use trigonometry and vector math to perform the rotations instead of matrix transformations (much like we did in the KochCurve example).</simpara>
</example>
<example>
<title>Exercise 8.13</title>
<simpara>Exercise: The seminal work in L-Systems and plant structures, The Algorithmic Beauty of Plants by Przemyslaw Prusinkiewicz and Aristid Lindenmayer, was published in 1990.  It is available for free in its entirety online at: <ulink url="http://algorithmicbotany.org/papers/#abop">http://algorithmicbotany.org/papers/#abop</ulink>.  Chapter 1 describes many sophisticated L-Systems with additional drawing rules and available alphabet characters.  In addition, it describes several methods for generating Stochastic L-Systems.   Expand the L-System example to include one or more additional features described by Prusinkiewicz and Lindenmayer.</simpara>
</example>
<example>
<title>Exercise 8.14</title>
<simpara>Exercise: In this chapter, we emphasized using fractal algorithms for generating visual patterns. However, fractals can be found in other creative mediums.  For example, fractal patterns are evident in Johann Sebastian Bach’s Cello Suite No. 3.  The structure of David Foster Wallace’s novel Infinite Jest was inspired by fractals.  Consider using the examples in this chapter to generate audio or text.</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 7 Exercise:</simpara>
<simpara>Incorporate fractals into your ecosystem.  Some possibilities:</simpara>
<itemizedlist>
<listitem>
<simpara>
Add plant-like creatures to the ecosystem environment.
</simpara>
</listitem>
<listitem>
<simpara>
Let’s say one of your plants is similar to a tree.  Can you add leaves or flowers to the end of the branches?   What if the leaves can fall off the tree (depending on a wind force)?  What if you add fruit that can be picked and eaten by the creatures?
</simpara>
</listitem>
<listitem>
<simpara>
Design a creature with a fractal pattern.
</simpara>
</listitem>
<listitem>
<simpara>
Use an L-System to generate instructions for how a creature should move or behave.
</simpara>
</listitem>
</itemizedlist>
</tip>
</section>
</chapter>
<chapter id="_chapter_9_the_evolution_of_code">
<title>Chapter 9.  The Evolution of Code</title>
<blockquote>
<attribution>
Richard Dawkins
</attribution>
<simpara>“The fact that life evolved out of nearly nothing, some 10 billion years after the universe evolved out of literally nothing, is a fact so staggering that I would be mad to attempt words to do it justice.”</simpara>
</blockquote>
<simpara>Let’s take a moment to think back to a simpler time, when you wrote your first Processing sketches and life was free and easy.  What is one of programming’s fundamental concepts that you likely used in those first sketches and continue to use over and over again?  <emphasis>Variables</emphasis>.  Variables allow you to save data and reuse that data while a program runs.   This, of course, is nothing new to us.  In fact, we have moved far beyond a sketch with just one or two variables and onto more complex data structures—variables made from custom types (objects) that include both data and functionality.  We’ve made our own little worlds of movers and particles and vehicles and cells and trees.</simpara>
<simpara>In each and every example in this book, the variables of these objects have to be initialized.  Perhaps you made a whole bunch of particles with random colors and sizes or a list of vehicles all starting at the same <emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y</phrase></emphasis> location on screen.   But  instead of acting as “intelligent designers” and assigning the properties of our objects through randomness or thoughtful consideration, we can let a process found in nature— <emphasis>evolution</emphasis> —decide for us.</simpara>
<simpara>Can we think of the variables of an object as its DNA?  Can objects make other objects and pass down their DNA to a new generation?  Can our simulation evolve?
 The answer to all these questions is yes.  After all, we wouldn’t be able to face ourselves in the mirror as nature-of-coders without tackling a simulation of one of the most powerful algorithmic processes found in nature itself.  This chapter is dedicated to examining the principles behind biological evolution and finding ways to apply those principles in code.</simpara>
<section id="chapter09_section1">
<title>9.1  Genetic Algorithms: Inspired by Actual Events</title>
<simpara>It’s important for us to clarify the goals of this chapter.   We will not go into depth about the science of genetics and evolution as it happens in the real world.  We won’t be making Punnett squares (sorry to disappoint) and there will be no discussion of nucleotides, protein synthesis, RNA, and other topics related to the actual biological processes of evolution.  Instead, we are going to look at the core principles behind Darwinian evolutionary theory and develop a set of algorithms <emphasis>inspired</emphasis> by these principles.   We don’t care so much about an accurate simulation of evolution; rather, we care about methods for applying evolutionary strategies in software.</simpara>
<simpara>This is not to say that a project with more scientific depth wouldn’t have value, and I encourage readers with a particular interest in this topic to explore possibilities for expanding the examples provided with additional evolutionary features.  Nevertheless, for the sake of keeping things manageable, we’re going to stick to the basics, which will be plenty complex and exciting.</simpara>
<simpara>The term “Genetic Algorithm” refers to a specific algorithm implemented in a specific way to solve specific sorts of problems.   While the formal Genetic Algorithm itself will serve as the foundation for the examples we create in this chapter, we needn’t worry about implementing the algorithm with perfect accuracy, given that we are looking for creative uses of evolutionary theories in our code.  This chapter will be broken down into the following three parts (with the majority of the time spent on the first.)</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Traditional Genetic Algorithm.</emphasis></emphasis>  We’ll begin with the traditional computer science genetic algorithm.  This algorithm was developed to solve problems in which the solution space is so vast that a “brute force” algorithm would simply take too long.   Here’s an example: I’m thinking of a number.  A number between one and one billion.  How long will it take for you to guess it?  Solving a problem with “brute force” refers to the process of checking every possible solution.  Is it one?  Is it two?  Is it three?  Is it four? And so and and so forth.  Though luck does play a factor here, with brute force we would often find ourselves patiently waiting for years while you count to one billion.   However, what if I could tell you if an answer you gave was good or bad?  Warm or cold?   Very warm?  Hot?  Super, super cold?  If you could evaluate how “fit” a guess is, you could pick other numbers closer to that guess and arrive at the answer more quickly.  Your answer could evolve.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Interactive Selection.</emphasis></emphasis>  Once we establish the traditional computer science algorithm, we’ll look at other applications of genetic algorithms in the visual arts.  Interactive selection refers to the process of evolving something (often an computer-generated image) through user interaction.  Let’s say you walk into a museum gallery and see ten paintings.   With interactive selection, you would pick your favorites and allow an algorithmic process to generate (or “evolve”) new paintings based on your preferences.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Ecosystem Simulation.</emphasis></emphasis>  The traditional computer science genetic algorithm and interactive selection technique are what you will likely find if you search online or read a textbook about artificial intelligence.  But as we’ll soon see, they don’t really simulate the process of evolution as it happens in the real world.   In this chapter, I want to also explore techniques for simulating the process of evolution in an ecosystem of pseudo-living beings.  How can our objects that move about the screen meet each other, mate, and pass their genes onto a new generation?  This would apply directly to the “eco-system” project outlined at the end of each chapter.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="chapter09_section2">
<title>9.2 Why Use Genetic Algorithms?</title>
<simpara>While computer simulations of evolutionary processes date back to the 1950s, much of what we think of as genetic algorithms (also known as “GAs”) today was developed by John Holland, a professor at University of Michigan whose book <emphasis>Adaptation in Natural and Artificial Systems</emphasis> pioneered GA research.  Today, more genetic algorithms are part of a wider field of research, often referred to as "Evolutionary Computing."</simpara>
<simpara>To help illustrate the traditional genetic algorithm, we are going to start with monkeys.  No, not our evolutionary ancestors.  We’re going to start with some fictional monkeys that bang away on keyboards with the goal of typing out the complete works of Shakespeare.</simpara>
<simpara id="chapter09_figure1"><emphasis role="strong"><phrase role="notetoself">[Missing Figure 9.1: Monkeys]</phrase></emphasis></simpara>
<simpara>The “infinite monkey theorem” is stated as follows:  A monkey hitting keys randomly on a typewriter will eventually type the complete works of Shakespeare (given an infinite amount of time).   The problem with this theory is that the probability of said monkey actually typing Shakespeare is so low that even if that monkey started at the Big Bang, it’s unbelievably unlikely we’d even have Hamlet at this point.   Let’s consider a monkey named George.</simpara>
<simpara>George types on a reduced typewriter containing only twenty-seven characters: twenty-six letters and one space bar.  So the probability of George hitting any given key is one in twenty-seven.</simpara>
<simpara>Let’s consider the phrase “to be or not to be that is the question” (we’re simplifying it from the original “To be, or not to be: that is the question”).  The phrase is 39 characters long. If George starts typing, the chance he’ll get the first character right is 1 in 27. Since the probability he’ll get the second character right is also 1 in 27, he has a 1 in 27*27 chance of landing the first two characters in correct order (this follows directly from our discussion of  <link linkend="intro.section3">"event probability in the introduction"</link>). Therefore, the probability that George will type the full phrase is:</simpara>
<simpara>(1/27) multiplied by itself 33 times, i.e. (1/27)<superscript>39</superscript></simpara>
<simpara>which equals a 1 in 66,555,937,033,867,822,607,895,549,241,096,482,953,017,615,834,735,226,163 chance of getting it right!</simpara>
<simpara>Needless to say, even hitting just this one phrase, not to mention an entire play, is highly unlikely.   Even if George is a computer simulation and can type one million random phrases per second, for George to have a 99% probability of eventually getting it right, he would have to type for 9,719,096,182,010,563,073,125,591,133,903,305,625,605,017 years. (Note that the age of the universe is estimated at a mere 13,750,000,000 years.)</simpara>
<simpara>The point of all these unfathomably large numbers is not to give you a headache, but to demonstrate that a brute force algorithm (typing every possible random phrase) is not a reasonable strategy for arriving randomly at “to be or not to be that is the question”.   Enter genetic algorithms, which will show that we can still start with random phrases and find the solution through simulated evolution.</simpara>
<simpara>Now, it’s worth noting that this problem (<emphasis>arrive at the phrase “to be or not to be”</emphasis>) is a ridiculous one.  Since we know the answer, all we need to do is type it.  Here’s a Processing sketch that solves the problem.</simpara>
<programlisting language="java" linenumbering="unnumbered">String s = "To be, or not to be: that is the question";
println(s);</programlisting>
<simpara>Nevertheless, the point here is that solving a problem with a known answer allows us to easily test our code.   Once we’ve successfully solved the problem, we can feel more confident in using genetic algorithms to do some actual useful work: solving problems with unknown answers.   So this first example serves no real purpose other than to demonstrate how genetic algorithms work.  If we test the GA results against the known answer and get “to be or not to be”, then we’ve succeeded in writing our genetic algorithm.</simpara>
<example id="chapter09_exercise1">
<title>Exercise 9.1</title>
<simpara>Create a sketch that generates random Strings.  We’ll need to know how to do this in order to implement the genetic algorithm example that will shortly follow.   How long does it take for Processing to randomly generate the String “cat.”  How could you adapt this to generate a random design using Processing’s shape drawing functions?</simpara>
</example>
</section>
<section id="chapter09_section3">
<title>9.3  Darwinian Natural Selection</title>
<simpara>Before we begin walking through the genetic algorithm, let’s take a moment to describe three core principles of Darwinian evolution that will be required as we implement our simulation.   In order for natural selection to occur as it does in nature, all three of these elements must be present.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Heredity.</emphasis></emphasis>  There must be a process in place by which children receive the properties of their parents. If creatures live long enough to reproduce, then their traits are passed down to their children in the next generation of creatures.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Variation.</emphasis></emphasis>  There must be a variety of traits present in the population or a means with which to introduce variation.   For example, let’s say there is a population of beetles in which all the beetles are exactly the same: same color, same size, same wingspan, same everything.   Without any variety in the population, the children will always be identical to the parents and to each other.  New combinations of traits can never occur and nothing can evolve.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Selection.</emphasis></emphasis>  There must be a mechanism by which some members of a population have the opportunity to be parents and pass down their genetic information and some do not.  This is typically referred to as “survival of the fittest.”   For example, let’s say a population of gazelles is chased by lions every day.  The faster gazelles are more likely to escape the lions and are therefore more likely to live longer and have a chance to reproduce and pass their genes down to their children.   The term <emphasis>fittest</emphasis>, however, can be a bit misleading.  Generally, we think of it as meaning bigger, faster, or stronger.   While this may be the case in some instances, natural selection operates on the principle that some traits are better adapted for the creature’s environment and therefore produce a greater likelihood of surviving and reproducing.    It has nothing to do with a given creature being “better” (after all, this is a subjective term) or more “physically fit.”    In the case of our typing monkeys, for example, a more “fit” monkey is one that has typed a phrase closer to “to be or not to be.”
</simpara>
</listitem>
</orderedlist>
<simpara>Next I’d like to walk through the narrative of the genetic algorithm.  We’ll do this in the context of the typing monkey.  The algorithm itself will be divided into two parts: a set of conditions for initialization (i.e. Processing’s <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>) and the steps that are repeated over and over again (i.e. Processing’s <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>) until we arrive at the correct answer.</simpara>
</section>
<section id="chapter09_section4">
<title>9.4 The Genetic Algorithm, Part I: Creating a Population</title>
<simpara>In the context of the typing monkey example, we will create a population of phrases.  (Note we are using the term “phrase” rather loosely, meaning a String of characters.)   This begs the question: How do we create this population?  Here is where the Darwinian principle of <emphasis role="strong"><emphasis>variation</emphasis></emphasis> applies.  Let’s say, for simplicity, that we are trying to evolve the phrase “cat”.  And we have a population of three phrases.</simpara>
<simpara><emphasis role="strong"><phrase role="mono">hug<?asciidoc-br?>
rid<?asciidoc-br?>
won</phrase></emphasis></simpara>
<simpara>Sure, there is variety in the three phrases above, but try to mix and match the characters every which way and you will never get “cat”.  There is not <emphasis>enough</emphasis> variety here to evolve the optimal solution.  However, if we had a population of thousands of phrases, all generated randomly, chances are that at least one member of the population will have a ‘c’ as the first character, one will have an ‘a’ as the second, and one a ‘t’ as the third.  A large population will most likely give us enough variety to generate the desired phrase (and in Part 2 of the algorithm, we’ll have another opportunity to introduce even more variation in case there isn’t enough in the first place.)   So we can be more specific in describing Step 1 and say:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Create a population of randomly generated elements.</phrase></emphasis></simpara>
<simpara>This brings up another important question.   What is the element itself?   As we move through the examples in this chapter, we’ll see several different scenarios; we might have a population of images or a population of vehicles (à la <link linkend="chapter06_section13">Chapter 6</link>).   The key, and the part that is new for us in this chapter, is that each member of the population has a virtual “DNA,” a set of properties (we can call them “genes”) that describe how a given element looks or behaves.   In the case of the typing monkey, for example, the DNA is simply a String of characters.</simpara>
<simpara>In the field of genetics, there is an important distinction between the concepts <emphasis role="strong"><emphasis>genotype</emphasis></emphasis> and <emphasis role="strong"><emphasis>phenotype</emphasis></emphasis>.  The actual genetic code—in our case, the digital information itself—is an element’s <emphasis role="strong"><emphasis>genotype</emphasis></emphasis>.   This is what gets passed down from generation to generation.  The <emphasis role="strong"><emphasis>phenotype</emphasis></emphasis>, however, is the expression of that data.   This distinction is key to how you will use genetic algorithms in your own work.  What are the objects in your world?   How will you design the genotype for your objects (the data structure to store each object’s properties) as well as the phenotype (what are <emphasis>you</emphasis> using these variables to express?).   We do this all the time in graphics programming.   The simplest example is probably color.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Genotype </entry>
<entry align="left" valign="top">Phenotype</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>int c = 255;</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><phrase role="notetoself">[insert white square]</phrase></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>int c = 127;</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><phrase role="notetoself">[insert gray square]</phrase></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>int c = 0;</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><phrase role="notetoself">[insert black square]</phrase></emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As we can see, the genotype is the digital information.  Each color is a variable that stores an integer and we choose to express that integer as a color.  But how we choose to express the data is arbitrary.   In a different approach, we could have used the integer to describe the length of a line, the weight of a force, etc.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Same Genotype  </entry>
<entry align="left" valign="top">Different Phenotype (line length)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>int c = 255;</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><phrase role="notetoself">[insert 255 pixel line]</phrase></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>int c = 127;</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><phrase role="notetoself">[insert 127 pixel line]</phrase></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>int c = 0;</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><phrase role="notetoself">[insert 0 pixel line]</phrase></emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The nice thing about our monkey-typing example is that there is no difference between genotype and phenotype.   The DNA data itself is a String of characters and the expression of that data is that very String.</simpara>
<simpara>So, we can finally end the discussion of this first step and be more specific with its description, saying:</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Create a population of N elements, each with randomly generated DNA.</phrase></emphasis></simpara>
</section>
<section id="chapter09_section5">
<title>9.5 The Genetic Algorithm, Part II: Selection</title>
<simpara>Here is where we apply the Darwinian principle of <emphasis>selection</emphasis>.   We need to evaluate the population and determine which members are fit to be selected as parents for the next generation.  The process of selection can be divided into two steps.</simpara>
<simpara><emphasis role="strong"><emphasis>1) Evaluate fitness.</emphasis></emphasis></simpara>
<simpara>For our genetic algorithm to function properly, we will need to design what is referred to as a <emphasis role="strong"><emphasis>fitness function</emphasis></emphasis>.  The function will produce a numeric score to describe the fitness of a given member of the population.   This, of course, is not how the real world works at all.  Creatures are not given a score; they simply survive or not.  But in the case of the traditional genetic algorithm, where we are trying to evolve an optimal solution to a problem, we need to be able to numerically evaluate any given possible solution.</simpara>
<simpara>Let’s examine our current example, the typing monkey.   Again, let’s simplify the scenario and say we are attempting to evolve the word “cat”.   We have three members of the population: “hut”, “car”, and “box”.   Car is obviously the most fit, given that it has two correct characters; hut has only one; and box has zero.   And there it is, our fitness function:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">fitness = the number of correct characters</phrase></emphasis></simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">DNA    </entry>
<entry align="left" valign="top">Fitness</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>hut</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>car</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>box</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>We will eventually want to look at examples with more sophisticated fitness functions, but this is a good place to start.</simpara>
<simpara><emphasis role="strong"><emphasis>2) Create a mating pool.</emphasis></emphasis></simpara>
<simpara>Once the fitness has been calculated for all members of the population, we can then select which members are fit to become parents and place them in a mating pool.  There are several different approaches we could take here.  For example, we could employ what is known as the <emphasis>elitist</emphasis> method and say “Which two members of the population scored the highest?  You two will make all the children for the next generation.”  This is probably one of the easier methods to program; however, it flies in the face of the principle of variation.  If two members of the population (out of perhaps thousands) are the only ones available to reproduce, the next generation will have little variety and this may stunt the evolutionary process.   We could instead make a mating pool out of a larger number—for example, the top 50% of the population, 500 out of 1,000.   This is also just as easy to program, but it will not produce optimal results.   In this case, the high-scoring top elements would have the same chance of being selected as a parent as the ones toward the middle.  And why should element number 500 have a solid shot of reproducing, while element number 501 has no shot?</simpara>
<simpara>A better solution for the mating pool is to use a <emphasis role="strong"><emphasis>probabilistic</emphasis></emphasis> method, which we’ll call the “wheel of fortune” (also known as the “roulette wheel”).    To illustrate this method, let’s consider a simple example where we have a population of five elements, each with a fitness score.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Element        </entry>
<entry align="left" valign="top">Fitness</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>A</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>B</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>C</simpara></entry>
<entry align="left" valign="top"><simpara>0.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>D</simpara></entry>
<entry align="left" valign="top"><simpara>1.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>E</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The first thing we’ll want to do is <emphasis role="strong"><emphasis>normalize</emphasis></emphasis> all the scores.  Remember normalizing a vector?  That involved taking an vector and standardizing its length, setting it to one.   When we normalize a set of fitness scores, we are standardizing their range to between 0 and 1, as a percentage of total fitness.   Let’s add up all the fitness scores.</simpara>
<simpara><emphasis role="strong"><phrase role="fomrula">total fitness = 3 + 4 + 0.5 + 1.5 + 1 = 10</phrase></emphasis></simpara>
<simpara>Then let’s divide each score by the total fitness, giving us the normalized fitness.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Element        </entry>
<entry align="left" valign="top">Fitness        </entry>
<entry align="left" valign="top">Normalized Fitness     </entry>
<entry align="left" valign="top">Expressed as a Percentage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>A</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>0.3</simpara></entry>
<entry align="left" valign="top"><simpara>30%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>B</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>0.4</simpara></entry>
<entry align="left" valign="top"><simpara>40%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>C</simpara></entry>
<entry align="left" valign="top"><simpara>0.5</simpara></entry>
<entry align="left" valign="top"><simpara>0.05</simpara></entry>
<entry align="left" valign="top"><simpara>5%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>D</simpara></entry>
<entry align="left" valign="top"><simpara>1.5</simpara></entry>
<entry align="left" valign="top"><simpara>0.15</simpara></entry>
<entry align="left" valign="top"><simpara>15%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>E</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0.1</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Now it’s time for the wheel of fortune.</simpara>
<informalfigure id="chapter09_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_02.png" />
  </imageobject>
  <textobject><phrase>Figure 9.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Spin the wheel and you’ll notice that Element B has the highest chance of being selected, followed by A, then D, then E, and finally C.  This probability-based selection according to fitness is an excellent approach.  One, it guarantees that the highest-scoring elements will be most likely to reproduce.  Two, it does not entirely eliminate any variation from the population.   Unlike with the elitist method, even the lowest-scoring element (in this case C) has a chance to pass its information down to the next generation.    It’s quite possible (and often the case) that even low-scoring elements have a tiny nugget of genetic code that is truly useful and should not entirely be eliminated from the population.   For example, in the case of evolving “to be or not to be,” we might have the following elements.</simpara>
<simpara><emphasis role="strong"><phrase role="mono">A:    to be or not to go<?asciidoc-br?>
B:    to be or not to pi<?asciidoc-br?>
C:    xxxxxxxxxxxxxxxxbe</phrase></emphasis></simpara>
<simpara>As you can see, elements A and B are clearly the most fit and would have the highest score.  But neither contains the correct characters for the end of the phrase.  Element C, even though it would receive a very low score, happens to have the genetic data for the end of the phrase.  And so while we would want A and B to be picked to generate the majority of the next generation, we would still want C to have a small chance to participate in the reproductive process.</simpara>
</section>
<section id="chapter09_section6">
<title>9.6 The Genetic Algorithm, Part III: Reproduction</title>
<simpara>Now that we have a strategy for picking parents, we need to figure out how to use <emphasis>reproduction</emphasis> to make the population’s next generation, keeping in mind the Darwinian principle of heredity—that children inherit properties from their parents.  Again, there are a number of different techniques we could employ here.  For example, one reasonable (and easy to program) strategy is asexual reproduction, meaning we pick just one parent and create a child that is an exact copy of that parent.   The standard approach with genetic algorithms, however, is to pick two parents and create a child according to the following steps.</simpara>
<simpara><emphasis role="strong"><emphasis>1) Crossover.</emphasis></emphasis></simpara>
<simpara>Crossover involves creating a child out of the genetic code of two parents.   In the case of the monkey-typing example, let’s assume we’ve picked two phrases from the mating pool (as outlined in our selection step).</simpara>
<simpara><emphasis role="strong"><phrase role="mono">Parent A:    FORK
Parent B:    PLAY</phrase></emphasis></simpara>
<simpara>It’s now up to us to make a child phrase from these two.  Perhaps the most obvious way (let’s call this the 50/50 method) would be to take the first two characters from A and the second two from B, leaving us with:</simpara>
<informalfigure id="chapter09_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_03.png" />
  </imageobject>
  <textobject><phrase>Figure 9.3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
A variation of this technique is to pick a random midpoint.  In other words, we don’t have to pick exactly half of the code from each parent.  We could sometimes end up with FLAY, and sometimes with FORY.  This is preferable to the 50/50 approach, since we increase the variety of possibilities for the next generation.</simpara>
<informalfigure id="chapter09_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_04.png" />
  </imageobject>
  <textobject><phrase>Figure 9.4: Picking a random midpoint.</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Another possibility is to randomly select a parent for each character in the child String.  You can think of this as flipping a coin four times: heads take from parent A, tails from parent B.  Here we could end up with many different results such as: PLRY, FLRK, FLRY, FORY, etc.</simpara>
<informalfigure id="chapter09_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_05.png" />
  </imageobject>
  <textobject><phrase>Figure 9.5: Coin-Flipping Approach</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This strategy will produce essentially the same results as the random midpoint method; however, if the order of the genetic information plays some role in expressing the phenotype, you may prefer one solution over the other.</simpara>
<simpara><emphasis role="strong"><emphasis>2) Mutation.</emphasis></emphasis></simpara>
<simpara>Once the child DNA has been created via crossover, we apply one final process before adding the child to the next generation—<emphasis role="strong"><emphasis>mutation</emphasis></emphasis>.   Mutation is an optional step, as there are some cases in which it is unnecessary.  However, it exists because of the Darwinian principle of variation.  We created an initial population randomly, making sure that we start with a variety of elements.  However, there can only be so much variety when seeding the first generation, and mutation allows us to introduce additional variety throughout the evolutionary process itself.</simpara>
<informalfigure id="chapter09_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_06.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Mutation is described in terms of a <emphasis>rate</emphasis>.  A given genetic algorithm might have a mutation rate of 5% or 1% or 0.1%, etc.  Let’s assume we just finished with crossover and ended up with the child FORY.  If we have a mutation rate of 1%, this means that for each character in the phrase generated from crossover, there is a 1% chance that it will mutate.  What does it mean for a character to mutate?  In this case, we define mutation as picking a new random character.    A 1% probability is fairly low, and most of the time mutation will not occur at all in a four-character String (96% of the time to be more precise).   However, when it does, the mutated character is replaced with a randomly generated one (See Figure 9.6).</simpara>
<simpara>As we’ll see in some of the examples, the mutation rate can greatly affect the behavior of the system.   Certainly, a very high mutation rate (such as, say, 80%) would negate the evolutionary process itself.  If the majority of a child’s genes are generated randomly, then we cannot guarantee that the more “fit” genes occur with greater frequency with each successive generation.</simpara>
<simpara>The process of selection (picking two parents) and reproduction (crossover and mutation) is applied over and over again <emphasis role="strong"><phrase role="var">N</phrase></emphasis> times until we have a new population of <emphasis role="strong"><phrase role="var">N</phrase></emphasis> elements.  At this point, the new population of children becomes the current population and we loop back to evaluate fitness and perform selection and reproduction again.</simpara>
<simpara>Now that we have described all the steps of the genetic algorithm in detail, it’s time to translate these steps into Processing code.  Because the previous description was a bit longwinded, let’s look at an overview of the algorithm first.  We’ll then cover each of the three steps in its own section, working out the code.</simpara>
<simpara><emphasis role="strong"><emphasis>SETUP:</emphasis></emphasis></simpara>
<simpara>Step 1: <emphasis role="strong"><emphasis>Initialize</emphasis></emphasis>: Create a population of N elements, each with randomly generated DNA.</simpara>
<simpara><emphasis role="strong"><emphasis>LOOP:</emphasis></emphasis></simpara>
<simpara>Step 2: <emphasis role="strong"><emphasis>Selection</emphasis></emphasis>: Evaluate the fitness of each element of the population and build a mating pool.</simpara>
<simpara>Step 3: <emphasis role="strong"><emphasis>Reproduction</emphasis></emphasis>: Repeat N times:
a. Pick two parents with probability according to relative fitness.
b. Crossover — create a “child” by combining the DNA of these two parents.
c. Mutation — mutate the child’s DNA based on a given probability.
d. Add the new child to a new population.</simpara>
<simpara>Step 4. Replace the old population with the new population and return to Step 2.</simpara>
<simpara><emphasis role="strong"><phrase role="notetoself">[Need to style above algorithm]</phrase></emphasis></simpara>
</section>
<section id="chapter09_section7">
<title>9.7  Code for Creating the Population</title>
<section id="_step_1_initialize_population">
<title>Step 1: Initialize Population</title>
<simpara>If we’re going to create a population, we need a data structure to store a list of members of the population.   In most cases (such as our typing-monkey example), the number of elements in the population can be fixed, and so we use an array.  Later we’ll see examples that involve a growing/shrinking population and we’ll use an ArrayList.   But an array of what?   We need an object that stores the genetic information for a member of the population.  Let’s call it <emphasis role="strong"><emphasis>DNA</emphasis></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

}</programlisting>
<simpara>The population will then be an array of DNA objects.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A population of 100 DNA objects
DNA[] population = new DNA[100];</programlisting>
<simpara>But what stuff goes in the DNA class?   For a typing monkey, its DNA is the random phrase it types, a String of characters.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {
  String phrase;
}</programlisting>
<simpara>While this is perfectly reasonable for this particular example, we’re not going to use an actual String object as the genetic code.  Instead, we’ll use an array of characters.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {
  // Each "gene" is one element of the array
  // We need 19 genes because “To be or not to be.” is 19 characters long.
  char[] genes = new char[19];  .
}</programlisting>
<simpara>By using an array, we’ll be able to extend all the code we write into other examples.  For example, the DNA of a creature in a physics system might be an array of PVectors—or for an image, an array of integers (RGB colors).   We can describe any set of properties in an array and even though a String is convenient for this particular sketch, an array will serve as a better foundation for future evolutionary examples.</simpara>
<simpara>Our genetic algorithm dictates that we create a population of N elements, each with <emphasis role="strong"><emphasis>randomly generated DNA</emphasis></emphasis>.  Therefore, in the object’s constructor, we randomly create each character of the array.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {
  char[] genes = new char[18];

  DNA() {
    for (int i = 0; i &lt; genes.length; i++) {
      // Picking randomly from a range of characters
      // with ASCII values between 32 and 128.
      // For more about ASCII:
      // http://en.wikipedia.org/wiki/ASCII[ASCII]
      genes[i] = (char) random(32,128);
    }
  }
}</programlisting>
<simpara>Now that we have the constructor, we can return to <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and initialize each DNA object in the population array.</simpara>
<programlisting language="java" linenumbering="unnumbered">DNA[] population = new DNA[100];

void setup() {
  for (int i = 0; i &lt; population.length; i++) {
    // Initializing each member of the population
    population[i] = new DNA();
  }
}</programlisting>
<simpara>Our DNA class is not at all complete. We’ll need to add functions to it to perform all the other tasks in our genetic algorithm, which we’ll do as we walk through steps 2 and 3.</simpara>
</section>
<section id="_step_2_selection">
<title>Step 2: Selection.</title>
<simpara>Step 2 reads, <emphasis role="strong"><emphasis>“Evaluate the fitness of each element of the population and build a mating pool.”</emphasis></emphasis>  Let’s first evaluate each object’s fitness.   Earlier we stated that one possible fitness function for our typed phrases is the total number of correct characters.  Let’s revise this fitness function a little bit and state it as the percentage of correct characters—i.e., the total number of correct characters divided by the total characters.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">Fitness = Total # Characters Correct/Total # Characters</phrase></emphasis></simpara>
<simpara>Where should we calculate the fitness?   Since the DNA class contains the genetic information (the phrase we will test against the target phrase), we can write a function inside the DNA class itself to score its own fitness.  Let’s assume we have a target phrase:</simpara>
<programlisting language="java" linenumbering="unnumbered">String target = "To be or not to be.";</programlisting>
<simpara>We can now compare each “gene” against the corresponding character in the target phrase, incrementing a counter each time we get a correct character.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {
  // We are adding another variable to the
  // DNA class to track fitness.
  float fitness;

  // Function to score fitness
  void fitness () {
    int score = 0;
    for (int i = 0; i &lt; genes.length; i++) {
      // Is the character correct?
      if (genes[i] == target.charAt(i)) {
        // If so, increment the score.
        score++;
      }
    }
    // Fitness is the percentage correct.
    fitness = float(score)/target.length();
  }</programlisting>
<simpara>In the main tab’s <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>, the very first step we’ll take is to call the fitness function for each member of the population.</simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {

  for (int i = 0; i &lt; population.length; i++) {
    population[i].fitness();
  }</programlisting>
<simpara>After we have all the fitness scores, we can build the “mating pool” that we’ll need for the reproduction step.  The mating pool is a data structure from which we’ll continuously pick two parents.  Recalling our description of the selection process, we want to pick parents with probabilities calculated according to fitness.  In other words, the members of the population that have the highest fitness scores should be most likely to be picked; those with the lowest scores, the least likely.</simpara>
<simpara>In this book’s <link linkend="intro_section3">Introduction</link>, we covered the basics of probability and generating a custom distribution of random numbers.    We’re going to use those techniques to assign a probability to each member of the population, picking parents by spinning the “wheel of fortune.”</simpara>
<informalfigure id="chapter09_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_02.png" />
  </imageobject>
  <textobject><phrase>Figure 9.2 (again)</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter09_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_07.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.7</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>It might be fun to do something ridiculous and actually program a simulation of a spinning wheel  as depicted above.  But this is quite unnecessary.  We can pick from the five options (ABCDE) according to their probabilities by filling an ArrayList with multiple instances of each parent.  In other words, let’s say you had a bucket of wooden letters—30 As, 40 Bs, 5 Cs, 15 Ds, and 10 Es.</simpara>
<simpara>If you pick a random letter out of that bucket, there’s a 30% chance you’ll get an A, a 5% chance you’ll get a C, and so on.  For us, that bucket is an ArrayList, and each wooden letter is a potential parent.  We add each parent to the ArrayList N number of times where N is equal to its percentage score.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Start with an empty mating pool.
  ArrayList&lt;DNA&gt; matingPool = new ArrayList&lt;DNA&gt;();

  for (int i = 0; i &lt; population.length; i++) {

    // n is equal to fitness times 100,
    // which leaves us with an integer between 0 and 100.
    int n = int(population[i].fitness * 100);
    for (int j = 0; j &lt; n; j++) {
      // Add each member of the population
      // to the mating pool N times.
      matingPool.add(population[i]);
    }
  }</programlisting>
<example id="chapter09_exercise2">
<title>Exercise 9.2</title>
<simpara>One of the other methods we used to generate a custom distribution of random numbers is called the “Monte Carlo method” (<emphasis role="strong"><phrase role="notetoself">REF</phrase></emphasis>).  This technique involved picking two random numbers, with the second number acting as a qualifying number and determining if the first random number should be kept or thrown away.  Rewrite the above mating pool algorithm to use the Monte Carlo method instead.</simpara>
</example>
<example id="chapter09_exercise3">
<title>Exercise 9.3</title>
<simpara>In some cases, the wheel of fortune algorithm will have an extraordinarily high preference for some elements over others.  Take the following probabilities:</simpara>
<simpara><emphasis role="strong"><phrase role="mono">A: 98%<?asciidoc-br?>
B: 1%<?asciidoc-br?>
C: 1%</phrase></emphasis></simpara>
<simpara>This is sometimes undesirable given how it will decrease the amount of variety in this system.  A solution to this problem is to replace the calculated fitness scores with the ordinals of scoring (meaning their rank).</simpara>
<simpara><emphasis role="strong"><phrase role="mono">A: 50% (3/6)<?asciidoc-br?>
B: 33% (2/6)<?asciidoc-br?>
C: 17% (1/6)</phrase></emphasis></simpara>
<simpara>Rewrite the mating pool algorithm to use this method instead.</simpara>
</example>
</section>
<section id="_step_3_reproduction">
<title>Step 3: Reproduction.</title>
<simpara>With the mating pool ready to go, it’s time to make some babies.  The first step is to pick two parents.  Again, it’s somewhat of an arbitrary decision to pick two parents.  It certainly mirrors human reproduction and is the standard means in the traditional GA, but in terms of your work, there really aren’t any restrictions here.  You could choose to perform “asexual” reproduction with one parent, or come up with a scheme for picking three or four parents from which to generate child DNA.   For this code demonstration, we’ll stick to two parents and call them “parentA” and “parentB.”</simpara>
<simpara>First thing we need are two random indices into the mating pool—random numbers between zero and the size of the ArrayList.</simpara>
<programlisting language="java" linenumbering="unnumbered">  int a = int(random(matingPool.size()));
  int b = int(random(matingPool.size()));</programlisting>
<simpara>We can use these indices to retrieve an actual DNA instance from the mating pool.</simpara>
<programlisting language="java" linenumbering="unnumbered">  DNA parentA = matingPool.get(a);
  DNA parentB = matingPool.get(b);</programlisting>
<simpara>Because we have multiple instances of the same DNA objects in the mating pool (not to mention that we could pick the same random number twice), it’s possible that parentA and parentB could be the same DNA object.  If we wanted to be strict, we could write some code to ensure that we haven’t picked the same parent twice, but we would gain very little efficiency for all that extra code.  Still, it‘s worth trying this as an exercise.</simpara>
<example id="chapter09_exercise4">
<title>Exercise 9.4</title>
<simpara>Add code to the above to guarantee that you have picked two unique “parents.”</simpara>
</example>
<simpara>Once we have the two parents, we can perform <emphasis role="strong"><emphasis>crossover</emphasis></emphasis> to generate the child DNA, followed by <emphasis role="strong"><emphasis>mutation</emphasis></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // A function for crossover
  DNA child = parentA.crossover(parentB);
  // A function for mutation
  child.mutate();</programlisting>
<simpara>Of course, the functions <emphasis role="strong"><phrase role="function">crossover()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">mutate()</phrase></emphasis> don’t magically exist in our DNA class; we have to write them.   The way we called <emphasis role="strong"><phrase role="function">crossover()</phrase></emphasis> above indicates that the function receives an instance of DNA as an argument and returns a new instance of DNA, the child.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // The function receives one argument (DNA) and returns DNA.
  DNA crossover(DNA partner) {

    // The child is a new instance of DNA
    // Note the DNA is generated randomly in the constructor,
    // but we will overwrite it below with DNA from parents.
    DNA child = new DNA();

    // Picking a random “midpoint” in the genes array
    int midpoint = int(random(genes.length));

    for (int i = 0; i &lt; genes.length; i++) {
      // Before midpoint copy genes from
      // one parent, after midpoint copy
      // genes from the other parent
      if (i &gt; midpoint) child.genes[i] = genes[i];
      else              child.genes[i] = partner.genes[i];
    }

    // Return the new child DNA
    return child;
  }</programlisting>
<simpara>The above crossover function uses the “random midpoint” method of crossover, in which the first section of genes is taken from parent A and the second section from parent B.</simpara>
<example id="chapter09_exercise5">
<title>Exercise 9.5</title>
<simpara>Rewrite the crossover function to use the “coin flipping” method instead, in which each gene has a 50% chance of coming from parent A and a 50% chance of coming from parent B.</simpara>
</example>
<simpara>The mutate() function is even simpler to write than crossover().   All we need to do is loop through the array of genes and for each randomly pick a new character according to the mutation rate.   With a mutation rate of 1%, for example, we would pick a new character one time out of a hundred.</simpara>
<programlisting language="java" linenumbering="unnumbered">float mutationRate = 0.01;

if (random(1) &lt; mutationRate) {
  // Pick a new character
  // Any code here would be executed 1% of the time.

}</programlisting>
<simpara>The entire function therefore reads:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void mutate() {
    // Looking at each gene in the array
    for (int i = 0; i &lt; genes.length; i++) {
      if (random(1) &lt; mutationRate) {
        // Mutation, a new random character
        genes[i] = (char) random(32,128);
      }
    }
  }</programlisting>
</section>
</section>
<section id="chapter09_section8">
<title>9.8  Genetic Algorithms: Putting It All Together</title>
<simpara>You may have noticed that we’ve essentially walked through the steps of the genetic algorithm twice, once describing it in narrative form and another time with code snippets implementing each of the steps.    What I’d like to do in this section is condense the previous two sections into one page, with the algorithm described in just three steps and the corresponding code alongside.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_ex01.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter09_example1"><emphasis role="strong"><phrase role="example">Example 9.1: Genetic algorithm: Evolving Shakespeare</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Variables we need for our GA&lt;/b&gt;&lt;/span&gt;

// Mutation rate
float mutationRate;
// Population Total
int totalPopulation = 150;

// Population array
DNA[] population;
// Mating pool ArrayList
ArrayList&lt;DNA&gt; matingPool;
// Target phrase
String target;

void setup() {
  size(200, 200);

  // Initializing target phrase and mutation rate
  target = "To be or not to be.";
  mutationRate = 0.01;

  // &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Step 1: Initialize Population&lt;/b&gt;&lt;/span&gt;
  population = new DNA[totalPopulation];
  for (int i = 0; i &lt; population.length; i++) {
    population[i] = new DNA();
  }
}

void draw() {

  // &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Step 2: Selection&lt;/b&gt;&lt;/span&gt;

  // Step 2a: Calculate fitness.
  for (int i = 0; i &lt; population.length; i++) {
    population[i].fitness();
  }

  // Step 2b: Build mating pool.
  ArrayList&lt;DNA&gt; matingPool = new ArrayList&lt;DNA&gt;();

  for (int i = 0; i &lt; population.length; i++) {
    // Add each member n times according to its fitness score.
    int n = int(population[i].fitness * 100);
    for (int j = 0; j &lt; n; j++) {
      matingPool.add(population[i]);
    }
  }

  // &lt;b&gt;&lt;span style="font-size: 110%; text-decoration:underline;"&gt;Step 3: Reproduction&lt;/b&gt;&lt;/span&gt;
  for (int i = 0; i &lt; population.length; i++) {
    int a = int(random(matingPool.size()));
    int b = int(random(matingPool.size()));
    DNA partnerA = matingPool.get(a);
    DNA partnerB = matingPool.get(b);
    // Step 3a: Crossover
    DNA child = partnerA.crossover(partnerB);
    // Step 3b: Mutation
    child.mutate(mutationRate);

    // Note we are overwriting the population with the new
    // children.  When draw() loops, we will perform all the same
    // steps with the new population of children.
    population[i] = child;
  }
}</programlisting>
<simpara>The main tab precisely mirrors the steps of the genetic algorithm.  However, most of the functionality called upon is actually present in the DNA class itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {


  char[] genes;
  float fitness;

  // Create DNA randomly.
  DNA() {
    genes = new char[target.length()];
    for (int i = 0; i &lt; genes.length; i++) {
      genes[i] = (char) random(32,128);
    }
  }

  // Calculate fitness.
  void fitness() {
     int score = 0;
     for (int i = 0; i &lt; genes.length; i++) {
        if (genes[i] == target.charAt(i)) {
          score++;
        }
     }
     fitness = float(score)/target.length();
  }

  // Crossover
  DNA crossover(DNA partner) {
    DNA child = new DNA(genes.length);
    int midpoint = int(random(genes.length));
    for (int i = 0; i &lt; genes.length; i++) {
      if (i &gt; midpoint) child.genes[i] = genes[i];
      else              child.genes[i] = partner.genes[i];
    }
    return child;
  }

  // Mutation
  void mutate(float mutationRate) {
    for (int i = 0; i &lt; genes.length; i++) {
      if (random(1) &lt; mutationRate) {
        genes[i] = (char) random(32,128);
      }
    }
  }

  // Convert to String—PHENOTYPE.
  String getPhrase() {
    return new String(genes);
  }

}</programlisting>
<example id="chapter09_exercise6">
<title>Exercise 9.6</title>
<simpara>Add features to the above example to report more information about the progress of the genetic algorithm itself.   For example, show the phrase closest to the target each generation, as well as report on the number of generations, average fitness, etc.  Stop the genetic algorithm once it has solved the phrase.  Consider writing a Population class to manage the GA (instead of including all the code in draw()).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_exc01.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_exc01.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
</section>
<section id="chapter09_section9">
<title>9.9  Genetic Algorithms: Make Them Your Own</title>
<simpara>The nice thing about using genetic algorithms in a project is that example code can easily be ported from application to application.  The core mechanics of selection and reproduction don’t need to change.  There are, however, three key components to genetic algorithms that you, the developer, will have to customize for each use.  This is crucial to moving beyond trivial demonstrations of evolutionary simulations (as in the Shakespeare example) to creative uses in projects that you make in Processing and other creative programming environments.</simpara>
<section id="_key_1_varying_the_variables">
<title>Key #1: Varying the variables</title>
<simpara>There aren’t a lot of variables to the genetic algorithm itself. In fact, if you look at the previous example’s code, you’ll see only two global variables (not including the arrays and ArrayLists to store the population and mating pool).</simpara>
<programlisting language="java" linenumbering="unnumbered">float mutationRate = 0.01;
int totalPopulation = 150;</programlisting>
<simpara>These two variables can greatly affect the behavior of the system, and it’s not such a good idea to arbitrarily assign them values (though tweaking them through trial and error is a perfectly reasonable way to arrive at optimal values).</simpara>
<simpara>The values I chose for the Shakespeare demonstration were picked to virtually guarantee that the genetic algorithm would solve for the phrase, but not too quickly (approximately 1,000 generations on average) so as to demonstrate the process over a reasonable period of time.    A much larger population, however, would yield faster results (if the goal were algorithmic efficiency rather than demonstration).  Here is a table of some results.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Total Population </entry>
<entry align="left" valign="top">Mutation Rate </entry>
<entry align="left" valign="top"> Number of Generations until Phrase Solved </entry>
<entry align="left" valign="top"> Total Time (in seconds) until Phrase Solved</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>150</simpara></entry>
<entry align="left" valign="top"><simpara>1%</simpara></entry>
<entry align="left" valign="top"><simpara>1089</simpara></entry>
<entry align="left" valign="top"><simpara>18.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>300</simpara></entry>
<entry align="left" valign="top"><simpara>1%</simpara></entry>
<entry align="left" valign="top"><simpara>448</simpara></entry>
<entry align="left" valign="top"><simpara>8.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1,000</simpara></entry>
<entry align="left" valign="top"><simpara>1%</simpara></entry>
<entry align="left" valign="top"><simpara>71</simpara></entry>
<entry align="left" valign="top"><simpara>1.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>50,000</simpara></entry>
<entry align="left" valign="top"><simpara>1%</simpara></entry>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>4.3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Notice how increasing the population size drastically reduces the number of generations needed to solve for the phrase.  However, it doesn’t necessarily reduce the amount of time.  Once our population balloons to fifty thousand elements, the sketch runs slowly, given the amount of time required to process fitness and build a mating pool out of so many elements. (There are, of course, optimizations that could be made should you require such a large population.)</simpara>
<simpara>In addition to the population size, the mutation rate can greatly affect performance.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Total Population </entry>
<entry align="left" valign="top">Mutation Rate </entry>
<entry align="left" valign="top"> Number of Generations until Phrase Solved </entry>
<entry align="left" valign="top"> Total Time (in seconds) until Phrase Solved</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1,000</simpara></entry>
<entry align="left" valign="top"><simpara>0%</simpara></entry>
<entry align="left" valign="top"><simpara>37 or never?</simpara></entry>
<entry align="left" valign="top"><simpara>1.2 or never?</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1,000</simpara></entry>
<entry align="left" valign="top"><simpara>1%</simpara></entry>
<entry align="left" valign="top"><simpara>71</simpara></entry>
<entry align="left" valign="top"><simpara>1.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1,000</simpara></entry>
<entry align="left" valign="top"><simpara>2%</simpara></entry>
<entry align="left" valign="top"><simpara>60</simpara></entry>
<entry align="left" valign="top"><simpara>1.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1,000</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
<entry align="left" valign="top"><simpara>never?</simpara></entry>
<entry align="left" valign="top"><simpara>never?</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Without any mutation at all (0%), you just have to get lucky.  If all the correct characters are present somewhere in some member of the initial population, you’ll evolve the phrase very quickly.  If not, there is no way for the sketch to ever reach the exact phrase.  Run it a few times and you’ll see both instances.  In addition, once the mutation rate gets high enough (10%, for example), there is so much randomness involved (1 out of every 10 letters is random in each new child) that the simulation is pretty much back to a random typing monkey.  In theory, it will eventually solve the phrase, but you may be waiting much, much longer than is reasonable.</simpara>
</section>
</section>
<section id="_key_2_the_fitness_function">
<title>Key #2: The fitness function</title>
<simpara>Playing around with the mutation rate or population total is pretty easy and involves little more than typing numbers in your sketch.  The real hard work of a developing a genetic algorithm is in writing a fitness function.  If you cannot define your problem’s goals and evaluate numerically how well those goals have been achieved, then you will not have successful evolution in your simulation.</simpara>
<simpara>Before we think about other scenarios with other fitness functions, let’s look at flaws in our Shakespearean fitness function.   Consider solving for a phrase that is not nineteen characters long, but one thousand.  Now, let’s say there are two members of the population, one with 800 characters correct and one with 801.  Here are their fitness scores:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Phrase A:</simpara></entry>
<entry align="left" valign="top"><simpara>800 characters correct</simpara></entry>
<entry align="left" valign="top"><simpara>fitness = 80%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Phrase B:</simpara></entry>
<entry align="left" valign="top"><simpara>801 characters correct</simpara></entry>
<entry align="left" valign="top"><simpara>fitness = 80.1%</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>There are a couple of problems here.  First, we are adding elements to the mating pool N numbers of times, where N equals fitness multiplied by one hundred.  Objects can only be added to an ArrayList a whole number of times, and so A and B will both be added 80 times, giving them an equal probability of being selected.  Even with an improved solution that takes floating point probabilities into account, 80.1% is only a teeny tiny bit higher than 80%.  But getting 801 characters right is a whole lot better than 800 in the evolutionary scenario.  We really want to make that additional character count.   We want the fitness score for 801 characters to be  exponentially better than the score for 800.</simpara>
<simpara>To put it another way, let’s graph the fitness function.</simpara>
<informalfigure id="chapter09_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_08.png" />
  </imageobject>
  <textobject><phrase>Figure 9.8</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is a linear graph; as the number of characters goes up, so does the fitness score.   However, what if the fitness increased exponentially as the number of correct characters increased?  Our graph could then look something like:</simpara>
<informalfigure id="chapter09_figure9">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_09.png" />
  </imageobject>
  <textobject><phrase>Figure 9.9</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The more correct characters, the even greater the fitness.  We can achieve this type of result in a number of different ways.  For example, we could say:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">fitness = (number of correct characters) * (number of correct characters)</phrase></emphasis></simpara>
<simpara>Let’s say we have two members of the population, one with five correct characters and one with six.   The number 6 is a 20% increase over the number 5.   Let’s look at the fitness scores squared.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Characters correct </entry>
<entry align="left" valign="top">Fitness</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>25</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>36</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The fitness scores increase exponentially relative to the number of correct characters.  36 is a 44% increase over 25.</simpara>
<simpara>Here’s another formula.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">fitness = 2<superscript>(number of correct characters)</superscript></phrase></emphasis></simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Characters correct             </entry>
<entry align="left" valign="top">Fitness</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Here, the fitness scores increase at a faster rate, doubling with each additional correct character.</simpara>
<example id="chapter09_exercise7">
<title>Exercise 9.7</title>
<simpara>Rewrite the fitness function to increase exponentially according to the number of correct characters.  Note you will also have to normalize the fitness values to a range between 0 and 1 so they can be added to the mating pool a reasonable number of times.</simpara>
</example>
<simpara>While this rather specific discussion of exponential vs. linear fitness functions is an important detail in the design of a good fitness function, I don’t want us to miss the more important point here: <emphasis>Design your own fitness function!</emphasis>    I seriously doubt that any project you undertake in Processing with genetic algorithms will actually involve counting the correct number of characters in a String.   In the context of this book, it’s more likely you will be looking to evolve a creature that is part of a physics system.  Perhaps you are looking to optimize the weights of steering behaviors so a creature can best escape a predator or avoid an obstacle or make it through a maze.   You have to ask yourself, what are you looking to evaluate?</simpara>
<simpara>Let’s consider a racing simulation in which a vehicle is evolving a design optimized for speed.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">fitness = total number of frames required for vehicle to reach target</phrase></emphasis></simpara>
<simpara>How about a cannon that is evolving the optimal way to shoot a target?</simpara>
<simpara><emphasis role="strong"><phrase role="formula">fitness = cannonball distance to target</phrase></emphasis></simpara>
<simpara>The design of computer-controlled players in a game is also a common scenario.  Let’s say you are programming a soccer game in which the user is the goalie.   The rest of the players are controlled by your program and have a set of parameters that determine how they kick a ball towards the goal.  What would the fitness score for any given player be?</simpara>
<simpara><emphasis role="strong"><phrase role="formula">fitness = total goals scored</phrase></emphasis></simpara>
<simpara>This, obviously, is a simplistic take on the game of soccer, but it illustrates the point.  The more goals a player scores, the higher its fitness, and the more likely its genetic information will appear in the next game.   Even with a fitness function as simple as the one described here, this scenario is demonstrating something very powerful—the adaptability of a system.  If the players continue to evolve from game to game to game, when a new <emphasis>human</emphasis> user enters the game with a completely different strategy, the system will quickly discover that the fitness scores are going down and evolve a new optimal strategy.  It will adapt.  (Don’t worry, there is very little danger in this resulting in sentient robots that will enslave all humans.)</simpara>
<simpara>In the end, if you do not have a fitness function that effectively evaluates the performance of the individual elements of your population, you will not have any evolution.  And the fitness function from one example will likely not apply to a totally different project.  So this is the part where you get to shine.  You have to design a function, sometimes from scratch, that works for your particular project.   And where do you do this?   All you have to edit are those few lines of code inside the function that computes the fitness variable.</simpara>
<programlisting language="java" linenumbering="unnumbered">void fitness() {
  ????????????
  ????????????
  fitness = ??????????
}</programlisting>
<section id="_key_3_genotype_and_phenotype">
<title>Key #3: Genotype and Phenotype</title>
<simpara>The final key to designing your own genetic algorithm relates to how you choose to encode the properties of your system.  What are you trying to express, and how can you translate that expression into a bunch of numbers?   What is the genotype and phenotype?</simpara>
<simpara>When talking about the fitness function, we happily assumed we could create computer-controlled kickers that each had a “set of parameters that determine how they kick a ball towards the goal.”   However, what those parameters are and how you choose to encode them is up to you.</simpara>
<simpara>We started with the Shakespeare example because of how easy it was to design both the genotype (an array of characters) and its expression, the phenotype (the String drawn in the window).</simpara>
<simpara>The good news is—and we hinted at this at the start of this chapter—you’ve really been doing this all along.  Anytime you write a class in Processing, you make a whole bunch of variables.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {
  float maxspeed;
  float maxforce;
  float size;
  float separationWeight;
  [inline]// etc.</programlisting>
<simpara>All we need to do to evolve those parameters is to turn them into an array, so that the array can be used with all of the functions—<emphasis role="strong"><phrase role="function">crossover()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">mutate()</phrase></emphasis>, etc.—found in the DNA class.  One common solution is to use an array of floating point numbers between 0 and 1.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

  // An array of floats
  float[] genes;

  DNA(int num) {
    genes = new float[num];
    for (int i = 0; i &lt; genes.length; i++) {
      // always pick a number between 0 and 1
      genes[i] = float(1);
    }
  }</programlisting>
<simpara>Notice how we’ve now put the genetic data (genotype) and its expression (phenotype) into two separate classes.  The DNA class is the genotype and the Vehicle class uses a DNA object to drive its behaviors and express that data visually—it is the phenotype.  The two can be linked by creating a DNA instance inside the vehicle class itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {
  // A DNA object embedded into the Vehicle class
  DNA dna;

  float maxspeed;
  float maxforce;
  float size;
  float separationWeight;
  // etc.

  Vehicle() {
    DNA = new DNA(4);
    // Using the genes to set variables
    maxspeed = dna.genes[0];
    maxforce = dna.genes[1];
    size = dna.genes[2];
    separationWeight = dna.genes[3];
    // etc.
  }</programlisting>
<simpara>Of course, you most likely don’t want all your variables to have a range between 0 and 1.  But rather than try to remember how to adjust those ranges in the DNA class itself, it’s easier to pull the genetic information from the DNA object and use Processing’s <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function to change the range.  For example, if you want a size variable between 10 and 72, you would say:</simpara>
<programlisting language="java" linenumbering="unnumbered">    size = map(dna.genes[2],0,1,10,72);</programlisting>
<simpara>In other cases, you will want to design a genotype that is an array of objects.   Consider the design of a rocket with a series of “thruster” engines.   You could describe each thruster with a PVector that outlines its direction and relative strength.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

  // The genotype is an array of PVectors.
  PVector[] genes;

  DNA(int num) {
    genes = new float[num];
    for (int i = 0; i &lt; genes.length; i++) {
      float angle = random(TWO_PI);
      // A PVector pointing in a random direction
      genes[i] = new PVector(cos(angle),sin(angle));
      // And scaled randomly
      genes[i].mult(random(10));
    }
  }</programlisting>
<simpara>The phenotype would be a Rocket class that participates in a physics system.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Rocket {
  DNA dna;
  [inline]// etc.</programlisting>
<simpara>What’s great about this technique of dividing the genotype and phenotype into separate classes (DNA and Rocket for example) is that when it comes time to build all of the code, you’ll notice that the DNA class we developed earlier remains intact.   The only thing that changes is the array’s data type (float, PVector, etc.) and the expression of that data in the phenotype class.</simpara>
<simpara>In the next section, we’ll follow this idea a bit further and walk through the necessary steps for an example that involves moving bodies and an array of PVectors as DNA.</simpara>
</section>
</section>
<section id="chapter09_section10">
<title>9.10  Evolving Forces: Smart Rockets</title>
<simpara>We picked the Rocket idea for a specific reason.  In 2009, <ulink url="http://blprnt.com">Jer Thorp</ulink> released a genetic algorithms example on his blog entitled “Smart Rockets.”  Jer points out that NASA uses evolutionary computing techniques to solve all sorts of problems, from satellite antenna design to rocket firing patterns. This inspired him to create a Flash demonstration of evolving rockets.  Here is a description of the scenario:</simpara>
<simpara>A population of rockets launches from the bottom of the screen with the goal of hitting a target at the top of the screen (with obstacles blocking a straight line path).</simpara>
<informalfigure id="chapter09_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_10.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>Figure 9.10</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure id="chapter09_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_11.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.11</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each rocket is equipped with five thrusters of variable strength and direction.    The thrusters don’t fire all at once and continuously; rather, they fire one at a time in a custom sequence.</simpara>
<simpara>In this section, we’re going to evolve our own simplified Smart Rockets, inspired by Jer Thorp’s.   When we get to the end of the section, we’ll leave implementing some of Jer’s additional advanced features as an exercise.</simpara>
<simpara>Our rockets will have only one thruster, and this thruster will be able to fire in any direction with any strength for every frame of animation.  This isn’t particularly realistic, but it will make building out the framework a little easier. (We can always make the rocket and its thrusters more advanced and realistic later.)</simpara>
<simpara>Let’s start by taking our basic Mover class from Chapter 2 examples and renaming it Rocket.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Rocket {

  // A Rocket has three vectors: location, velocity, acceleration.
  PVector location;
  PVector velocity;
  PVector acceleration;

  // Accumulating forces into acceleration (Newton’s 2nd law)
  void applyForce(PVector f) {
    acceleration.add(f);
  }

  // Our simple physics model (Euler integration)
  void update() {
    // Velocity changes according to acceleration.
    velocity.add(acceleration);
    // Location changes according to velocity.
    location.add(velocity);
    acceleration.mult(0);
  }
}</programlisting>
<simpara>Using the above framework, we can implement our smart rocket by saying that for every frame of animation, we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> with a new force.   The “thruster” applies a single force to the rocket each time through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.</simpara>
<simpara>Considering this example, let’s go through the three keys to programming our own custom genetic algorithm example as outlined in the previous section.</simpara>
<simpara><emphasis role="strong"><phrase role="highight">Key #1: Population size and mutation rate</phrase></emphasis></simpara>
<simpara>We can actually hold off on this first key for the moment.  Our strategy will be to pick some reasonable numbers (a population of 100 rockets, mutation rate of 1%) and build out the system, playing with these numbers once we have our sketch up and running.</simpara>
<simpara><emphasis role="strong"><phrase role="highight">Key #2: The fitness function</phrase></emphasis></simpara>
<simpara>We stated the goal of a rocket reaching a target.   In other words, the closer a rocket gets to the target, the higher the fitness.    Fitness is inversely proportional to distance: the smaller the distance, the greater the fitness; the greater the distance, the smaller the fitness.</simpara>
<simpara>Let’s assume we have a PVector target.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void fitness() {
    // How close did we get?
    float d = PVector.dist(location,target);
    // Fitness is inversely proportional to distance.
    fitness = 1/d;
  }</programlisting>
<simpara>This is perhaps the simplest fitness function we could write.  By using one divided by distance, large distances become small numbers and small distances become large.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">distance                       </entry>
<entry align="left" valign="top">1 / distance</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>300</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 300 = 0.0033</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 100 = 0.01</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 5   = 0.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 1   = 1.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0.1</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 0.1 = 10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>And if we wanted to use our exponential trick from the previous section, we could use one divided by distance squared.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">distance                       </entry>
<entry align="left" valign="top">1 / distance           </entry>
<entry align="left" valign="top">(1 / distance)<superscript>2</superscript></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>300</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 400 = 0.0025</simpara></entry>
<entry align="left" valign="top"><simpara>0.00000625</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 100 = 0.01</simpara></entry>
<entry align="left" valign="top"><simpara>0.0001</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 5   = 0.2</simpara></entry>
<entry align="left" valign="top"><simpara>0.04</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 1   = 1.0</simpara></entry>
<entry align="left" valign="top"><simpara>1.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0.1</simpara></entry>
<entry align="left" valign="top"><simpara>1 / 0.1 = 10</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>There are several additional improvements we’ll want to make to the fitness function, but this simple one is a good start.</simpara>
<programlisting language="java" linenumbering="unnumbered">void fitness() {
  float d = PVector.dist(location,target);
  // Squaring 1 divided by distance
  fitness = pow(1/d,2);
}</programlisting>
<simpara><emphasis role="strong"><phrase role="highlight">Key #3: Genotype and Phenotype</phrase></emphasis></simpara>
<simpara>We stated that each Rocket has a thruster that fires in a variable direction with a variable magnitude in each frame.   And so we need a PVector for each frame of animation.  Our genotype, the data required to encode the Rocket’s behavior, is therefore an array of PVectors.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {
  PVector[] genes;</programlisting>
<simpara>The happy news here is that we don’t really have to do anything else to the DNA class.  All of the functionality we developed for the typing monkey (crossover and mutation) applies here.  The one difference we do have to consider is how we initialize the array of genes.  With the typing monkey, we had an array of characters and picked a random character for each element of the array.   Here we’ll do exactly the same thing and initialize a DNA sequence as an array of random PVectors.   Now, your instinct in creating a random PVector might be as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(random(-1,1),random(-1,1));</programlisting>
<informalfigure id="chapter09_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_12.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is perfectly fine and will likely do the trick.  However, if we were to draw every single possible vector we might pick, the result would fill a square (See Figure 9.12)  In this case, it probably doesn’t matter, but there is a slight bias to diagonals here given that a PVector from the center of a square to a corner is longer than a purely vertical or horizontal one.</simpara>
<informalfigure id="chapter09_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_13.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>What would be better here is to pick a random angle and make a PVector of length one from that angle, giving us a circle (See Figure 9.13). This could be easily done with a <link linkend="chapter03_section5">quick polar to Cartesian conversion</link>, but a quicker path to the result is just to use PVector&#8217;s <emphasis role="strong"><phrase role="function">random2D()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (int i = 0; i &lt; genes.length; i++) {
  // Making a PVector from a random angle
  genes[i] = PVector.random2D();
}</programlisting>
<simpara>A PVector of length one is actually going to be quite a large force.  Remember, forces are applied to acceleration, which accumulates into velocity thirty times per second.   So, for this example, we can also add one more variable to the DNA class: a maximum force that scales all the PVectors.    This will control the thruster power.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

  // The genetic sequence is an array of PVectors.
  PVector[] genes;

  // How strong can the thrusters be?
  float maxforce = 0.1;

  DNA() {
    // We need a PVector for every frame of the rocket’s life.
    genes = new PVector[lifetime];
    for (int i = 0; i &lt; genes.length; i++) {
      float angle = random(TWO_PI);
      genes[i] = new PVector(cos(angle), sin(angle));
      // Scaling the PVectors randomly,
      // but no stronger than maximum force
      genes[i].mult(random(0, maxforce));
    }
  }</programlisting>
<simpara>Notice also that we created an array of PVectors with length “lifetime.”   We need a PVector for each frame of the Rocket’s life, and the above assumes the existence of a global variable “lifetime” that stores the total number of frames in each generation’s life cycle.</simpara>
<simpara>The expression of this array of PVectors, the phenotype, is a Rocket class modeled on our basic PVector and forces examples from Chapter 2.   All we need to do is add an instance of a DNA object to the class.  The fitness variable will also live here.   Only the Rocket object knows how to compute its distance to the target, and therefore the fitness function will live here in the phenotype as well.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Rocket {

  // A Rocket has DNA.
  DNA dna;
  // A Rocket has fitness.
  float fitness;

  PVector location;
  PVector velocity;
  PVector acceleration;</programlisting>
<simpara>What are we using the DNA for?  We are marching through the array of PVectors and applying them one at a time as a force to the rocket.  To do this, we’ll also have to add an integer that acts as a counter to walk through the array.</simpara>
<programlisting language="java" linenumbering="unnumbered">  int geneCounter = 0;

  void run() {
    // Apply a force from the genes array.
    applyForce(dna.genes[geneCounter]);
    // Go to the next force in the genes array.
    geneCounter++;
    // Update the Rocket’s physics.
    update();
  }</programlisting>
</section>
<section id="chapter09_section11">
<title>9.11 Smart Rockets: Putting It All Together</title>
<simpara>We now have our DNA class (genotype) and our Rocket class (phenotype).  The last piece of the puzzle is a Population class, which manages an array of Rockets and has the functionality for selection and reproduction.   Again, the happy news here is that we barely have to change anything from the Shakespeare monkey example.  The process for building a mating pool and generating a new array of child Rockets is exactly the same as what we did with our population of Strings.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Population {

  // Population has variables to keep
  // track of mutation rate, current
  // population array, mating pool, and
  // number of generations.
  float mutationRate;
  Rocket[] population;
  ArrayList&lt;Rocket&gt; matingPool;
  int generations;

  // These functions haven’t changed, so
  // no need to go through the code again.
  void fitness() {}
  void selection() {}
  void reproduction() {}</programlisting>
<simpara>There is one fairly significant change, however.   With typing monkeys, a random phrase was evaluated as soon as it was created.  The String of characters had no lifespan; it existed purely for the purpose of calculating its fitness and then we moved on.   The rockets, however, need to live for a period of time before they can be evaluated; they need to be given a chance to make their attempt at reaching the target.   Therefore, we need to add one more function to the Population class that runs the physics simulation itself.   This is identical to what we did in the <emphasis role="strong"><phrase role="function">run()</phrase></emphasis> function of a particle system—update all the particle locations and draw them.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void live () {
    for (int i = 0; i &lt; population.length; i++) {
      // The run function takes care of
      // the forces, updating the Rocket’s
      // location, and displaying it.
      population[i].run();
    }
  }</programlisting>
<simpara>Finally, we’re ready for <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.   Here in the main tab, our primary responsibility is to implement the steps of the genetic algorithm in the appropriate order by calling the functions in the Population class.</simpara>
<programlisting language="java" linenumbering="unnumbered">    population.fitness();
    population.selection();
    population.reproduction();</programlisting>
<simpara>However, unlike the Shakespeare example, we don’t want to do this every frame.  Rather, our steps work as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Create a population of Rockets
</simpara>
</listitem>
<listitem>
<simpara>
Let the Rockets live for N frames
</simpara>
</listitem>
<listitem>
<simpara>
Evolve the next generation
</simpara>
<itemizedlist>
<listitem>
<simpara>
Selection
</simpara>
</listitem>
<listitem>
<simpara>
Reproduction
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Return to step #2
</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_ex02.png" canvas="processingjs/chapter09/_9_02_SmartRockets_superbasic/DNA.pde processingjs/chapter09/_9_02_SmartRockets_superbasic/Population.pde  processingjs/chapter09/_9_02_SmartRockets_superbasic/Rocket.pde processingjs/chapter09/_9_02_SmartRockets_superbasic/_9_02_SmartRockets_superbasic.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter09_example2"><emphasis role="strong"><phrase role="example">Example 9.2: Simple Smart Rockets</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// How many frames does a generation live for?
int lifetime;

// What frame are we on?
int lifeCounter;

// The population
Population population;

void setup() {
  size(640, 480);
  lifetime = 500;
  lifeCounter = 0;

  // Step 1: Create the population.
  // Here is where we could play with
  // the mutation rate and population size.

  float mutationRate = 0.01;
  population = new Population(mutationRate, 50);
}

void draw() {
  background(255);
  // The revised genetic algorithm
  if (lifeCounter &lt; lifetime) {
    // Step 2: The rockets live their
    // life until lifeCounter reaches lifetime.
    population.live();
    lifeCounter++;
  } else {
    // When lifetime is reached, reset
    // lifeCounter and evolve the next
    // generation (Steps 3 and 4,
    // selection and reproduction).
    lifeCounter = 0;
    population.fitness();
    population.selection();
    population.reproduction();
  }
}</programlisting>
<simpara>The above example works, but it isn’t particularly interesting.  After all, the rockets simply evolve to having DNA with a bunch of vectors that point straight upwards.   In the next section, we’re going to talk through two suggested improvements for the example and provide code snippets that implement these improvements.</simpara>
</section>
<section id="chapter09_section12">
<title>9.12 Smarter Rockets</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_ex03.png" canvas="processingjs/chapter09/_9_03_SmartRockets/DNA.pde processingjs/chapter09/_9_03_SmartRockets/Obstacle.pde processingjs/chapter09/_9_03_SmartRockets/Population.pde  processingjs/chapter09/_9_03_SmartRockets/Rocket.pde processingjs/chapter09/_9_03_SmartRockets/_9_03_SmartRockets.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter09_example3"><emphasis role="strong"><phrase role="example">Example 9.3: Smart Rockets</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Improvement #1: Obstacles</phrase></emphasis></simpara>
<simpara>Adding obstacles that the rockets must avoid will make the system more complex and demonstrate the power of the evolutionary algorithm more effectively.  We can make rectangular, stationary obstacles fairly easily by creating a class that stores a location and dimensions.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Obstacle {

  // An obstacle is a location (top left
  // corner of rectangle) with a width and height.
  PVector location;
  float w,h;</programlisting>
<simpara>We can also write a <emphasis role="strong"><phrase role="function">contains()</phrase></emphasis> function that returns true or false to determine if a Rocket has hit the obstacle.</simpara>
<programlisting language="java" linenumbering="unnumbered">  boolean contains(PVector v) {
    if (v.x &gt; location.x &amp;&amp; v.x &lt; location.x + w &amp;&amp; v.y &gt; location.y &amp;&amp; v.y &lt; location.y + h) {
      return true;
    } else {
      return false;
    }
  }</programlisting>
<simpara>Assuming we make an ArrayList of Obstacles, we can then have each Rocket check to see if it has collided with an Obstacle and set a Boolean flag to be true if it does, adding a function to the Rocket class.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // This new function lives in the Rocket
  // class and checks if a Rocket has
  // hit an obstacle.
  void obstacles() {
    for (Obstacle obs : obstacles) {
      if (obs.contains(location)) {
        stopped = true;
      }
    }
  }</programlisting>
<simpara>If the Rocket hits an obstacle, we choose to stop it from updating its location.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void run() {
    // Only run the Rocket if it doesn’t hit an obstacle.
    if (!stopped) { // [bold]
      applyForce(dna.genes[geneCounter]);
      geneCounter = (geneCounter + 1) % dna.genes.length;
      update();
      obstacles(); // [bold]
    }
  }</programlisting>
<simpara>And we also have an opportunity to adjust the Rocket’s fitness.  We consider it to be pretty terrible if the Rocket hits an obstacle, and so its fitness should be greatly reduced.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void fitness() {
    float d = dist(location.x, location.y, target.location.x, target.location.y);
    fitness = pow(1/d, 2);
    if (stopped) fitness *= 0.1; // [bold]
  }</programlisting>
<simpara><emphasis role="strong"><phrase role="highlight">Improvement #2: Evolve reaching the target faster</phrase></emphasis></simpara>
<simpara>If you look closely at our first Smart Rockets example, you’ll notice that the rockets are not rewarded for getting to the target faster.  The only variable in their fitness calculation is the distance to the target at the end of the generation’s life.  In fact, in the event that the rockets get very close to the target but overshoot it and fly past, they may actually be penalized for getting to the target faster.   Slow and steady wins the race in this case.</simpara>
<simpara>We could improve the algorithm to optimize for speed a number of ways.  First, instead of using the distance to the target at the end of the generation, we could use the distance that is the closest to the target at any point during the rocket’s life.  We would call this the Rocket’s “record” distance.  (All of the code snippets in this section live inside the Rocket class.)</simpara>
<programlisting language="java" linenumbering="unnumbered">  void checkTarget() {
    float d = dist(location.x, location.y, target.location.x, target.location.y);
    // Every frame, we check its distance and see
    // if it’s closer than the “record” distance.
    // If it is, we have a new record.
    if (d &lt; recordDist) recordDist = d;</programlisting>
<simpara>In addition, a Rocket should be rewarded according to how quickly it reaches the target.  The faster it reaches the target, the higher the fitness.   The slower, the lower.  To accomplish this, we can increment a counter every cycle of the Rocket’s life until it reaches the target.  At the end of the rocket’s life, the counter will equal the amount of time it took to reach that target.</simpara>
<programlisting language="java" linenumbering="unnumbered">    // If the object reaches the target,
    // set a Boolean flag to true.
    if (target.contains(location)) {
      hitTarget = true;
    } else if (!hitTarget) {
      // As long as we haven’t yet reached
      // the target, keep incrementing the counter.
      finishTime++;
    }
}</programlisting>
<simpara>Fitness is also inversely proportional to finishTime, and so we can improve our fitness function as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void fitness() {

    // Finish time and record distance!
    fitness = (1/(finishTime*recordDist));
    // Make it exponential.
    fitness = pow(fitness, 2);

    if (stopped) fitness *= 0.1;
    // You are rewarded for reaching the target.
    if (hitTarget) fitness *= 2;
  }</programlisting>
<simpara>These improvements are both incorporated into the code for Example 9.3: Smart Rockets.</simpara>
<example id="chapter09_exercise8">
<title>Exercise 9.8</title>
<simpara>Create a more complex obstacle course. As you make it more difficult for the Rockets to reach the target, do you need to improve other aspects of the GA—for example, the fitness function?</simpara>
</example>
<example id="chapter09_exercise9">
<title>Exercise 9.9</title>
<simpara>Implement the rocket firing pattern of Jer Thorp’s Smart Rockets.  Each Rocket only gets five thrusters (of any direction and strength) that follow a firing sequence (of arbitrary length).   Jer’s simulation also gives the Rockets a finite amount of fuel.  To see Jer’s example, visit: <ulink url="http://www.blprnt.com/smartrockets/">http://www.blprnt.com/smartrockets/</ulink></simpara>
</example>
<example id="chapter09_exercise10">
<title>Exercise 9.10</title>
<simpara>Visualize the rockets differently.  Can you draw a line for the shortest path to the target?  Can you add particle systems that act as smoke in the direction of the rocket thrusters?</simpara>
</example>
<example id="chapter09_exercise11">
<title>Exercise 9.11</title>
<simpara>Another way to achieve a similar result is to evolve a flow field.  Can you make the genotype of a Rocket a flow field of PVectors?</simpara>
</example>
<example id="chapter09_exercise12">
<title>Exercise 9.12</title>
<simpara>One of the more famous implementations of genetic algorithms in computer graphics is Karl Sims’ s“Evolved Virtual Creatures.”   In Sims’ work, a population of digital creatures (in a simulated physics environment) are evaluated for their ability to perform tasks, such as swimming, running, jumping, following, and competing for a green cube.</simpara>
</example>
<example id="chapter09_exercise13">
<title>Exercise 9.13</title>
<simpara>One of the innovations in Sims’ s work is a node-based genotype.  In other words, the creature’s DNA is not a linear list of PVectors or numbers, but a map of nodes.  (For an example of this, take a look at <link linkend="chapter05_exercise15">Exercise 5.15</link>, toxiclibs‘ Force Directed Graph example).   The phenotype is the creature’s design itself, a network of limbs connected with muscles.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_exc14.png" classname="half-width" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_exc14.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">[Need final illustration]</phrase></emphasis></simpara>
<simpara>Using toxiclibs or box2d as the physics model, can you create a simplified 2D version of Sims’ s creatures?   For a lengthier description of Sims’ s techniques, I suggest you watch the video and read Sims’ s paper <ulink url="http://www.karlsims.com/evolved-virtual-creatures.html">Virtual Creatures</ulink>.   In addition, you can find a similar example that uses box2d to evolve a “car”: <ulink url="http://boxcar2d.com/">BoxCar2D</ulink>.</simpara>
</example>
</section>
<section id="chapter09_section13">
<title>9.13 Interactive Selection</title>
<simpara>In addition to Evolved Virtual Creatures, Sims is also well-known for his museum installation <emphasis>Galapagos</emphasis>.  Originally installed in the Intercommunication Center in Tokyo in 1997, the installation consists of twelve monitors displaying computer-generated images.  These images evolve over time, following the genetic algorithm steps of selection and reproduction.  The innovation here is not the use of the genetic algorithm itself, but rather the strategy behind the fitness function.    In front of each monitor is a sensor on the floor that can detect the presence of a user viewing the screen.  The fitness of an image is tied to the length of time that viewers look at the image.  This is known as <emphasis>interactive selection</emphasis>, a genetic algorithm with fitness values assigned by users.</simpara>
<simpara>Think of all the rating systems you’ve ever used.  Could you evolve the perfect movie by scoring all films according to your Netflix ratings?  The perfect singer according to American Idol voting?</simpara>
<informalfigure id="chapter09_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_14.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.14</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To illustrate this technique, we’re going to build a population of simple faces.  Each face will have a set of properties: head size, head color, eye location, eye size, mouth color, mouth location, mouth width, and mouth height.</simpara>
<simpara>The face’s DNA (genotype) is an array of floating point numbers between zero and one, with a single value for each property.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

  float[] genes;
  // We need 20 numbers to draw the face.
  int len = 20;

  DNA() {
    genes = new float[len];
    for (int i = 0; i &lt; genes.length; i++) {
      // Each gene is a random float between 0 and 1.
      genes[i] = random(0,1);
    }
  }</programlisting>
<simpara>The phenotype is a Face class that includes an instance of a DNA object.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Face {

  DNA dna;
  float fitness;</programlisting>
<simpara>When it comes time to draw the Face on screen, we can use Processing’s <emphasis role="strong"><phrase role="function">map()</phrase></emphasis> function to convert any gene value to the appropriate range for pixel dimensions or color values. (In this case,  we are also using <emphasis role="strong"><phrase role="function">colorMode()</phrase></emphasis> to set the RGB ranges between zero and one.)</simpara>
<programlisting language="java" linenumbering="unnumbered">  // Using map() to convert the genes to a range for drawing the face
  void display() {
    float r          = map(dna.genes[0],0,1,0,70);
    color c          = color(dna.genes[1],dna.genes[2],dna.genes[3]);
    float eye_y      = map(dna.genes[4],0,1,0,5);
    float eye_x      = map(dna.genes[5],0,1,0,10);
    float eye_size   = map(dna.genes[5],0,1,0,10);
    color eyecolor   = color(dna.genes[4],dna.genes[5],dna.genes[6]);
    color mouthColor = color(dna.genes[7],dna.genes[8],dna.genes[9]);
    float mouth_y    = map(dna.genes[5],0,1,0,25);
    float mouth_x    = map(dna.genes[5],0,1,-25,25);
    float mouthw     = map(dna.genes[5],0,1,0,50);
    float mouthh     = map(dna.genes[5],0,1,0,10);</programlisting>
<simpara>So far, we’re not really doing anything new.  This is what we’ve done in every GA example so far.   What’s new is that we are not going to write a <emphasis role="strong"><phrase role="function">fitness()</phrase></emphasis> function in which the score is computed based on a math formula.   Instead, we are going to ask the user to assign the fitness.</simpara>
<simpara>Now, how best to ask a user to assign fitness is really more of an interaction design problem, and it isn’t really within the scope of this book.    So we’re not going to launch into an elaborate discussion of how to program sliders or build your own hardware dials or build a web app for users to submit online scores.  How you choose to acquire fitness scores is really up to you and the particular application you are developing.</simpara>
<simpara>For this simple demonstration, we’ll increase fitness whenever a user rolls the mouse over a face.  The next generation is created when the user presses a button with an “evolve next generation” label.</simpara>
<simpara>Let’s look at how the steps of the Genetic Algorithm are applied in the main tab, noting how fitness is assigned according to mouse interaction and the next generation is created on a button press.  The rest of the code for checking mouse locations, button interactions, etc. can be found in the accompanying example code.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_ex04.png" canvas="processingjs/chapter09/_9_04_Faces_interactiveselection/Button.pde processingjs/chapter09/_9_04_Faces_interactiveselection/DNA.pde processingjs/chapter09/_9_04_Faces_interactiveselection/Face.pde processingjs/chapter09/_9_04_Faces_interactiveselection/_9_04_Faces_interactiveselection.pde processingjs/chapter09/_9_04_Faces_interactiveselection/Population.pde processingjs/chapter09/_9_04_Faces_interactiveselection/Rectangle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter09_example4"><emphasis role="strong"><phrase role="example">Example 9.4: Interactive selection</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">Population population;
Button button;

void setup() {
  size(780,200);
  float mutationRate = 0.05;
  population = new Population(mutationRate,10);
  button = new Button(15,150,160,20, "evolve new generation");
}

void draw() {

  population.display();
  // The mouse location is passed to
  // the population, which will score
  // each Face according to rollover time.
  population.rollover(mouseX,mouseY); // [bold]
  button.display();
}

void mousePressed() {
  // When a button is pressed,
  // the new generation is created
  // via selection and reproduction.
  if (button.clicked(mouseX,mouseY)) { // [bold]
    population.selection();
    population.reproduction();
  }
}</programlisting>
<simpara>This example, it should be noted, is really just a demonstration of the idea of interactive selection and does not achieve a particularly meaningful result.  For one, we didn’t take much care in the visual design of the faces; they are just a few simple shapes with sizes and colors.  Sims, for example, used more elaborate mathematical functions as his images’ genotype.  You might also consider a vector-based approach, in which a design’s genotype is a set of points and/or paths.</simpara>
<simpara>The more significant problem here, however, is one of time.  In the natural world, evolution occurs over millions of years.  In the computer simulation world of our previous examples, we were able to evolve behaviors relatively quickly because we were producing new generations algorithmically.  In the Shakespeare monkey example, a new generation was born in each frame of animation (approximately sixty per second).   Since the fitness values were computed according to a math formula, we could also have arbitrarily large populations that increased the speed of evolution.  In the case of interactive selection, however, we have to sit and wait for a user to rate each and every member of the population before we can get to the next generation.   A large population would be unreasonably tedious to deal with—not to mention, how many generations could you stand to sit through?</simpara>
<simpara>There are certainly clever solutions around this.  Sims’s Galapagos exhibit concealed the rating process from the users, as it occurred through the normal behavior of looking at artwork in a museum setting.  Building a web application that would allow many users to rate a population in a distributed fashion is also a good strategy for achieving many ratings for large populations quickly.</simpara>
<simpara>In the end, the key to a successful interactive selection system boils down to the same keys we previously established.   What is the genotype and phenotype?  And how do you calculate fitness, which in this case we can revise to say: “What is your strategy for assigning fitness according to user interaction?”</simpara>
<example id="chapter09_exercise14">
<title>Exercise 9.14</title>
<simpara>Build your own interactive selection project.   In addition to a visual design, consider evolving sounds—for example, a short sequence of tones.  Can you devise a strategy, such as a web application or physical sensor system, to acquire ratings from many users over time?</simpara>
</example>
</section>
<section id="chapter09_section14">
<title>9.14  Ecosystem Simulation</title>
<simpara>You may have noticed something a bit odd about every single evolutionary system we’ve built so far in this chapter.   After all, in the real world, a population of babies isn’t born all at the same time.  Those babies don’t then grow up and all reproduce at exactly the same time, then instantly dying to leave the population size perfectly stable.   That would be ridiculous.  Not to mention the fact that there is certainly no one running around the forest with a calculator crunching numbers and assigning fitness values to all the creatures.</simpara>
<simpara>In the real world, we don’t really have “survival of the fittest”; we have “survival of the survivors.”  Things that happen to live longer, for whatever reason, have a greater chance of reproducing.   Babies are born, they live for a while, maybe they themselves have a baby, maybe they don’t, and then they die.</simpara>
<simpara>You won’t necessarily find simulations of “real-world” evolution in artificial intelligence textbooks.  Genetic algorithms are generally used in the more formal manner we outlined in this chapter.   However, since we are reading this book to develop simulations of natural systems, it’s worth looking at some ways we might use a genetic algorithm is something that resembles a living “ecosystem”, much like one we’ve described in the exercises at the end of each chapter.</simpara>
<simpara>Let’s begin by developing a very simple scenario.  We’ll create a creature called a Bloop, a circle that moves about the screen according to Perlin noise.  The creature will have a radius and a maximum speed.  The bigger it is, the slower it moves; the smaller, the faster.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Bloop {
  // A location
  PVector location;

  // Variables for size and speed
  float r;
  float maxspeed;

  // Some variables for Perlin noise calculations
  float xoff, yoff;

  void update() {
    float vx = map(noise(xoff),0,1,-maxspeed,maxspeed);
    float vy = map(noise(yoff),0,1,-maxspeed,maxspeed);
    // A little Perlin noise algorithm to calculate a velocity
    PVector velocity = new PVector(vx,vy);
    xoff += 0.01;
    yoff += 0.01;

    // The Bloop moves
    location.add(velocity);
  }

  // A Bloop is a circle
  void display() {
    ellipse(location.x, location.y, r, r);
  }
}</programlisting>
<simpara>The above is missing a few details (such as initializing the variables in the Constructor), but you get the idea.</simpara>
<simpara>For this example, we’ll want to store the population of Bloops in an ArrayList, rather than an array, as we expect the population to grow and shrink according to how often Bloops die or are born.  We can store this ArrayList in a class called “World,” which will manage all the elements of the Bloops’ world.</simpara>
<programlisting language="java" linenumbering="unnumbered">class World {

  // A list of Bloops
  ArrayList&lt;Bloop&gt; bloops;

  World(int num) {
    bloops = new ArrayList&lt;Bloop&gt;();

    for (int i = 0; i &lt; num; i++) {
      // Making an initial population of Bloops
      bloops.add(new Bloop());
    }
  }</programlisting>
<simpara>So far, what we have is just a rehashing of our ParticleSystem example from Chapter 5.  We have an entity (Bloop) that moves around the window and a class (World) that manages a variable quantity of these entities.   To turn this into a system that evolves, we need to add two additional features to our world:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Bloops die.</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Bloops are born.</emphasis></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>Bloops dying is our replacement for a fitness function, the process of “selection.” If a Bloop dies, it cannot be selected to be a parent, because it simply no longer exists!   One way we can build a mechanism to ensure Bloop deaths into our world is by adding a health variable to the Bloop class.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Bloop {
  // A Bloop is born with 100 health points.
  float health = 100;</programlisting>
<simpara>In each frame of animation, a Bloop loses some health.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {
    // All that other stuff for movement

    // Death is always looming!
    health -= 1;
  }</programlisting>
<simpara>If the health drops below zero, the Bloop dies.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // We add a function to the Bloop class
  // to test if the Bloop is alive or dead.
  boolean dead() {
    if (health &lt; 0.0) {
      return true;
    } else {
      return false;
    }
  }</programlisting>
<simpara>This is a good first step, but we haven’t really achieved anything.  After all, if all Bloops start with 100 health points and lose 1 point per frame, then all Bloops will live for the exact same amount of time and die together.   If every single Bloop lives the same amount of time, they all have equal chances of reproducing and therefore nothing will evolve.</simpara>
<simpara>There are many ways we could achieve variable lifespans with a more sophisticated world.  For example, we could introduce predators that eat Bloops.  Perhaps the faster Bloops would be able to escape being eaten more easily, and therefore our world would evolve to have faster and faster Bloops.  Another option would be to introduce food.  When a Bloop eats food, it increases its health points, and therefore extends its life.</simpara>
<simpara>Let’s assume we have an ArrayList of PVector locations for food, named “food.”  We could test each Bloop’s proximity to each food location.  If the Bloop is close enough, it eats the food (which is then removed from the world) and increases its health.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void eat() {
    for (int i = food.size()-1; i &gt;= 0; i--) {
      PVector foodLocation = food.get(i);
      float d = PVector.dist(location, foodLocation);
      // Is the Bloop close to the food?
      if (d &lt; r/2) {

        // If so, it gets 100 more health points.
        health += 100;
        // The food is no longer available for other Bloops.
        food.remove(i);
      }
    }
  }</programlisting>
<simpara>Now we have a scenario in which Bloops that eat more food live longer and have a greater likelihood of reproducing.  Therefore, we expect that our system would evolve Bloops with an optimal ability to find and eat food.</simpara>
<simpara>Now that we have built our world, it’s time to add the components required for evolution.  First we should establish our genotype and phenotype.</simpara>
<section id="_genotype_and_phenotype">
<title>Genotype and Phenotype</title>
<simpara>The ability for a Bloop to find food is tied to two variables—size and speed.  Bigger Bloops will find food more easily simply because their size will allow them to intersect with food locations more often. And faster Bloops will find more food because they can cover ground more easily.</simpara>
<informalfigure id="chapter09_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_15.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 9.15</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
Since size and speed are inversely related (large Bloops are slow, small Bloops are fast), we only need a genotype with a single number.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

  float[] genes;

  DNA() {
    // It may seem absurd to use an
    // array when all we have is a single
    // value, but we stick with an array in
    // case we want to make more sophisticated Bloops later.
    genes = new float[1];
    for (int i = 0; i &lt; genes.length; i++) {
      genes[i] = random(0,1);
    }
  }</programlisting>
<simpara>The phenotype then is the Bloop itself, whose size and speed is assigned by adding an instance of a DNA object to the Bloop class.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Bloop {
  PVector location;
  float health;

  // A Bloop now has DNA.
  DNA dna;
  float r;
  float maxspeed;

  Bloop(DNA dna_) {
    location = new PVector(width/2,height/2);
    health = 200;
    dna = dna_;

    // maxspeed and r (radius) are mapped
    // to values according to the DNA.
    maxspeed = map(dna.genes[0], 0, 1, 15, 0);
    r        = map(dna.genes[0], 0, 1, 0, 50);
  }</programlisting>
<simpara>Notice that with maxspeed, the range is mapped to between fifteen and zero, meaning a Bloop with a gene value of zero moves at a speed of fifteen and a Bloop with a gene value of one doesn’t move at all (speed of zero).</simpara>
</section>
<section id="_selection_and_reproduction">
<title>Selection and Reproduction</title>
<simpara>Now that we have the genotype and phenotype, we need to move on to devising a means for Bloops to be selected as parents.  We stated before that the longer a Bloop lives, the more chances it has to reproduce.    The length of life is the Bloop’s fitness.</simpara>
<simpara>One option would be to say that whenever two Bloops come into contact with each other, they make a new Bloop.  The longer a Bloop lives, the more likely it is to come into contact with another Bloop.  (This would also affect the evolutionary outcome given that, in addition to eating food, their ability to find other Bloops is a factor in increasing the likelihood of having a baby.)</simpara>
<simpara>A simpler option would be to have “asexual” reproduction, meaning a Bloop does not require a partner.  It can, at any moment, make a clone of itself, another Bloop with the same genetic makeup.   If we state this selection algorithm as follows:</simpara>
<simpara><emphasis role="strong"><emphasis>At any given moment, a Bloop has a 1% chance of reproducing.</emphasis></emphasis></simpara>
<simpara>then the longer a Bloop lives, the more likely it will make at least one child.  This is equivalent to saying the more times you play the lottery, the greater the likelihood you’ll win (though I’m sorry to say your chances of that are still essentially zero).</simpara>
<simpara>To implement this selection algorithm, we can write a function in the Bloop class that picks a random number every frame. If the number is less than 0.01 (1%), a new Bloop is born.</simpara>
<programlisting language="java" linenumbering="unnumbered">  // This function will return a new Bloop, the child.
  Bloop reproduce() {

    // A 1% chance of executing the code in
    // this conditional, i.e. a 1% chance of reproducing
    if (random(1) &lt; 0.01) {
      [inline] // Make the Bloop baby
    }
  }</programlisting>
<simpara>How does a Bloop reproduce?   In our previous examples, the reproduction process involved calling the crossover() function in the DNA class and making a new object from the newly made DNA.  Here, since we are making a child from a single parent, we’ll call a function called <emphasis role="strong"><phrase role="function">copy()</phrase></emphasis> instead.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Bloop reproduce() {
    if (random(1) &lt; 0.0005) {
      // Make a copy of the DNA.
      DNA childDNA = dna.copy(); // [bold]
      // 1% mutation rate
      childDNA.mutate(0.01); // [bold]
      // Make a new Bloop at the same location with the new DNA.
      return new Bloop(location, childDNA); // [bold]

    } else { // [bold]
      // If the Bloop does not
      // reproduce, return null.
      return null; // [bold]
    }
  }</programlisting>
<simpara>Note also that we’ve reduced the probability of reproducing from 1% to 0.05%.  This value makes quite a difference; with a high probability of reproducing, the system will quickly tend towards overpopulation.   Too low a probability, and everything will likely quickly die out.</simpara>
<simpara>Writing the <emphasis role="strong"><phrase role="function">copy()</phrase></emphasis> function into the DNA class is easy since Processing includes a function <emphasis role="strong"><phrase role="function">arraycopy()</phrase></emphasis> that copies the contents of one array into another.</simpara>
<programlisting language="java" linenumbering="unnumbered">class DNA {

  // This copy() function replaces
  // crossover() for this example.
  DNA copy() {

    // Make a new array the same
    // length and copy its contents.
    float[] newgenes = new float[genes.length];
    arraycopy(genes,newgenes);
    return new DNA(newgenes);
  }
}</programlisting>
<simpara>Now that we have all the pieces in place for selection and reproduction, we can finalize the World class that manages the list of all Bloop objects (as well as a Food object, which itself is a list of PVector locations for food).</simpara>
<simpara>Before you run the example, take a moment to guess what size and speed of Bloops the system will evolve towards.  We’ll discuss following the code.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter09/ch09_ex05.png" canvas="processingjs/chapter09/_9_05_EvolutionEcosystem/_9_05_EvolutionEcosystem.pde processingjs/chapter09/_9_05_EvolutionEcosystem/Bloop.pde processingjs/chapter09/_9_05_EvolutionEcosystem/DNA.pde processingjs/chapter09/_9_05_EvolutionEcosystem/Food.pde processingjs/chapter09/_9_05_EvolutionEcosystem/World.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter09/ch09_ex05.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter09_example5"><emphasis role="strong"><phrase role="example">Example 9.5: Evolution Ecosystem</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">World world;

// setup() and draw() do nothing more than create
// and run a World object.
void setup() {
  size(600,400);
  world = new World(20);
}

void draw() {
  background(255);
  world.run();
}

class World {

  // The World object keeps track of the
  // population Bloops as well as the food.
  ArrayList&lt;Bloop&gt; bloops;
  Food food;

  World(int num) {
    food = new Food(num);
    bloops = new ArrayList&lt;Bloop&gt;();

    // Creating the population
    for (int i = 0; i &lt; num; i++) {
      PVector location = new PVector(random(width),random(height));
      DNA dna = new DNA();
      bloops.add(new Bloop(l,dna));
    }
  }

  void run() {
    food.run();

    for (int i = bloops.size()-1; i &gt;= 0; i--) {
      // The Bloops live their life.
      Bloop b = bloops.get(i);
      b.run();
      b.eat(food);
      // If one dies, it is removed from
      // the population and food is added
      // at its location.
      if (b.dead()) {
        bloops.remove(i);
        food.add(b.location);
      }

      // Here is where each living Bloop has
      // a chance to reproduce.  As long as a
      // child is made (i.e. not null) it is
      // added to the population.
      Bloop child = b.reproduce();
      if (child != null) bloops.add(child);
    }
  }
}</programlisting>
<simpara>If you guessed medium-sized Bloops with medium speed, you were right.   With the design of this system, Bloops that are large are simply too slow to find food.  And Bloops that are fast are too small to find food.   The ones that are able to live the longest tend to be in the middle, large enough and fast enough to find food (but not too large or too fast).  There are also some anomalies.     For example, if it so happens that a bunch of large Bloops end up in the same location (and barely move because they are so large) they may all die out suddenly, leaving a lot of food for one large Bloop who happens to be there to eat and allowing a mini-population of large Bloops to sustain themselves for a period of time in one location.</simpara>
<simpara>This example is rather simplistic given its single gene and asexual reproduction.   Here are some suggestions for how you might apply the Bloop example in a more elaborate ecosystem simulation, such as the one suggested as a project at the end of each chapter.</simpara>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 9 Exercise:</simpara>
<simpara>Add evolution to your ecosystem, building from the examples in this chapter.</simpara>
<itemizedlist>
<listitem>
<simpara>
Add a population of predators in your ecosystem.   Biological evolution between predators and prey (or parasites and hosts) is often referred to as an “arms race,” in which the creatures continuously adapt and counter-adapt to each other.   Can you achieve this behavior in a system of multiple creatures?
</simpara>
</listitem>
<listitem>
<simpara>
How would you implement crossover and mutation between two parents in an ecosystem modeled after the Bloops?  Try implementing an algorithm so that two creatures meet and mate when within a certain proximity.   Can you make creatures with gender?
</simpara>
</listitem>
<listitem>
<simpara>
Try using the weights of multiple steering forces as a creature’s DNA.   Can you create a scenario in which creatures evolve to cooperate with each other?
</simpara>
</listitem>
<listitem>
<simpara>
One of the greatest challenges in ecosystem simulations is achieving a nice balance.  You will likely find that most of your attempts result in either mass overpopulation (followed by mass extinction) or simply mass extinction straight away.  What techniques can you employ to achieve balance?  Consider using the genetic algorithm itself to evolve optimal parameters for an ecosystem.
</simpara>
</listitem>
</itemizedlist>
</tip>
</section>
</section>
</chapter>
<chapter id="_chapter_10_neural_networks">
<title>Chapter 10.  Neural Networks</title>
<blockquote>
<attribution>
Charlie Sheen
</attribution>
<simpara>“You can&#8217;t process me with a normal brain.”</simpara>
</blockquote>
<simpara>We’re at the end of our story.   This is the last “official” chapter of this book (though I envision additional supplemental material for the web site and perhaps other new chapters in the future).    We began with inanimate objects living in a world of forces and gave those objects desires, autonomy, and the ability to take action according to a system of rules.  Next, we allowed those objects to live in a population and evolve over time.  Now we ask: What is each object’s decision-making process?  How can it adjust its choices by learning over time?  Can a computational entity process its environment and generate a decision?</simpara>
<simpara>The human brain can be described as a biological neural network—an interconnected web of neurons transmitting elaborate patterns of electrical signals.   Dendrites receive input signals and, based on those inputs, fire an output signal via an axon.  Or something like that.  How the human brain actually works is an elaborate and complex mystery, one that we certainly are not going to attempt to tackle in rigorous detail in this chapter.</simpara>
<informalfigure id="chapter10_figure1">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_01.png" />
  </imageobject>
  <textobject><phrase>Figure 10.1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The good news is that developing engaging animated systems with code does not required scientific rigor or accuracy, as we’ve learned throughout this book.   We can simply be inspired by the idea of brain function.</simpara>
<simpara>In this chapter, we’ll begin with a conceptual overview of the properties and features of neural networks and build the simplest possible example of one (a network that consists of a single neuron).  Afterwards, we’ll examine strategies for creating a “Brain” object that can be inserted into our Vehicle class and used to determine steering.   Finally, we’ll also look at techniques for visualizing and animating a network of neurons.</simpara>
<section id="chapter10_section1">
<title>10.1 Artificial Neural Networks: Introduction and Application</title>
<simpara>Computer scientists have long been inspired by the human brain.   In 1943, Warren S. McCulloch, a neuroscientist, and Walter Pitts, a logician, developed the first conceptual model of an artificial neural network.  In their paper, "A logical calculus of the ideas imminent in nervous activity,” they describe the concept of a neuron, a single cell living in a network of cells that receives inputs, processes those inputs, and generates an output.</simpara>
<simpara>Their work, and the work of many scientists and researchers that followed, was not meant to accurately describe how the biological brain works.  Rather, an artificial neural network (which we will now simply refer to as a “neural network”) was designed as a computational model based on the brain to solve certain kinds of problems.</simpara>
<simpara>It’s probably pretty obvious to you that there are problems that are incredibly simple for a computer to solve, but difficult for you.  Take the square root of 964,324, for example.  A quick line of code produces the value 982, a number Processing computed in less than a millisecond.   There are, on the other hand, problems that are incredibly simple for you or me to solve, but not so easy for a computer.   Show any toddler a picture of a kitten or puppy and they’ll be able to tell you very quickly which one is which.   Say hello and shake my hand one morning and you should be able to pick me out of a crowd of people the next day.  But need a machine to perform one of these tasks?  Scientists have already spent careers researching and implementing complex solutions.</simpara>
<simpara>The most common application of neural networks in computing today is to perform one of these “easy-for-a-human, difficult-for-a-machine” tasks, often referred to as pattern recognition.   Applications range from optical character recognition (turning printed or handwritten scans into digital text) to facial recognition.  We don’t have the time or need to use some of these more elaborate artificial intelligence algorithms here, but if you are interested in researching neural networks, I’d recommend the books <emphasis>Artificial Intelligence: A Modern Approach</emphasis> by Stuart J. Russell and Peter Norvig and <emphasis>AI for Game Developers</emphasis> by David M. Bourg and Glenn Seemann.</simpara>
<informalfigure id="chapter10_figure2">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_02.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 10.2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>A neural network is a “connectionist” computational system.   The computational systems we write are procedural; a program starts at the first line of code, executes it, and goes onto the next, following instructions in a linear fashion.   A true neural network does not follow a linear path.  Rather, information is processed collectively, in parallel throughout a network of nodes (the nodes, in this case, being neurons).</simpara>
<simpara>Here we have yet another example of a complex system, much like the ones we examined in chapters six, seven, and eight.   The individual elements of the network, the neurons, are incredibly simple.  They read an input, process it, and generate an output.   A network of many neurons, however, can exhibit incredibly rich and intelligent behaviors.</simpara>
<simpara>One of the key elements of a neural network is its ability to <emphasis role="strong"><emphasis>learn</emphasis></emphasis>.  A neural network is not just a complex system, but a complex <emphasis role="strong"><emphasis>adaptive</emphasis></emphasis> system, meaning it can change its internal structure based on the information flowing through it.  Typically, this is achieved through the adjusting of <emphasis role="strong"><emphasis>weights</emphasis></emphasis>.  In the diagram above, each line represents a connection between two neurons and indicates the pathway for the flow of information.    Each connection has a weight, a number that controls the signal between the two neurons.   If the network generates a “good” output (which we’ll define later), there is no need to adjust the weights. However, if the network generates a “poor” output—an error, so to speak—then the system adapts, altering the weights in order to improve subsequent results.</simpara>
<simpara>There are several strategies for learning, and we’ll examine two of them in this chapter.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Supervised Learning</emphasis></emphasis> —Essentially, a strategy that involves a teacher that is smarter than the network itself.  For example, let’s take the facial recognition example.  The teacher shows the network a bunch of faces, and the teacher already knows the name associated with each face.  The network makes its guesses, then the teacher provides the network with the answers.   The network can then compare its answers to the known “correct” ones and make adjustments according to its errors.  Our first neural network in the next section will follow this model.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Unsupervised Learning</emphasis></emphasis> —Required when there isn’t an example data set with known answers.    Imagine searching for a hidden pattern in a data set.   An application of this is clustering, i.e. dividing a set of elements into groups according to some unknown pattern.   We won’t be looking at any examples of unsupervised learning in this chapter, as this strategy is less relevant for our examples.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Reinforcement Learning</emphasis></emphasis> —A strategy built on observation.   Think of a little mouse running through a maze. If it turns left, it gets a piece of cheese; if it turns right, it receives a little shock. (Don’t worry, this is just a pretend mouse.)   Presumably, the mouse will learn over time to turn left.  Its neural network makes a decision with an outcome (turn left or right) and observes its environment (yum or ouch).   If the observation is negative, the network can adjust its weights in order to make a different decision the next time.    Reinforcement learning is common in robotics.  At time t, the robot performs a task and observes the results.   Did it crash into a wall or fall off a table?  Or is it unharmed?  We’ll look at reinforcement learning in the context of our simulated steering vehicles.
</simpara>
</listitem>
</itemizedlist>
<simpara>This ability of a neural network to learn, to make adjustments to its structure over time, is what makes it so useful in the field of artificial intelligence.  Here are some standard uses of neural networks in software today.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Pattern Recognition</emphasis></emphasis> —We’ve mentioned this several times already and it’s probably the most common application.   Examples are facial recognition, optical character recognition, etc.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Time Series Prediction</emphasis></emphasis> —Neural networks can be used to make predictions.  Will the stock rise or fall tomorrow?  Will it rain or be sunny?
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Signal Processing</emphasis></emphasis> —Cochlear implants and hearing aids need to filter out unnecessary noise and amplify the important sounds.   Neural networks can be trained to process an audio signal and filter it appropriately.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Control</emphasis></emphasis> —You may have read about recent research advances in self-driving cars.   Neural networks are often used to manage steering decisions of physical vehicles (or simulated ones).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Soft Sensors</emphasis></emphasis> —A soft sensor refers to the process of analyzing a collection of many measurements.   A thermometer can tell you the temperature of the air, but what if you also knew the humidity, barometric pressure, dew point, air quality, air density, etc.?  Neural networks can be employed to process the input data from many individual sensors and evaluate them as a whole.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Anomaly Detection</emphasis></emphasis> —Because neural networks are so good at recognizing patterns, they can also be trained to generate an output when something occurs that doesn’t fit the pattern.  Think of a neural network monitoring your daily routine over a long period of time.  After learning the patterns of your behavior, it could alert you when something is amiss.
</simpara>
</listitem>
</itemizedlist>
<simpara>This is by no means a comprehensive list of applications of neural networks.   But hopefully it gives you an overall sense of the features and possibilities.   The thing is, neural networks are complicated, and difficult.  They involve all sorts of fancy mathematics.   While this is all fascinating (and incredibly important to scientific research), a lot of the techniques are not very practical in the world of building interactive, animated Processing sketches.   Not to mention that in order to cover all this material, we would need another book—or more likely, a series of books.</simpara>
<simpara>So instead, we’ll begin our last hurrah in the nature of code with the simplest of all neural networks in order to understand the how the overall concepts are applied in code.  Then we’ll look at some Processing sketches that generate visual results inspired by these concepts.</simpara>
</section>
<section id="chapter10_section2">
<title>10.2  The Perceptron</title>
<simpara>Invented in 1957 at the Cornell Aeronautical Laboratory by Frank Rosenblatt, a perceptron is the simplest neural network possible.   A computational model of a single neuron, a perceptron consists of one or more inputs, a processor, and a single output.</simpara>
<informalfigure id="chapter10_figure3">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_03.png" />
  </imageobject>
  <textobject><phrase>Figure 10.3: The Perceptron</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
A perceptron follows the “feed-forward” model, meaning inputs are sent into the neuron, are processed, and result in an output.  In the diagram above, this means the network (one neuron) reads from left to right: inputs come in, output goes out.</simpara>
<simpara>Let’s follow each of these steps in more detail.</simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Step 1: Receive inputs.</phrase></emphasis></simpara>
<simpara>Say we have a perceptron with two inputs—let’s call them x1 and x2.</simpara>
<simpara><emphasis role="strong"><phrase role="mono">Input 0:         x1 = 12<?asciidoc-br?>
Input 1:        x2 = 4</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Step 2: Weight inputs.</phrase></emphasis></simpara>
<simpara>Each input that is sent into the neuron must first be weighted, i.e. multiplied by some value (often a number between -1 and 1).   When creating a perceptron, we’ll typically begin by assigning random weights.  Here, let’s give the inputs the following weights:</simpara>
<simpara><emphasis role="strong"><phrase role="mono">Weight 0: 0.5<?asciidoc-br?>
Weight 1: -1</phrase></emphasis></simpara>
<simpara>We take each input and multiply it by its weight.</simpara>
<simpara><emphasis role="strong"><phrase role="mono">Input 0 <literal>*</literal> Weight 0 &#8658; 12 <literal>*</literal> 0.5 = 6</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="mono">Input 1 <literal>*</literal> Weight 1 &#8658; 4 <literal>*</literal> -1 = -4</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Step 3: Sum inputs.</phrase></emphasis></simpara>
<simpara>The weighted inputs are then summed.</simpara>
<simpara><emphasis role="strong"><phrase role="mono">Sum = 6 + -4 = 2</phrase></emphasis></simpara>
<simpara><emphasis role="strong"><phrase role="highlight">Step 4: Generate output.</phrase></emphasis></simpara>
<simpara>The output of a perceptron is generated by passing that sum through an activation function.    In the case of a simple binary output, the activation function is what tells the perceptron whether to “fire” or not.   You can envision an LED connected to the output signal: if it fires, the light goes on; if not, it stays off.</simpara>
<simpara>Activation functions can get a little bit hairy.   If you start reading one of those artificial intelligence textbooks looking for more info about activation functions, you may soon find yourself reaching for a calculus textbook.    However, with our friend the simple perceptron, we’re going to do something really easy.  Let’s make the activation function the sign of the sum.   In other words, if the sum is a positive number, the output is 1; if it is negative, the output is -1.</simpara>
<simpara><emphasis role="strong"><phrase role="mono">Output = sign(sum) &#8658; sign(2) &#8658; +1</phrase></emphasis></simpara>
<simpara>Let’s review and condense these steps so we can implement them with a code snippet.</simpara>
<simpara><emphasis role="strong"><emphasis>The Perceptron Algorithm:</emphasis></emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
For every input, multiply that input by its weight.
</simpara>
</listitem>
<listitem>
<simpara>
Sum all of the weighted inputs.
</simpara>
</listitem>
<listitem>
<simpara>
Compute the output of the perceptron based on that sum passed through an activation function (the sign of the sum).
</simpara>
</listitem>
</orderedlist>
<simpara>Let’s assume we have two arrays of numbers, the inputs and the weights.   For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">float[] inputs  = {12 , 4};
float[] weights = {0.5,-1};</programlisting>
<simpara>“For every input” implies a loop that multiplies each input by its corresponding weight.  Since we need the sum, we can add up the results in that very loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Steps 1 and 2: Add up
// all the weighted inputs.
float sum = 0;
for (int i = 0; i &lt; inputs.length; i++) {
  sum += inputs[i]*weights[i];
}</programlisting>
<simpara>Once we have the sum we can compute the output.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Step 3: Passing the sum
// through an activation function
float output = activate(sum);

// The activation function
int activate(float sum) {
  // Return a 1 if positive, -1 if negative.
  if (sum &gt; 0) return 1;
  else return -1;
}</programlisting>
</section>
<section id="chapter10_section3">
<title>10.3  Simple Pattern Recognition Using a Perceptron</title>
<simpara>Now that we understand the computational process of a perceptron, we can look at an example of one in action.   We stated that neural networks are often used for pattern recognition applications, such as facial recognition.   Even simple perceptrons can demonstrate the basics of classification.  Let’s take the following example:</simpara>
<informalfigure id="chapter10_figure4">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_04.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 10.4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Consider a line in two-dimensional space. Points in that space can be classified as living on either one side of the line or another. While this is a somewhat silly example (since there is clearly no need for a neural network; we can determine on which side a point lies with some simple algebra), it shows how a perceptron can be trained to recognize points on one side versus another.</simpara>
<simpara>Let’s say a perceptron has 2 inputs (the x and y coordinates of a point). Using a sign activation function, the output will either be a -1 or 1—i.e., the input data is classified according to the sign of the output.  In the above diagram, we can see how each point is either below the line (-1) or above (+1).</simpara>
<simpara>The perceptron itself can be diagrammed as follows:</simpara>
<informalfigure id="chapter10_figure5">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_05.png" />
  </imageobject>
  <textobject><phrase>Figure 10.5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We can see how there are two inputs (x and y), a weight for each input (weight<subscript>x</subscript> and weight<subscript>y</subscript>), as well as a processing neuron that generates the output.</simpara>
<simpara>There is a pretty significant problem here, however.  Let’s consider the point (0,0).  What if we send this point into the perceptron as its input:  x = 0 and y = 0?  What will the sum of its weighted inputs be?  No matter what the weights are, the sum will always be 0!  But this can’t be right—after all, the point (0,0) could certainly be above or below various lines in our two-dimensional world.</simpara>
<simpara>To avoid this dilemma, our perceptron will require a third input, typically referred to as a <emphasis role="strong"><emphasis>bias</emphasis></emphasis> input.   A bias input always has the value of 1 and is also weighted.  Here is our perceptron with the addition of the bias:</simpara>
<informalfigure id="chapter10_figure6">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_06.png" />
  </imageobject>
  <textobject><phrase>Figure 10.6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let’s go back to the point (0,0).   Here are our inputs:</simpara>
<simpara><emphasis role="strong"><phrase role="mono">0 <literal>*</literal> weight for x = 0<?asciidoc-br?>
0 <literal>*</literal> weight for y = 0<?asciidoc-br?>
1 <literal>*</literal> weight for bias = weight for bias</phrase></emphasis></simpara>
<simpara>The output is the sum of the above three values, zero plus zero plus the bias’s weight.  The bias therefore, on its own, answers the question as to where (0,0) is in relation to the line.  If the bias’s weight is positive, (0,0) is above the line, negative it is below.   It “biases” the perceptron’s understanding of the line’s position relative to (0,0).</simpara>
</section>
<section id="chapter10_section4">
<title>10.4  Coding the Perceptron</title>
<simpara>We’re now ready to assemble the code for a Perceptron class.  The only data the perceptron needs to track are the input weights, and we could use an array of floats to store these.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Perceptron {
  float[] weights;</programlisting>
<simpara>The constructor could receive an argument indicating the number of inputs (in this case three: x, y, and a bias) and size the array accordingly.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Perceptron(int n) {
    weights = new float[n];
    for (int i = 0; i &lt; weights.length; i++) {
      // The weights are picked randomly to start.
      weights[i] = random(-1,1);
    }
  }</programlisting>
<simpara>A perceptron needs to be able to receive inputs and generate an output.  We can package these requirements into a function called <emphasis role="strong"><phrase role="function">feedforward()</phrase></emphasis>.   In this example, we’ll have the perceptron receive its inputs as an array (which should be the same length as the array of weights) and return the output as an <emphasis>int</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">  int feedforward(float[] inputs) {
    float sum = 0;
    for (int i = 0; i &lt; weights.length; i++) {
      sum += inputs[i]*weights[i];
    }
    // Result is the sign of the sum, -1 or +1.
    // Here the Perceptron is making a guess.
    // Is it on one side of the line or the other?
    return activate(sum);
  }</programlisting>
<simpara>Presumably, we could now create a Perceptron object and ask it to make a guess for any given point:</simpara>
<informalfigure id="chapter10_figure7">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_07.png" />
  </imageobject>
  <textobject><phrase>Figure 10.7</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">// Create the Perceptron.
Perceptron p = new Perceptron(3);
// The input is 3 values: x,y and bias.
float[] point = {50,-12,1};
// The answer!
int result = p.feedforward(point);</programlisting>
<simpara>Did the perceptron get it right?    At this point, the perceptron has no better than a 50/50 chance of arriving at the right answer.  Remember, when we created it, we gave each weight a random value.    A neural network isn’t magic.   It’s not going to be able to guess anything correctly unless we teach it how to!</simpara>
<simpara>To train a neural network to answer correctly, we’re going to employ the method of <emphasis>supervised learning</emphasis> that we described in <link linkend="chapter10_section1">section 10.1</link>.</simpara>
<simpara>With this method, the network is provided with inputs for which there is a known answer.  This way the network can find out if it has made a correct guess.  If it’s incorrect, the network can learn from its mistake and adjust its weights.  The process is as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Provide the perceptron with inputs for which there is a known answer.
</simpara>
</listitem>
<listitem>
<simpara>
Ask the perceptron to guess an answer.
</simpara>
</listitem>
<listitem>
<simpara>
Compute the error.  (Did it get the answer right or wrong?)
</simpara>
</listitem>
<listitem>
<simpara>
Adjust all the weights according to the error.
</simpara>
</listitem>
<listitem>
<simpara>
Return to Step 1 and repeat!
</simpara>
</listitem>
</orderedlist>
<simpara>Steps 1 through 4 can be packaged into a function.  Before we can write the entire function, however, we need to examine Steps 3 and 4 in more detail.  How do we define the perceptron’s error?  And how should we adjust the weights according to this error?</simpara>
<simpara>The perceptron’s error can be defined as the difference between the desired answer and its guess.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">ERROR = DESIRED OUTPUT - GUESS OUTPUT</phrase></emphasis></simpara>
<simpara>The above formula may look familiar to you.  In <link linkend="chapter06_section3">Chapter 6</link>, we computed a steering force as the difference between our desired velocity and our current velocity.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">STEERING = DESIRED VELOCITY - CURRENT VELOCITY</phrase></emphasis></simpara>
<simpara>This was also an error calculation.  The current velocity acts as a guess and the error (the steering force) tells us how to adjust the velocity in the right direction.   In a moment, we’ll see how adjusting the vehicle’s velocity to follow a target is just like adjusting the weights of a neural network to arrive at the right answer.</simpara>
<simpara>In the case of the perceptron, the output has only two possible values: <emphasis role="strong"><emphasis>+1</emphasis></emphasis> or <emphasis role="strong"><emphasis>-1</emphasis></emphasis>.   This means there are only three possible errors.</simpara>
<simpara>If the perceptron guesses the correct answer, then the guess equals the desired output and the error is zero.  If the correct answer is -1 and we’ve guessed +1, then the error is -2.  If the correct answer is +1 and we’ve guessed -1, then the error is +2.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Desired        </entry>
<entry align="left" valign="top">Guess  </entry>
<entry align="left" valign="top">Error</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>-1</simpara></entry>
<entry align="left" valign="top"><simpara>-1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>-1</simpara></entry>
<entry align="left" valign="top"><simpara>+1</simpara></entry>
<entry align="left" valign="top"><simpara>-2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+1</simpara></entry>
<entry align="left" valign="top"><simpara>-1</simpara></entry>
<entry align="left" valign="top"><simpara>+2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>+1</simpara></entry>
<entry align="left" valign="top"><simpara>+1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The error is the determining factor in how the perceptron’s weights should be adjusted.   For any given weight, what we are looking to calculate is the change in weight, often called Δweight (or “delta” weight, delta being the Greek letter Δ).</simpara>
<simpara><emphasis role="strong"><phrase role="formula">NEW WEIGHT = WEIGHT + ΔWEIGHT</phrase></emphasis></simpara>
<simpara>Δweight is calculated as the error multiplied by the input.</simpara>
<simpara><emphasis role="strong"><phrase role="formula">ΔWEIGHT = ERROR <literal>*</literal> INPUT</phrase></emphasis></simpara>
<simpara>Therefore:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">NEW WEIGHT = WEIGHT + ERROR <literal>*</literal> INPUT</phrase></emphasis></simpara>
<simpara>To understand why this works, we can again return to <link linkend="chapter06_section3">steering</link>.  A steering force is essentially an error in velocity.  If we apply that force as our acceleration (Δvelocity), then we adjust our velocity to move in the correct direction.  This is what we want to do with our neural network’s weights.  We want to adjust them in the right direction, as defined by the error.</simpara>
<simpara>With steering, however, we had an additional variable that controlled the vehicle’s ability to steer: the <emphasis>maximum force</emphasis>.   With a high maximum force, the vehicle was able to accelerate and turn very quickly; with a lower force, the vehicle would take longer to adjust its velocity.  The neural network will employ a similar strategy with a variable called the “learning constant.”  We’ll add in the learning constant as follows:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">NEW WEIGHT = WEIGHT + ERROR <literal>*</literal> INPUT <literal>*</literal> LEARNING CONSTANT</phrase></emphasis></simpara>
<simpara>Notice that a high learning constant means the weight will change more drastically.  This may help us arrive at a solution more quickly, but with such large changes in weight it’s possible we will overshoot the optimal weights.  With a small learning constant, the weights will be adjusted slowly, requiring more training time but allowing the network to make very small adjustments that could improve the network’s overall accuracy.</simpara>
<simpara>Assuming the addition of a variable “c” for learning constant, we can now write a training function for the perceptron following the above steps.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A new variable is introduced
// to control the learning rate.
float c = 0.01;

// Step 1: Provide the inputs and known answer.
// These are passed in as arguments to train().
void train(float[] inputs, int desired) {

  // Step 2: Guess according to those inputs.
  int guess = feedforward(inputs);

  // Step 3: Compute the error (difference
  // between answer and guess).
  float error = desired - guess;

  // Step 4: Adjust all the weights according
  // to the error and learning constant.
  for (int i = 0; i &lt; weights.length; i++) {
    weights[i] += c * error * inputs[i];
  }
}</programlisting>
<simpara>We can now see the Perceptron class as a whole.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Perceptron {
  // The Perceptron stores its weights and learning constants.
  float[] weights;
  float c = 0.01;

  Perceptron(int n) {
    weights = new float[n];
    // Weights start off random.
    for (int i = 0; i &lt; weights.length; i++) {
      weights[i] = random(-1,1);
    }
  }

  // Return an output based on inputs.
  int feedforward(float[] inputs) {
    float sum = 0;
    for (int i = 0; i &lt; weights.length; i++) {
      sum += inputs[i]*weights[i];
    }
    return activate(sum);
  }

  // Output is a +1 or -1.
  int activate(float sum) {
    if (sum &gt; 0) return 1;
    else return -1;
  }

  // Train the network against known data.
  void train(float[] inputs, int desired) {
    int guess = feedforward(inputs);
    float error = desired - guess;
    for (int i = 0; i &lt; weights.length; i++) {
      weights[i] += c * error * inputs[i];
    }
  }
}</programlisting>
<simpara>To train the perceptron, we need a set of inputs with a known answer.   We could package this up in a class like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Trainer {

  // A "Trainer" object stores the inputs and the correct answer.
  float[] inputs;
  int answer;

  Trainer(float x, float y, int a) {
    inputs = new float[3];
    inputs[0] = x;
    inputs[1] = y;
    // Note the Trainer has the bias input built into its array.
    inputs[2] = 1;
    answer = a;
  }
}</programlisting>
<simpara>Now the question becomes, how do we pick a point and know whether it is above or below a line?   Let’s start with the formula for a line, where y is calculated as a function of x:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">y = f(x)</phrase></emphasis></simpara>
<simpara>In generic terms, a line can be described as:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">y = ax + b</phrase></emphasis></simpara>
<simpara>Here’s a specific example:</simpara>
<simpara><emphasis role="strong"><phrase role="formula">y = 2*x + 1</phrase></emphasis></simpara>
<simpara>We can then write a Processing function with this in mind.</simpara>
<programlisting language="java" linenumbering="unnumbered">// A function to calculate y based on x along a line
float f(float x) {
  return 2*x+1;
}</programlisting>
<simpara>So, if we make up a point:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = random(width);
float y = random(height);</programlisting>
<simpara>How do we know if this point is above or below the line?   The line function <emphasis role="strong"><phrase role="function">f(x)</phrase></emphasis> gives gives us the y value on the line for that x position.  Let’s call that yline.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The y position on the line
float yline = f(x);</programlisting>
<simpara>If the y value we are examining is above the line, it will be less than yline.</simpara>
<informalfigure id="chapter10_figure8">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_08.png" />
  </imageobject>
  <textobject><phrase>Figure 10.8</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">if (y &lt; yline) {
  // The answer is -1 if y is above the line.
  answer = -1;
} else {
  answer = 1;
}</programlisting>
<simpara>We can then make a Trainer object with the inputs and the correct answer.</simpara>
<programlisting language="java" linenumbering="unnumbered">Trainer t = new Trainer(x, y, answer);</programlisting>
<simpara>Assuming we had a Perceptron object “ptron,” we could then train it by sending the inputs along with the known answer.</simpara>
<programlisting language="java" linenumbering="unnumbered">ptron.train(t.inputs,t.answer);</programlisting>
<simpara>Now, it’s important to remember that this is just a demonstration.  Remember our <link linkend="chapter09_section2">Shakespearean typing monkeys</link>?  We asked our genetic algorithm to solve for an answer we already knew—“to be or not to be.”  We did this to make sure our genetic algorithm worked properly.  The same reasoning applies to this example.  We don’t need a perceptron to tell us whether a point is above or below a line, we can do that with simple math.   We are using this scenario, one that we can easily solve without a perceptron, to demonstrate the perceptron’s algorithm as well as easily confirm that it is working properly.</simpara>
<simpara>Let’s look at how the perceptron works with an array of many training points.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_ex01.png" canvas="processingjs/chapter10/_10_01_SimplePerceptron/_10_01_SimplePerceptron.pde processingjs/chapter10/_10_01_SimplePerceptron/Perceptron.pde processingjs/chapter10/_10_01_SimplePerceptron/Trainer.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter10/ch10_ex01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter10_example1"><emphasis role="strong"><phrase role="example">Example 10.1: The Perceptron</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">// The Perceptron
Perceptron ptron;
// 2,000 training points
Trainer[] training = new Trainer[2000];
int count = 0;

// The formula for a line
float f(float x) {
  return 2*x+1;
}

void setup() {
  size(400, 400);

  ptron = new Perceptron(3);

  // Make 2,000 training points.
  for (int i = 0; i &lt; training.length; i++) {
    float x = random(-width/2,width/2);
    float y = random(-height/2,height/2);
    int answer = 1;
    // Is the correct answer 1 or -1?
    if (y &lt; f(x)) answer = -1;
    training[i] = new Trainer(x, y, answer);
  }
}


void draw() {
  background(255);
  translate(width/2,height/2);

  ptron.train(training[count].inputs, training[count].answer);
  // For animation, we are training one point at a time.
  count = (count + 1) % training.length;

  for (int i = 0; i &lt; count; i++) {
    stroke(0);
    int guess = ptron.feedforward(training[i].inputs);
    // Show the classification—noFill() for -1, fill(0) for +1.
    if (guess &gt; 0) noFill();
    else           fill(0);
    ellipse(training[i].inputs[0], training[i].inputs[1], 8, 8);
  }
}</programlisting>
<example id="chapter10_exercise1">
<title>Exercise 10.1</title>
<simpara>Instead of using the supervised learning model above, can you train the neural network to find the right weights by using a genetic algorithm?</simpara>
</example>
<example id="chapter10_exercise2">
<title>Exercise 10.2</title>
<simpara>Visualize the Perceptron itself. Draw the inputs, the processing node, and the output.</simpara>
</example>
</section>
<section id="chapter10_section5">
<title>10.5  A Steering Perceptron</title>
<simpara>While classifying points according to their position above or below a line was a useful demonstration of the Perceptron in action, it doesn’t have much practical relevance to the other examples throughout this book.  In this section, we’ll take the concepts of a Perceptron (array of inputs, single output), apply it to steering behaviors, and demonstrate reinforcement learning along the way.</simpara>
<simpara>We are now going to take significant creative license with the concept of a neural network. This will allow us to stick with the basics and avoid some of the highly complex algorithms associated with more sophisticated neural networks.   Here we’re not so concerned with following rules outlined in artificial intelligence textbooks—we’re just hoping to make something interesting and brain-like.</simpara>
<simpara>Remember our good friend, the Vehicle?  You know, that object with a location, velocity, and acceleration?  That could obey Newton’s laws with an <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function and move around the window according to a variety of steering rules?</simpara>
<simpara>What if we added one more variable to our Vehicle class?</simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {

  // Giving the Vehicle a brain!
  Perceptron brain;

  PVector location;
  PVector velocity;
  PVector acceleration;
  [inline]//etc...</programlisting>
<simpara>Here’s our scenario.  Let’s say we have a Processing sketch with an ArrayList of targets and a single Vehicle.</simpara>
<simpara><emphasis role="strong"><phrase role="notetoself">[This should be a figure: 10.9]</phrase></emphasis></simpara>
<simpara>Let’s say that the Vehicle seeks all of the targets.   According to the principles of Chapter 6, we would next write a function that calculates a steering force towards each target, applying each force one at a time to the object’s acceleration.   Assuming the targets are an ArrayList of PVector objects, it would look something like:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void seek(ArrayList&lt;PVector&gt; targets) {
    for (PVector target : targets) {
      // For every target, apply a steering force towards the target.
      PVector force = seek(targets.get(i));
      applyForce(force);
    }
  }</programlisting>
<simpara>In Chapter 6, we also examined how we could create more dynamic simulations by weighting each steering force according to some rule.  For example, we could say that the further you are from a target, the stronger the force.</simpara>
<programlisting language="java" linenumbering="unnumbered"> void seek(ArrayList&lt;PVector&gt; targets) {
    for (PVector target : targets) {
      PVector force = seek(targets.get(i));
      float d = PVector.dist(target,location);
      float weight = map(d,0,width,0,5);
      // Weighting each steering force individually
      force.mult(weight);
      applyForce(force);
    }
  }</programlisting>
<simpara>But what if instead we could ask our brain (i.e. Perceptron) to take in all the forces as an input, process them according to weights of the Perceptron inputs, and generate an output steering force?   What if we could instead say:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void seek(ArrayList&lt;PVector&gt; targets) {

    // Make an array of inputs for our brain.
    PVector[] forces = new PVector[targets.size()];

    for (int i = 0; i &lt; forces.length; i++) {
      // Fill the array with a steering force
      forces[i] = seek(targets.get(i));
    }                                                                   for each target.

    // Ask our brain for a result and apply that as the force!
    PVector output = brain.process(forces);
    applyForce(output);
  }</programlisting>
<simpara>In other words, instead of weighting and accumulating the forces inside our Vehicle object, we simply pass an array of forces to the Vehicle’s “brain” object and allow the brain to weight and sum the forces for us.  The output is then applied as a steering force.  This opens up a range of possibilities. A vehicle could make decisions as to how to steer on its own, learning from its mistakes, and responding to stimuli in its environment.  Let’s see how this works.</simpara>
<simpara>We can use the line classification Perceptron as a model, with one important difference—the inputs are not single numbers, but vectors!     Let’s look at how the <emphasis role="strong"><phrase role="function">feedforward()</phrase></emphasis> function works in our Vehicle’s perceptron, alongside the one from our previous example.</simpara>
<passthrough><table class="code">
<tr>
<th>Vehicle PVector inputs</th>
<th>Line float inputs</th>
</tr>
<tr>
<td>
<pre>
PVector feedforward(PVector[] forces) {
  // Sum is a PVector.
  <b>PVector sum = new PVector();</b>
  for (int i = 0; i < weights.length; i++) {
    // Vector addition and multiplication
    <b>forces[i].mult(weights[i]);</b>
    <b>sum.add(forces[i]);</b>
  }
  // No activation function
  <b>return sum;</b>
}
</pre>
</td>
<td>
<pre>
int feedforward(float[] inputs) {
  // Sum is a float.
  <b>float sum = 0;</b>
  for (int i = 0; i < weights.length; i++) {
    // Scalar addition and multiplication
    <b>sum += inputs[i]*weights[i];</b>

  }
  // Activation Function
  <b>return activate(sum);</b>
}
</pre>
</td>
</tr>

</table></passthrough>
<simpara>Note how these two functions implement nearly identical algorithms, with two differences.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Summing PVectors.</emphasis></emphasis>  Instead of a series of numbers added together, each input is a PVector and must be multiplied by the weight and added to a sum according the mathematical PVector functions.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>No activation function.</emphasis></emphasis>   In this case, we’re taking the result and applying it directly as a steering force for the vehicle, so we’re not asking for a simple boolean value that classifies it in one of two categories.  Rather, we’re asking for raw output itself, the resulting overall force.
</simpara>
</listitem>
</orderedlist>
<simpara>Once the resulting steering force has been applied, it’s time to give feedback to the brain, i.e. <emphasis>reinforcement learning</emphasis>.   Was the decision to steer in that particular direction a good one or a bad one?  Presumably if some of the targets were predators (resulting in being eaten) and some of the targets were food (resulting in greater health), the network would adjust its weights in order to steer away from the predators and towards the food.</simpara>
<simpara>Let’s take a simpler example, where the Vehicle simply wants to stay close to the center of the window.    We’ll train the brain as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">    PVector desired = new PVector(width/2,height/2);
    PVector error = PVector.sub(desired, location);
    brain.train(forces,error);</programlisting>
<informalfigure id="chapter10_figure10">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_10.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>Figure 10.10</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here we are passing the brain a copy of all the inputs (which it will need for error correction) as well as an observation about its environment: a PVector that points from its current location to where it desires to be.  This PVector essentially serves as the error—the longer the PVector, the worse the Vehicle is performing; the shorter, the better (see Figure 10.10).</simpara>
<simpara>The brain can then apply this “error” vector (which has two error values, one for x and one for y) as a means for adjusting the weights, just as we did in the line classification example.</simpara>
<informaltable classname="mono"
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Training the Vehicle   </entry>
<entry align="left" valign="top">Training the Line Classifier</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>void train(PVector[] forces, PVector error) { +<?asciidoc-br?>
+<?asciidoc-br?>
+
  for (int i = 0; i &lt; weights.length; i++) {<?asciidoc-br?>
    weights[i] += c*error.x*forces[i].x;<?asciidoc-br?>
    weights[i] += c*error.y*forces[i].y;<?asciidoc-br?>
  }<?asciidoc-br?>
}</simpara></entry>
<entry align="left" valign="top"><simpara>void train(float[] inputs, int desired) {<?asciidoc-br?></simpara>
<simpara>  int guess = feedforward(inputs);<?asciidoc-br?>
  float error = desired - guess;</simpara>
<simpara>  for (int i = 0; i &lt; weights.length; i++) {<?asciidoc-br?>
    weights[i] += c * error * inputs[i];<?asciidoc-br?></simpara>
<simpara>  }<?asciidoc-br?>
}</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Because the Vehicle observes its own error, there is no need to calculate one; we can simply receive the error as an argument.  Notice how the change in weight is processed twice, once for the error along the x-axis and once for the y-axis.</simpara>
<programlisting language="java" linenumbering="unnumbered">weights[i] += c*error.x*forces[i].x;
weights[i] += c*error.y*forces[i].y;</programlisting>
<simpara>We can now look at the Vehicle class and see how the <emphasis role="strong"><emphasis>steer</emphasis></emphasis> function uses a Perceptron to control the overall steering force.   The new content from this chapter is highlighted.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_ex02.png" canvas="processingjs/chapter10/_10_02_SeekingNeural/_10_02_SeekingNeural.pde processingjs/chapter10/_10_02_SeekingNeural/Perceptron.pde processingjs/chapter10/_10_02_SeekingNeural/Vehicle.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter10/ch10_ex02.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter10_example2"><emphasis role="strong"><phrase role="example">Example 10.2: Perceptron steering</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">class Vehicle {

  // The Vehicle now has a brain.
  Perceptron brain;

  // Same old variables for physics
  PVector location;
  PVector velocity;
  PVector acceleration;
  float maxforce;
  float maxspeed;

  // The Vehicle creates a Perceptron with n inputs and a learning constant.
  Vehicle(int n, float x, float y) {
    brain = new Perceptron(n,0.001);
    acceleration = new PVector(0,0);
    velocity = new PVector(0,0);
    location = new PVector(x,y);
    maxspeed = 4;
    maxforce = 0.1;
  }

  // Same old update() function
  void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    location.add(velocity);
    acceleration.mult(0);
  }

  // Same old applyForce() function
  void applyForce(PVector force) {
    acceleration.add(force);
  }

  void steer(ArrayList&lt;PVector&gt; targets) {
    PVector[] forces = new PVector[targets.size()];

    for (int i = 0; i &lt; forces.length; i++) {
      forces[i] = seek(targets.get(i));
    }
    // All the steering forces are inputs.
    PVector result = brain.feedforward(forces);

    // The result is applied.
    applyForce(result);

    // The brain is trained according to
    // the distance to the center.
    PVector desired = new PVector(width/2,height/2);
    PVector error = PVector.sub(desired, location);
    brain.train(forces,error);

  }


  // Same old seek() function
  PVector seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    return steer;
  }

}</programlisting>
<example id="chapter10_exercise3">
<title>Exercise 10.3</title>
<simpara>Visualize the weights of the network.  Try mapping each target’s corresponding weight to its brightness.</simpara>
</example>
<example id="chapter10_exercise4">
<title>Exercise 10.4</title>
<simpara>Try different rules for reinforcement learning.  What if some targets are desirable and some are undesirable?</simpara>
</example>
</section>
<section id="chapter10_section6">
<title>10.6  It’s a “Network,” Remember?</title>
<simpara>Yes, a perceptron can have multiple inputs, but it is still a lonely neuron.  The power of neural networks comes in the networking itself.   Perceptrons are, sadly, incredibly limited in their abilities.    If you read an AI textbook, it will say that a Perceptron can only solve linearly separable problems.  What’s a linearly separable problem?  Let’s take a look at our first example, which determined whether points were on one side of a line or the other.</simpara>
<informalfigure id="chapter10_figure11">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_11.png" />
  </imageobject>
  <textobject><phrase>Figure 10.11</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>On the left of Figure 10.11, we have classic linearly separable data.  Graph all of the possibilities; if you can classify the data with a straight line, then it is linearly separable.  On the right, however, is non-linearly separable data.  You can’t draw a straight line to separate the black dots from the gray ones.</simpara>
<simpara>One of the simplest examples of a non-linearly separable problem is XOR, or “exclusive or.”  We’re all familiar with AND.  For <emphasis role="strong"><emphasis>A</emphasis></emphasis> AND <emphasis role="strong"><emphasis>B</emphasis></emphasis> to be true, both <emphasis role="strong"><emphasis>A</emphasis></emphasis> and <emphasis role="strong"><emphasis>B</emphasis></emphasis> must be true.  With OR, either <emphasis role="strong"><emphasis>A</emphasis></emphasis> or <emphasis role="strong"><emphasis>B</emphasis></emphasis> can be true for <emphasis role="strong"><emphasis>A</emphasis></emphasis> OR <emphasis role="strong"><emphasis>B</emphasis></emphasis> to evaluate as true. These are both linearly separable problems.  Let’s look at the solution space, a “truth table.”</simpara>
<informalfigure id="chapter10_figure12">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_12.png" />
  </imageobject>
  <textobject><phrase>Figure 10.12</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
See how you can draw a line to separate the true outputs from the false ones?</simpara>
<simpara><emphasis role="strong"><emphasis>XOR</emphasis></emphasis> is the equivalent of <emphasis role="strong"><emphasis>OR</emphasis></emphasis> and <emphasis role="strong"><emphasis>NOT AND</emphasis></emphasis>.  In other words, <emphasis role="strong"><emphasis>A</emphasis></emphasis> <emphasis role="strong"><emphasis>XOR</emphasis></emphasis> <emphasis role="strong"><emphasis>B</emphasis></emphasis> only evaluates to true if one of them is true.  If both are false or both are true, then we get false.  Take a look at the following truth table.</simpara>
<informalfigure id="chapter10_figure13">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_13.png" />
  </imageobject>
  <textobject><phrase>Figure 10.13</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>￼
This is not linearly separable.  Try to draw a line to separate the true outputs from the false ones —you can’t!</simpara>
<simpara>So perceptrons can’t even solve something as simple as <emphasis role="strong"><emphasis>XOR</emphasis></emphasis>.  But what if we made a network out of two Perceptrons?  If one perceptron can solve <emphasis role="strong"><emphasis>OR</emphasis></emphasis> and one perceptron can solve <emphasis role="strong"><emphasis>NOT AND</emphasis></emphasis>, then two perceptrons combined can solve <emphasis role="strong"><emphasis>XOR</emphasis></emphasis>.</simpara>
<informalfigure id="chapter10_figure14">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_14.png" />
  </imageobject>
  <textobject><phrase>Figure 10.14</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">[Missing 10.14]</phrase></emphasis></simpara>
<simpara>The above diagram is known as a multi-layered Perceptron, a network of many neurons.   Some are input neurons and receive the inputs; some are part of what’s called a “hidden” layer (as they are connected to neither the inputs or outputs of the network directly); and then there are the output neurons, from which we read the results.</simpara>
<simpara>Training these networks is much more complicated.  With the simple perceptron, we could easily evaluate how to change the weights according to the error. But here there are so many different connections, each in a different layer of the network. How does one know how much each neuron or connection contributed to the overall error of the network?</simpara>
<simpara>The solution to optimizing weights of a multi-layered network is known as backpropagation.  The output of the network is generated in the same manner as a Perceptron.   The inputs multiplied by the weights are summed and fed forward through the network.  The difference here is that they pass through additional layers of neurons before reaching the output. Training the network (i.e. adjusting the weights) also involves taking the error (desired result - guess).  The error, however, must be fed backwards through the network. The final error ultimately adjusts the weights of all the connections.</simpara>
<simpara>Backpropagation is a bit beyond the scope of this book and involves a fancier activation function (called the sigmoid function) as well as some basic calculus.  If you are interested in how backpropagation works, check the book website (and github repository) for an example that solves XOR using a multi-layered feed forward network with backpropagation.</simpara>
<simpara>Instead, here we’ll focus on a code framework for building the visual architecture of a network.  We’ll make Neuron objects and Connection objects from which a Network object can be created and animated to show the feed forward process.   This will closely resemble some of the force-directed graph examples we examined in Chapter 5 (toxiclibs).</simpara>
</section>
<section id="chapter10_section7">
<title>10.7  Neural Network Diagram</title>
<simpara>Our goal will be to create the following simple network diagram:</simpara>
<informalfigure id="chapter10_figure15">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_15.png" />
  </imageobject>
  <textobject><phrase>Figure 10.15</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The primary building block for the diagram is a neuron. A neuron is a simple object, an entity with an (x,y) location.</simpara>
<programlisting language="java" linenumbering="unnumbered">// An incredibly simple neuron class stores and displays the location of a single Neuron
class Neuron {
  PVector location;

  Neuron(float x, float y) {
    location = new PVector(x, y);
  }

  void display() {
    stroke(0);
    fill(0);
    ellipse(location.x, location.y, 16, 16);
  }
}</programlisting>
<simpara>The Network class can then manage an ArrayList of neurons, as well as have its own location (so that each Neuron is drawn relative to the Network’s center).  This is Particle Systems 101.  We have a single element (a Neuron) and a Network (a “system” of many Neurons).</simpara>
<programlisting language="java" linenumbering="unnumbered">// A Network is a list of neurons.
class Network {
  ArrayList&lt;Neuron&gt; neurons;
  PVector location;

  Network(float x, float y) {
    location = new PVector(x,y);
    neurons = new ArrayList&lt;Neuron&gt;();
  }

  // We can add an neuron to the network.
  void addNeuron(Neuron n) {
    neurons.add(n);
  }

  // We can draw the entire network.
  void display() {
    pushMatrix();
    translate(location.x, location.y);
    for (Neuron n : neurons) {
      n.display();
    }
    popMatrix();
  }
}</programlisting>
<simpara>Now, we can pretty easily make the diagram above.</simpara>
<programlisting language="java" linenumbering="unnumbered">Network network;

void setup() {
  size(640, 360);
  // Make a Network.
  network = new Network(width/2,height/2);

  // Make the Neurons.
  Neuron a = new Neuron(-200,0);
  Neuron b = new Neuron(0,100);
  Neuron c = new Neuron(0,-100);
  Neuron d = new Neuron(200,0);

  // Add the Neurons to the network.
  network.addNeuron(a);
  network.addNeuron(b);
  network.addNeuron(c);
  network.addNeuron(d);
}

void draw() {
  background(255);
  // Show the network.
  network.display();
}</programlisting>
<simpara>The above yields:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_ex03a.png" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter10/ch10_ex03a.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>What’s missing, of course, is the connection.   We can consider a Connection object to be made up of three elements, two Neurons (from Neuron <emphasis role="strong"><phrase role="var">a</phrase></emphasis> to Neuron <emphasis role="strong"><phrase role="var">b</phrase></emphasis>) and a weight.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Connection {
  // The Connection is between two neurons.
  Neuron a;
  Neuron b;
  // The Connection has a weight.
  float weight;

  Connection(Neuron from, Neuron to,float w) {
    weight = w;
    a = from;
    b = to;
  }

  // The connection is drawn as a line.
  void display() {
    stroke(0);
    strokeWeight(weight*4);
    line(a.location.x, a.location.y, b.location.x, b.location.y);
  }
}</programlisting>
<simpara>Once we have the idea of a Connection object, we can write a function (let’s put it inside the Network class) that connects two neurons together—the goal being that in addition to making the Neurons in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>, we can also connect them.</simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(640, 360);
  network = new Network(width/2,height/2);

  Neuron a = new Neuron(-200,0);
  Neuron b = new Neuron(0,100);
  Neuron c = new Neuron(0,-100);
  Neuron d = new Neuron(200,0);

  // Making connections between the Neurons
  network.connect(a,b);
  network.connect(a,c);
  network.connect(b,d);
  network.connect(c,d);

  network.addNeuron(a);
  network.addNeuron(b);
  network.addNeuron(c);
  network.addNeuron(d);
}</programlisting>
<simpara>The Network class therefore needs a new function called <emphasis role="strong"><phrase role="function">connect()</phrase></emphasis>, which makes a Connection object between the two specified Neurons.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void connect(Neuron a, Neuron b) {
    // Connection has a random weight.
    Connection c = new Connection(a, b, random(1));

    [inline]// But what do we do with the Connection object?
  }</programlisting>
<simpara>Presumably, we might think that the Network should store an ArrayList of Connection objects, just like it stores an ArrayList of Neurons.  While useful, in this case such an ArrayList is not necessary and is missing an important feature that we need.  Ultimately we plan to “feed forward” through the network.  So the Neuron objects themselves need to know to which Neurons they are connected in the “forward” direction.  In other words, each Neuron should have its own list of Connection objects.   When <emphasis role="strong"><phrase role="var">a</phrase></emphasis> connects to <emphasis role="strong"><phrase role="var">b</phrase></emphasis>, we want <emphasis role="strong"><phrase role="var">a</phrase></emphasis> to store a reference of that connection so that it can pass its output to <emphasis role="strong"><phrase role="var">b</phrase></emphasis> when the time comes.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void connect(Neuron a, Neuron b) {
    Connection c = new Connection(a, b, random(1));
    a.addConnection(c);
  }</programlisting>
<simpara>In some cases, we also might want Neuron <emphasis role="strong"><phrase role="var">b</phrase></emphasis> to know about this Connection object, but in this particular example we are only going to pass information in one direction.</simpara>
<simpara>For this to work, we have to add an ArrayList of Connection objects to the Neuron class. Then we implement the <emphasis role="strong"><phrase role="function">addConnection()</phrase></emphasis> function that stores the Connection in that ArrayList.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Neuron {
  PVector location;

  // The Neuron stores its connections.
  ArrayList&lt;Connection&gt; connections;

  Neuron(float x, float y) {
    location = new PVector(x, y);
    connections = new ArrayList&lt;Connection&gt;();
  }

  // Adding a Connection to this Neuron
  void addConnection(Connection c) {
    connections.add(c);
  }</programlisting>
<simpara>The Neuron’s <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> function can draw the connections as well.  And finally, we have our Network diagram.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_ex03.png" canvas="processingjs/chapter10/_10_03_NetworkViz/_10_03_NetworkViz.pde processingjs/chapter10/_10_03_NetworkViz/Connection.pde processingjs/chapter10/_10_03_NetworkViz/Network.pde processingjs/chapter10/_10_03_NetworkViz/Neuron.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter10/ch10_ex03.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter10_example3"><emphasis role="strong"><phrase role="example">Example 10.3: Neural Network Diagram</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">  void display() {
    stroke(0);
    strokeWeight(1);
    fill(0);
    ellipse(location.x, location.y, 16, 16);

    // Drawing all the Connections
    for (Connection c : connections) {
      c.display();
    }
  }
}</programlisting>
</section>
<section id="chapter10_section8">
<title>10.8  Animating Feed Forward</title>
<simpara>An interesting problem to consider is how to visualize the flow of information as it travels throughout a neural network.    Our network is built on the feed forward model, meaning an input arrives at the first neuron (drawn on the lefthand side of the window) and the output of that neuron flows across the connections to the right until it exits as output from the network itself.</simpara>
<simpara>Our first step is to add a function to the network to receive this input, which we’ll make a random number between zero and one.</simpara>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  // All our old network set up code


  // A new function to send in an input
  network.feedforward(random(1));
}</programlisting>
<simpara>The network, which manages all the neurons, can choose to which neurons it should apply that input.  In this case, we’ll do something simple and just feed a single input into the first neuron in the ArrayList, which happens to be the left-most one.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Network {

  // A new function to feed an
  // input into the Neuron
  void feedforward(float input) {
    Neuron start = neurons.get(0);
    start.feedforward(input);
  }</programlisting>
<simpara>What did we do?  Well, we made it necessary to add a function called <emphasis role="strong"><phrase role="function">feedforward()</phrase></emphasis> in the Neuron class that will receive the input and process it.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Neuron

  void feedforward(float input) {
     // What do we do with the input?

  }</programlisting>
<simpara>If you recall from working with our Perceptron, the standard task that the processing unit performs is to sum up all of its inputs.  So if our neuron class adds a variable called sum, it can simply accumulate the inputs as they are received.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Neuron

  int sum = 0; // [bold]

  void feedforward(float input) {
    // Accumulate the sums.
    sum += input; // [bold]
  }</programlisting>
<simpara>The neuron should then decide whether it should “fire,” or pass an output through any of its connections to the next layer in the network.  Here we can create a really simple activation function: if the sum is greater than one, fire!</simpara>
<programlisting language="java" linenumbering="unnumbered"> void feedforward(float input) {
    sum += input;
    // Activate the neuron and fire the outputs?
    if (sum &gt; 1) {
      fire();
      // If we’ve fired off our output,
      // we can reset our sum to 0.
      sum = 0;
    }
  }</programlisting>
<simpara>Now, what do we do in the <emphasis role="strong"><phrase role="function">fire()</phrase></emphasis> function?  If you recall, each neuron keeps track of its connections to other neurons.  So all we need to do is loop through those connections and <emphasis role="strong"><phrase role="function">feedforward()</phrase></emphasis> the Neuron’s output.  For this simple example, we’ll just take the Neuron’s sum variable and make it the output.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void fire() {
    for (Connection c : connections) {
      // The Neuron sends the sum out
      // through all of its connections
      c.feedforward(sum);
    }
  }</programlisting>
<simpara>Here’s where things get a little tricky.  After all, our job here is not to actually make a functioning neural network, but to animate a simulation of one.  If the neural network were just continuing its work, it would instantly pass those inputs (multiplied by the connection’s weight) along to the connected Neurons.  We’d say something like:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Connection {

  void feedforward(float val) {
    b.feedforward(val*weight);
  }</programlisting>
<simpara>But this is not what we want. What we want to do is draw something that we can see traveling along the connection from Neuron <emphasis role="strong"><phrase role="var">a</phrase></emphasis> to Neuron <emphasis role="strong"><phrase role="var">b</phrase></emphasis>.</simpara>
<simpara>Let’s first think about how we might do that. We know the location of Neuron <emphasis role="strong"><phrase role="var">a</phrase></emphasis>; it’s the PVector <emphasis role="strong"><phrase role="var">a.location</phrase></emphasis>.  Neuron <emphasis role="strong"><phrase role="var">b</phrase></emphasis> is located at <emphasis role="strong"><phrase role="var">b.location</phrase></emphasis>.    What we need to do is start something moving from Neuron <emphasis role="strong"><phrase role="var">a</phrase></emphasis> by creating another PVector that will store the path of our traveling data.</simpara>
<programlisting language="java" linenumbering="unnumbered">  PVector sender = a.location.get();</programlisting>
<simpara>Once we have a copy of that location, we can use any of the motion algorithms that we’ve studied throughout this book to move along this path.  Here—let’s pick something very simple and just interpolate from a to b.</simpara>
<programlisting language="java" linenumbering="unnumbered">  sender.x = lerp(sender.x, b.location.x, 0.1);
  sender.y = lerp(sender.y, b.location.y, 0.1);</programlisting>
<simpara>Along with the connection’s line, we can then draw a circle at that location:</simpara>
<programlisting language="java" linenumbering="unnumbered">  stroke(0);
  line(a.location.x, a.location.y, b.location.x, b.location.y);
  fill(0);
  ellipse(sender.x, sender.y, 8, 8); // [bold]</programlisting>
<simpara>This resembles the following:</simpara>
<informalfigure id="chapter10_figure16">
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_16.png" />
  </imageobject>
  <textobject><phrase>Figure 10.16</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="note to self">[Missing this illustration, also need to label A and B Neurons]</phrase></emphasis></simpara>
<simpara>Ok, so that’s how we might move something along the connection.  But how do we know when to do so?   We start this process the moment the Connection object receives the “feedforward” signal.   We can keep track of this process by employing a simple boolean to know whether the connection is sending or not.    Before, we had:</simpara>
<programlisting language="java" linenumbering="unnumbered">  void feedforward(float val) {
    b.feedforward(val*weight);
  }</programlisting>
<simpara>Now, instead of sending the value on straight away, we’ll trigger an animation:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Connection {

  boolean sending = false;
  PVector sender;
  float output;

  void feedforward(float val) {
    // Sending is now true.
    sending = true;
    // Start the animation at location of Neuron A.
    sender = a.location.get();
    // Store the output for when it is actually time to feed it forward.
    output = val*weight;
  }</programlisting>
<simpara>Notice how our connection class now needs three new variables.  We need a boolean “sending” that starts as false and that will track whether or not the Connection is actively sending (i.e. animating).  We need a PVector “sender” for the location where we’ll draw the traveling dot.  And since we aren’t passing the output along this instant, we’ll need to store it in a variable that will do the job later.</simpara>
<simpara>The <emphasis role="strong"><phrase role="function">feedforward()</phrase></emphasis> function is called the moment the Connection becomes active.  Once it’s active, we’ll need to call another function continuously (each time through <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>), one that will update the location of the traveling data.</simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {
    if (sending) {
      // As long as we’re sending, interpolate our points.
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);
    }
  }</programlisting>
<simpara>We’re missing a key element, however.  We need to check if the sender has arrived at location b, and if it has, feed forward that output to the next Neuron.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {
    if (sending) {
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);

      // How far are we from Neuron b?
      float d = PVector.dist(sender, b.location); // [bold]

      // If we’re close enough (within one pixel) pass on the output. Turn off sending.
      if (d &lt; 1) { // [bold]
        b.feedforward(output); // [bold]
        sending = false; // [bold]
      }
    }
  }</programlisting>
<simpara>Let’s look at the Connection class all together, as well as our new draw() function.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_ex04.png" canvas="processingjs/chapter10/_10_04_NetworkAnimation/_10_04_NetworkAnimation.pde processingjs/chapter10/_10_04_NetworkAnimation/Connection.pde processingjs/chapter10/_10_04_NetworkAnimation/Network.pde processingjs/chapter10/_10_04_NetworkAnimation/Neuron.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter10/ch10_ex04.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara id="chapter10_example4"><emphasis role="strong"><phrase role="example">Example 10.4: Animating Neural Network Diagram</phrase></emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);
  // The Network now has a new update() method that updates all of the Connection objects.
  network.update(); // [bold]
  network.display();

  if (frameCount % 30 == 0) { // [bold]
    // We are choosing to send in an input every 30 frames.
    network.feedforward(random(1)); // [bold]
  } // [bold]
}

class Connection {
  // The Connection’s data
  float weight;
  Neuron a;
  Neuron b;

  // Variables to track the animation
  boolean sending = false;
  PVector sender;
  float output = 0;

  Connection(Neuron from, Neuron to, float w) {
    weight = w;
    a = from;
    b = to;
  }

  // The Connection is active with data traveling from a to b.
  void feedforward(float val) {
    output = val*weight;
    sender = a.location.get();
    sending = true;
  }

  // Update the animation if it is sending.
  void update() {
    if (sending) {
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);
      float d = PVector.dist(sender, b.location);
      if (d &lt; 1) {
        b.feedforward(output);
        sending = false;
      }
    }
  }

  // Draw the connection as a line and traveling circle.
  void display() {
    stroke(0);
    strokeWeight(1+weight*4);
    line(a.location.x, a.location.y, b.location.x, b.location.y);

    if (sending) {
      fill(0);
      strokeWeight(1);
      ellipse(sender.x, sender.y, 16, 16);
    }
  }
}</programlisting>
<example id="chapter10_exercise5">
<title>Exercise 10.5</title>
<simpara>The Network in the above example was manually configured by setting the location of each Neuron and its connections with hard-coded values.  Rewrite this example to generate the network’s layout via an algorithm.  Can you make a circular network diagram? A random one? An example of a multi-layered network is below.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter10/ch10_exc05.png" canvas="processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Ex_10_5_LayeredNetworkAnimation.pde processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Connection.pde processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Network.pde processingjs/chapter10/Ex_10_5_LayeredNetworkAnimation/Neuron.pde" classname="screenshot" />
  </imageobject>
  <textobject><phrase>imgs/chapter10/ch10_exc05.png</phrase></textobject>
</mediaobject>
</informalfigure>
</example>
<example id="chapter10_exercise6">
<title>Exercise 10.6</title>
<simpara>Rewrite the example so that each Neuron keeps track of its forward and backward connections.  Can you feed inputs through the network in any direction?</simpara>
</example>
<example id="chapter10_exercise7">
<title>Exercise 10.7</title>
<simpara>Instead of <emphasis role="strong"><phrase role="function">lerp()</phrase></emphasis>, use moving bodies with steering forces to visualize the flow of information in the network.</simpara>
</example>
<tip>
<title>The Ecosystem Project</title>
<simpara>Step 10 Exercise:</simpara>
<simpara>Try incorporating the concept of a “brain” into your creatures.</simpara>
<itemizedlist>
<listitem>
<simpara>
Use reinforcement learning in the creatures’ decision-making process.
</simpara>
</listitem>
<listitem>
<simpara>
Create a creature that features a visualization of its brain as part of its design (even if the brain itself is not functional).
</simpara>
</listitem>
<listitem>
<simpara>
Can the ecosystem as a whole emulate the brain?  Can elements of the environment be neurons and the creatures act as inputs and outputs?
</simpara>
</listitem>
</itemizedlist>
</tip>
</section>
</chapter>
</book>
